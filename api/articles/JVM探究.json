{"title":"JVM 理论探究","slug":"JVM探究","date":"2021-05-06T08:25:44.000Z","updated":"2021-05-06T08:26:26.000Z","comments":true,"path":"api/articles/JVM探究.json","excerpt":null,"covers":["https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501155102.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502005237.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501161637.png","https://img-blog.csdnimg.cn/20201217213314510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501163417.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501164943.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501164956.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501165007.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501173518.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501173432.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501174842.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501175400.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501180058.png","https://img-blog.csdnimg.cn/20200715152713345.png#pic_center","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501190206.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501191953.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501192059.png"],"content":"<ul>\n<li>请你谈谈你对 JVM 的理解，Java8 虚拟机和之前的变化更新？</li>\n<li>什么是 OOM，什么是栈溢出 StackOverFlowError？怎么分析？</li>\n<li>JVM 常用调优参数有哪些？</li>\n<li>内存快照如何抓取，怎么分析 Dump 文件？</li>\n<li>谈谈 JVM 中，类加载器你的认识？</li>\n</ul>\n<h2 id=\"JVM-的位置\"><a href=\"#JVM-的位置\" class=\"headerlink\" title=\"JVM 的位置\"></a>JVM 的位置</h2><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501155102.png\" alt=\"JVM图解\"></p>\n<h2 id=\"JVM-的体系结构\"><a href=\"#JVM-的体系结构\" class=\"headerlink\" title=\"JVM 的体系结构\"></a>JVM 的体系结构</h2><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502005237.png\" alt=\"image-20210502005237430\"></p>\n<p>百分之 99 的 JVM 调优都是在堆中调优，Java 栈、本地方法栈、程序计数器是不会有垃圾存在的。</p>\n<h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><p>作用：加载 Class 文件~</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501161637.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>虚拟机自带的加载器</li>\n<li>启动类（根）加载器</li>\n<li>扩展类加载器</li>\n<li>应用程序（系统类）加载器</li>\n</ul>\n<h2 id=\"双清委派机制\"><a href=\"#双清委派机制\" class=\"headerlink\" title=\"双清委派机制\"></a>双清委派机制</h2><p><img src=\"https://img-blog.csdnimg.cn/20201217213314510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<h2 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h2><p>Java 安全模型的核心就是 Java 沙箱(sandbox)</p>\n<p>什么是沙箱?沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。</p>\n<p>沙箱主要限制系统资源访问，那系统资源包括什么? CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>\n<p>所有的 Java 程序运行都可以指定沙箱，可以定制安全策略。</p>\n<p>在 Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码,可以访问一切本地资源。而对于非授信的远程代码在早期的 Java 实现中，安全依赖于沙箱 Sandbox)机制。如下图所示 JDK1.0 安全模型</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501163417.png\" alt=\"img\"></p>\n<p>但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的 Java1.1 版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示 JDK1.1 安全模型</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501164943.png\" alt=\"在这里插入图片描述\"></p>\n<p>在 Java1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501164956.png\" alt=\"在这里插入图片描述\"></p>\n<p>当前最新的安全机制实现，则引入了域(Domain)的概念。虚拟机会把所有代码加载到不同的系统域和应用域,系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain),对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示最新的安全模型(jdk 1.6)</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501165007.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>组成沙箱的基本条件</strong></p>\n<ul>\n<li>字节码校验器(bytecode verifier) :确保 Java 类文件遵循 Java 语言规范。这样可以帮助 Java 程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。</li>\n<li>类裝载器(class loader) :其中类装载器在 3 个方面对 Java 沙箱起作用<ul>\n<li>它防止恶意代码去干涉善意的代码;</li>\n<li>它守护了被信任的类库边界;</li>\n<li>它将代码归入保护域,确定了代码可以进行哪些操作；</li>\n</ul>\n</li>\n</ul>\n<p>虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成， 每一个被装载的类将有一个名字，这个命名空间是由 Java 虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。</p>\n<p>类装载器采用的机制是双亲委派模式。</p>\n<ol>\n<li>从最内层 JVM 自带类加载器开始加载,外层恶意同名类得不到加载从而无法使用;</li>\n<li>由于严格通过包来区分了访问域,外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。</li>\n</ol>\n<ul>\n<li>存取控制器(access controller) :存取控制器可以控制核心 API 对操作系统的存取权限，而这个控制的策略设定,可以由用户指定。</li>\n<li>安全管理器(security manager) : 是核心 API 和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。</li>\n<li>安全软件包(security package) : java.security 下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括:<ul>\n<li>安全提供者</li>\n<li>消息摘要</li>\n<li>数字签名</li>\n<li>加密</li>\n<li>鉴别</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Native\"><a href=\"#Native\" class=\"headerlink\" title=\"Native\"></a>Native</h2><ul>\n<li>native :凡是带了 native 关键字的，说明 java 的作用范围达不到了，回去调用底层 c 语言的库!</li>\n<li>会进入本地方法栈</li>\n<li>调用本地方法本地接口 JNI (Java Native Interface)</li>\n<li>JNI 作用:开拓 Java 的使用，融合不同的编程语言为 Java 所用!最初: C、C++</li>\n<li>Java 诞生的时候 C、C++横行，想要立足，必须要有调用 C、C++的程序</li>\n<li>它在内存区域中专门开辟了一块标记区域: Native Method Stack，登记 native 方法</li>\n<li>在最终执行的时候，加载本地方法库中的方法通过 JNI</li>\n</ul>\n<h3 id=\"Native-Method-Stack\"><a href=\"#Native-Method-Stack\" class=\"headerlink\" title=\"Native Method Stack\"></a><strong>Native Method Stack</strong></h3><p>它的具体做法是 Native Method Stack 中登记 native 方法，在( Execution Engine )执行引擎执行的时候加载 Native Libraies。[本地库]</p>\n<h3 id=\"Native-Interface-本地接口\"><a href=\"#Native-Interface-本地接口\" class=\"headerlink\" title=\"Native Interface 本地接口\"></a><strong>Native Interface 本地接口</strong></h3><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序, Java 在诞生的时候是 C/C++横行的时候，想要立足，必须有调用 C、C++的程序，于是就在内存中专门开辟了块区域处理标记为 native 的代码，它的具体做法是在 Native Method Stack 中登记 native 方法,在( Execution Engine )执行引擎执行的时候加载 Native Libraies。</p>\n<p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间通信很发达，比如可以使用 Socket 通信,也可以使用 Web Service 等等，不多做介绍!</p>\n<h2 id=\"PC-寄存器\"><a href=\"#PC-寄存器\" class=\"headerlink\" title=\"PC 寄存器\"></a>PC 寄存器</h2><p>程序计数器: Program Counter Register</p>\n<p>每个线程都有一个程序计数器，是线程私有的，就是一个指针, 指向方法区中的方法字节码(用来存储指向像一条指令的地址， 也即将要执行的指令代码)，在执行引擎读取下一条指令, 是一个非常小的内存空间，几乎可以忽略不计</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区是被所有线程共享,所有字段和方法字节码，以及一些特殊方法，如构造函数,接口代码也在此定义,简单说，所有定义的方法的信息都保存在该区域,此区域属于共享区间;</p>\n<p>==静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关==</p>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>栈:先进后出</p>\n<p>桶:后进先出</p>\n<p>队列:先进先出( FIFO : First Input First Output )</p>\n<p>栈：<strong>栈内存，主管程序的运行，生命周期和线程同步</strong></p>\n<p><strong>线程结束，栈内存也就是释放，对于栈来说，不存在垃圾回收问题</strong></p>\n<p>一旦线程结束，栈就 Over!</p>\n<p>栈内存中:</p>\n<p><strong>8 大基本类型+对象引用+实例的方法</strong></p>\n<p><strong>栈运行原理:栈帧</strong></p>\n<p>栈满了: StackOverflowError</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501173518.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501173432.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"三种-JVM\"><a href=\"#三种-JVM\" class=\"headerlink\" title=\"三种 JVM\"></a>三种 JVM</h2><ul>\n<li><p><strong>HotSpot VM</strong></p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代</span><br><span class=\"line\">码，然后通知<span class=\"keyword\">JIT编译器以方法为单位进行编译。 </span>如果一个方法被频繁调用，或方法中有效</span><br><span class=\"line\">循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。 通过编译器与解释器</span><br><span class=\"line\">恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待</span><br><span class=\"line\">本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码</span><br><span class=\"line\">优化技术，输出质量更高的本地代码</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>JRockit</strong></p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>.<span class=\"keyword\">JRockit </span>VM曾经号称“世界上速度最快的<span class=\"keyword\">Java虚拟机”</span></span><br><span class=\"line\"><span class=\"keyword\"></span><span class=\"number\">2</span>.由于专注于服务器端应用，它可以不太关注程序启动速度，因此<span class=\"keyword\">JRockit内部不包含解析器实现，全部代码都靠即时</span></span><br><span class=\"line\"><span class=\"keyword\"></span>编译器编译后执行。 除此之外，<span class=\"keyword\">JRockit的垃圾收集器和MissionControl服务套件等部分的实</span></span><br><span class=\"line\"><span class=\"keyword\"></span>现，在众多<span class=\"keyword\">Java虚拟机中也一直处于领先水平</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>J9</strong></p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.IBM J9 VM并不是IBM公司唯一的Java虚拟机，不过是目前其主力发展的Java虚拟机，IBM J9 VM原本是内部开发代号，</span><br><span class=\"line\">正式名称是“IBM Technology for Java Virtual Machine”，简称IT4J，只是这个名字太拗口了一点，普及程度不如J9.</span><br><span class=\"line\">2.与BEA JRockit专注于服务器端应用不同，IBM J9的市场定位与Sun HotSpot比较接近，它是一款设计上从服务器端</span><br><span class=\"line\">到桌面应用再到嵌入式都全面考虑的多用途虚拟机<span class=\"strong\">***</span>，J9的开发目的是作为IBM公司各种Java产品的执行平台，它的主</span><br><span class=\"line\">要市场是和IBM产品（如IBM WebSphere等）搭配以及在IBM AIX和z/OS这些平台上部署Java</span><br><span class=\"line\">应用。</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>Heap, 一个 JVM 只有一个堆内存，堆内存的大小是可以调节的。</p>\n<p>类加载器读取了类文件后，一般会把什么东西放到堆中?</p>\n<p>类, 方法，常量,变量~，保存我们所有引用类型的真实对象;</p>\n<p>堆内存中还要细分为三个区域:</p>\n<ul>\n<li>新生区(伊甸园区) Young/New</li>\n<li>老年区 old</li>\n<li>永久区 Perm</li>\n</ul>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501174842.png\" alt=\"img\"></p>\n<p>GC 垃圾回收,主要是在伊甸园区和养老区~</p>\n<p>假设内存满了,OOM,堆内存不够! java.lang.OutOfMemoryError:Java heap space</p>\n<p>永久存储区里存放的都是 Java 自带的 例如 lang 包中的类 如果不存在这些，Java 就跑不起来了</p>\n<p>在 JDK8 以后，永久存储区改了个名字(元空间)</p>\n<p><a href=\"https://www.cnblogs.com/duanxz/p/3726574.html\">参考链接</a></p>\n<h2 id=\"新生区、老年区\"><a href=\"#新生区、老年区\" class=\"headerlink\" title=\"新生区、老年区\"></a>新生区、老年区</h2><ul>\n<li>对象：诞生和成长的地方，甚至死亡;</li>\n<li>伊甸园，所有的对象都是在伊甸园区 new 出来的!</li>\n<li>幸存者区(0,1)</li>\n</ul>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501175400.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>伊甸园满了就触发轻 GC，经过轻 GC 存活下来的就到了幸存者区，幸存者区满之后意味着新生区也满了，则触发重 GC，经过重 GC 之后存活下来的就到了养老区。</strong></p>\n<p>真理:经过研究，99%的对象都是临时对象!|</p>\n<p><a href=\"https://www.cnblogs.com/duanxz/p/3726574.html\">参考链接</a></p>\n<h2 id=\"永久区\"><a href=\"#永久区\" class=\"headerlink\" title=\"永久区\"></a>永久区</h2><p>这个区域常驻内存的。用来存放 JDK 自身携带的 Class 对象。Interface 元数据，存储的是 Java 运行时的一些环境~ 这个区域不存在垃圾回收，关闭虚拟机就会释放内存</p>\n<ul>\n<li>jdk1.6 之前：永久代,常量池是在方法区;</li>\n<li>jdk1.7：永久代,但是慢慢的退化了，去永久代，常量池在堆中</li>\n<li>jdk1.8 之后：无永久代,常量池在元空间</li>\n</ul>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501180058.png\" alt=\"在这里插入图片描述\"></p>\n<p>元空间：逻辑上存在，物理上不存在 (因为存储在本地磁盘内) 所以最后并不算在 JVM 虚拟机内存中</p>\n<h2 id=\"堆内存调优\"><a href=\"#堆内存调优\" class=\"headerlink\" title=\"堆内存调优\"></a>堆内存调优</h2><p>测试代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        s += <span class=\"string\">&quot;11111111111111111111111111111111111111111111111111111&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20200715152713345.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501190206.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>在一个项目中，突然出现了 OOM 故障,那么该如何排除 研究为什么出错~</strong></p>\n<ul>\n<li>能够看到代码第几行出错:内存快照分析工具，MAT, Jprofiler</li>\n<li>Debug, 一行行分析代码!</li>\n</ul>\n<p><strong>MAT, Jprofiler 作用</strong></p>\n<ul>\n<li>分析 Dump 内存文件,快速定位内存泄露;</li>\n<li>获得堆中的数据</li>\n<li>获得大的对象~</li>\n</ul>\n<p><strong>Jprofile 使用</strong></p>\n<ol>\n<li>在 idea 中下载 jprofile 插件</li>\n<li>联网下载 jprofile 客户端</li>\n<li>在 idea 中 VM 参数中写参数 -Xms1m -Xmx8m -XX: +HeapDumpOnOutOfMemoryError</li>\n<li>运行程序后在 jprofile 客户端中打开找到错误 告诉哪个位置报错</li>\n</ol>\n<p><strong>命令参数详解</strong></p>\n<ul>\n<li>-Xms 设置初始化内存分配大小/164</li>\n<li>-Xmx 设置最大分配内存，默以 1/4</li>\n<li>-XX: +PrintGCDetails // 打印 GC 垃圾回收信息</li>\n<li>-XX: +HeapDumpOnOutOfMemoryError //oom <strong>DUMP</strong></li>\n</ul>\n<h2 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h2><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501191953.png\" alt=\"在这里插入图片描述\"></p>\n<p>JVM 在进行 GC 时，并不是对这三个区域统一回收。 大部分时候，回收都是新生代~</p>\n<ul>\n<li>新生代</li>\n<li><strong>幸存区(form，to)</strong></li>\n<li>老年区</li>\n</ul>\n<p>GC 两种类:轻 GC (普通的 GC)， 重 GC (全局 GC)</p>\n<p>GC 常见面试题目:</p>\n<ul>\n<li><p><strong>JVM 的内存模型和分区~详细到每个区放什么?</strong></p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501192059.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p><strong>堆里面的分区有哪些?</strong></p>\n<p>Eden, form, to, 老年区,说说他们的特点!</p>\n</li>\n<li><p><strong>GC 的算法有哪些?</strong></p>\n<p>标记清除法，标记整理,复制算法，引用计数器</p>\n</li>\n<li><p><strong>轻 GC 和重 GC 分别在什么时候发生?</strong></p>\n</li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/qianguyihao/p/4744233.html\">参考链接</a></p>\n","more":"<ul>\n<li>请你谈谈你对 JVM 的理解，Java8 虚拟机和之前的变化更新？</li>\n<li>什么是 OOM，什么是栈溢出 StackOverFlowError？怎么分析？</li>\n<li>JVM 常用调优参数有哪些？</li>\n<li>内存快照如何抓取，怎么分析 Dump 文件？</li>\n<li>谈谈 JVM 中，类加载器你的认识？</li>\n</ul>\n<h2 id=\"JVM-的位置\"><a href=\"#JVM-的位置\" class=\"headerlink\" title=\"JVM 的位置\"></a>JVM 的位置</h2><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501155102.png\" alt=\"JVM图解\"></p>\n<h2 id=\"JVM-的体系结构\"><a href=\"#JVM-的体系结构\" class=\"headerlink\" title=\"JVM 的体系结构\"></a>JVM 的体系结构</h2><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210502005237.png\" alt=\"image-20210502005237430\"></p>\n<p>百分之 99 的 JVM 调优都是在堆中调优，Java 栈、本地方法栈、程序计数器是不会有垃圾存在的。</p>\n<h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><p>作用：加载 Class 文件~</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501161637.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>虚拟机自带的加载器</li>\n<li>启动类（根）加载器</li>\n<li>扩展类加载器</li>\n<li>应用程序（系统类）加载器</li>\n</ul>\n<h2 id=\"双清委派机制\"><a href=\"#双清委派机制\" class=\"headerlink\" title=\"双清委派机制\"></a>双清委派机制</h2><p><img src=\"https://img-blog.csdnimg.cn/20201217213314510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<h2 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h2><p>Java 安全模型的核心就是 Java 沙箱(sandbox)</p>\n<p>什么是沙箱?沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。</p>\n<p>沙箱主要限制系统资源访问，那系统资源包括什么? CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>\n<p>所有的 Java 程序运行都可以指定沙箱，可以定制安全策略。</p>\n<p>在 Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码,可以访问一切本地资源。而对于非授信的远程代码在早期的 Java 实现中，安全依赖于沙箱 Sandbox)机制。如下图所示 JDK1.0 安全模型</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501163417.png\" alt=\"img\"></p>\n<p>但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的 Java1.1 版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示 JDK1.1 安全模型</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501164943.png\" alt=\"在这里插入图片描述\"></p>\n<p>在 Java1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501164956.png\" alt=\"在这里插入图片描述\"></p>\n<p>当前最新的安全机制实现，则引入了域(Domain)的概念。虚拟机会把所有代码加载到不同的系统域和应用域,系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain),对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示最新的安全模型(jdk 1.6)</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501165007.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>组成沙箱的基本条件</strong></p>\n<ul>\n<li>字节码校验器(bytecode verifier) :确保 Java 类文件遵循 Java 语言规范。这样可以帮助 Java 程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。</li>\n<li>类裝载器(class loader) :其中类装载器在 3 个方面对 Java 沙箱起作用<ul>\n<li>它防止恶意代码去干涉善意的代码;</li>\n<li>它守护了被信任的类库边界;</li>\n<li>它将代码归入保护域,确定了代码可以进行哪些操作；</li>\n</ul>\n</li>\n</ul>\n<p>虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成， 每一个被装载的类将有一个名字，这个命名空间是由 Java 虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。</p>\n<p>类装载器采用的机制是双亲委派模式。</p>\n<ol>\n<li>从最内层 JVM 自带类加载器开始加载,外层恶意同名类得不到加载从而无法使用;</li>\n<li>由于严格通过包来区分了访问域,外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。</li>\n</ol>\n<ul>\n<li>存取控制器(access controller) :存取控制器可以控制核心 API 对操作系统的存取权限，而这个控制的策略设定,可以由用户指定。</li>\n<li>安全管理器(security manager) : 是核心 API 和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。</li>\n<li>安全软件包(security package) : java.security 下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括:<ul>\n<li>安全提供者</li>\n<li>消息摘要</li>\n<li>数字签名</li>\n<li>加密</li>\n<li>鉴别</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Native\"><a href=\"#Native\" class=\"headerlink\" title=\"Native\"></a>Native</h2><ul>\n<li>native :凡是带了 native 关键字的，说明 java 的作用范围达不到了，回去调用底层 c 语言的库!</li>\n<li>会进入本地方法栈</li>\n<li>调用本地方法本地接口 JNI (Java Native Interface)</li>\n<li>JNI 作用:开拓 Java 的使用，融合不同的编程语言为 Java 所用!最初: C、C++</li>\n<li>Java 诞生的时候 C、C++横行，想要立足，必须要有调用 C、C++的程序</li>\n<li>它在内存区域中专门开辟了一块标记区域: Native Method Stack，登记 native 方法</li>\n<li>在最终执行的时候，加载本地方法库中的方法通过 JNI</li>\n</ul>\n<h3 id=\"Native-Method-Stack\"><a href=\"#Native-Method-Stack\" class=\"headerlink\" title=\"Native Method Stack\"></a><strong>Native Method Stack</strong></h3><p>它的具体做法是 Native Method Stack 中登记 native 方法，在( Execution Engine )执行引擎执行的时候加载 Native Libraies。[本地库]</p>\n<h3 id=\"Native-Interface-本地接口\"><a href=\"#Native-Interface-本地接口\" class=\"headerlink\" title=\"Native Interface 本地接口\"></a><strong>Native Interface 本地接口</strong></h3><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序, Java 在诞生的时候是 C/C++横行的时候，想要立足，必须有调用 C、C++的程序，于是就在内存中专门开辟了块区域处理标记为 native 的代码，它的具体做法是在 Native Method Stack 中登记 native 方法,在( Execution Engine )执行引擎执行的时候加载 Native Libraies。</p>\n<p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间通信很发达，比如可以使用 Socket 通信,也可以使用 Web Service 等等，不多做介绍!</p>\n<h2 id=\"PC-寄存器\"><a href=\"#PC-寄存器\" class=\"headerlink\" title=\"PC 寄存器\"></a>PC 寄存器</h2><p>程序计数器: Program Counter Register</p>\n<p>每个线程都有一个程序计数器，是线程私有的，就是一个指针, 指向方法区中的方法字节码(用来存储指向像一条指令的地址， 也即将要执行的指令代码)，在执行引擎读取下一条指令, 是一个非常小的内存空间，几乎可以忽略不计</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区是被所有线程共享,所有字段和方法字节码，以及一些特殊方法，如构造函数,接口代码也在此定义,简单说，所有定义的方法的信息都保存在该区域,此区域属于共享区间;</p>\n<p>==静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关==</p>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>栈:先进后出</p>\n<p>桶:后进先出</p>\n<p>队列:先进先出( FIFO : First Input First Output )</p>\n<p>栈：<strong>栈内存，主管程序的运行，生命周期和线程同步</strong></p>\n<p><strong>线程结束，栈内存也就是释放，对于栈来说，不存在垃圾回收问题</strong></p>\n<p>一旦线程结束，栈就 Over!</p>\n<p>栈内存中:</p>\n<p><strong>8 大基本类型+对象引用+实例的方法</strong></p>\n<p><strong>栈运行原理:栈帧</strong></p>\n<p>栈满了: StackOverflowError</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501173518.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501173432.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"三种-JVM\"><a href=\"#三种-JVM\" class=\"headerlink\" title=\"三种 JVM\"></a>三种 JVM</h2><ul>\n<li><p><strong>HotSpot VM</strong></p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代</span><br><span class=\"line\">码，然后通知<span class=\"keyword\">JIT编译器以方法为单位进行编译。 </span>如果一个方法被频繁调用，或方法中有效</span><br><span class=\"line\">循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。 通过编译器与解释器</span><br><span class=\"line\">恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待</span><br><span class=\"line\">本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码</span><br><span class=\"line\">优化技术，输出质量更高的本地代码</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>JRockit</strong></p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>.<span class=\"keyword\">JRockit </span>VM曾经号称“世界上速度最快的<span class=\"keyword\">Java虚拟机”</span></span><br><span class=\"line\"><span class=\"keyword\"></span><span class=\"number\">2</span>.由于专注于服务器端应用，它可以不太关注程序启动速度，因此<span class=\"keyword\">JRockit内部不包含解析器实现，全部代码都靠即时</span></span><br><span class=\"line\"><span class=\"keyword\"></span>编译器编译后执行。 除此之外，<span class=\"keyword\">JRockit的垃圾收集器和MissionControl服务套件等部分的实</span></span><br><span class=\"line\"><span class=\"keyword\"></span>现，在众多<span class=\"keyword\">Java虚拟机中也一直处于领先水平</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>J9</strong></p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.IBM J9 VM并不是IBM公司唯一的Java虚拟机，不过是目前其主力发展的Java虚拟机，IBM J9 VM原本是内部开发代号，</span><br><span class=\"line\">正式名称是“IBM Technology for Java Virtual Machine”，简称IT4J，只是这个名字太拗口了一点，普及程度不如J9.</span><br><span class=\"line\">2.与BEA JRockit专注于服务器端应用不同，IBM J9的市场定位与Sun HotSpot比较接近，它是一款设计上从服务器端</span><br><span class=\"line\">到桌面应用再到嵌入式都全面考虑的多用途虚拟机<span class=\"strong\">***</span>，J9的开发目的是作为IBM公司各种Java产品的执行平台，它的主</span><br><span class=\"line\">要市场是和IBM产品（如IBM WebSphere等）搭配以及在IBM AIX和z/OS这些平台上部署Java</span><br><span class=\"line\">应用。</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>Heap, 一个 JVM 只有一个堆内存，堆内存的大小是可以调节的。</p>\n<p>类加载器读取了类文件后，一般会把什么东西放到堆中?</p>\n<p>类, 方法，常量,变量~，保存我们所有引用类型的真实对象;</p>\n<p>堆内存中还要细分为三个区域:</p>\n<ul>\n<li>新生区(伊甸园区) Young/New</li>\n<li>老年区 old</li>\n<li>永久区 Perm</li>\n</ul>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501174842.png\" alt=\"img\"></p>\n<p>GC 垃圾回收,主要是在伊甸园区和养老区~</p>\n<p>假设内存满了,OOM,堆内存不够! java.lang.OutOfMemoryError:Java heap space</p>\n<p>永久存储区里存放的都是 Java 自带的 例如 lang 包中的类 如果不存在这些，Java 就跑不起来了</p>\n<p>在 JDK8 以后，永久存储区改了个名字(元空间)</p>\n<p><a href=\"https://www.cnblogs.com/duanxz/p/3726574.html\">参考链接</a></p>\n<h2 id=\"新生区、老年区\"><a href=\"#新生区、老年区\" class=\"headerlink\" title=\"新生区、老年区\"></a>新生区、老年区</h2><ul>\n<li>对象：诞生和成长的地方，甚至死亡;</li>\n<li>伊甸园，所有的对象都是在伊甸园区 new 出来的!</li>\n<li>幸存者区(0,1)</li>\n</ul>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501175400.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>伊甸园满了就触发轻 GC，经过轻 GC 存活下来的就到了幸存者区，幸存者区满之后意味着新生区也满了，则触发重 GC，经过重 GC 之后存活下来的就到了养老区。</strong></p>\n<p>真理:经过研究，99%的对象都是临时对象!|</p>\n<p><a href=\"https://www.cnblogs.com/duanxz/p/3726574.html\">参考链接</a></p>\n<h2 id=\"永久区\"><a href=\"#永久区\" class=\"headerlink\" title=\"永久区\"></a>永久区</h2><p>这个区域常驻内存的。用来存放 JDK 自身携带的 Class 对象。Interface 元数据，存储的是 Java 运行时的一些环境~ 这个区域不存在垃圾回收，关闭虚拟机就会释放内存</p>\n<ul>\n<li>jdk1.6 之前：永久代,常量池是在方法区;</li>\n<li>jdk1.7：永久代,但是慢慢的退化了，去永久代，常量池在堆中</li>\n<li>jdk1.8 之后：无永久代,常量池在元空间</li>\n</ul>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501180058.png\" alt=\"在这里插入图片描述\"></p>\n<p>元空间：逻辑上存在，物理上不存在 (因为存储在本地磁盘内) 所以最后并不算在 JVM 虚拟机内存中</p>\n<h2 id=\"堆内存调优\"><a href=\"#堆内存调优\" class=\"headerlink\" title=\"堆内存调优\"></a>堆内存调优</h2><p>测试代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        s += <span class=\"string\">&quot;11111111111111111111111111111111111111111111111111111&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20200715152713345.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501190206.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>在一个项目中，突然出现了 OOM 故障,那么该如何排除 研究为什么出错~</strong></p>\n<ul>\n<li>能够看到代码第几行出错:内存快照分析工具，MAT, Jprofiler</li>\n<li>Debug, 一行行分析代码!</li>\n</ul>\n<p><strong>MAT, Jprofiler 作用</strong></p>\n<ul>\n<li>分析 Dump 内存文件,快速定位内存泄露;</li>\n<li>获得堆中的数据</li>\n<li>获得大的对象~</li>\n</ul>\n<p><strong>Jprofile 使用</strong></p>\n<ol>\n<li>在 idea 中下载 jprofile 插件</li>\n<li>联网下载 jprofile 客户端</li>\n<li>在 idea 中 VM 参数中写参数 -Xms1m -Xmx8m -XX: +HeapDumpOnOutOfMemoryError</li>\n<li>运行程序后在 jprofile 客户端中打开找到错误 告诉哪个位置报错</li>\n</ol>\n<p><strong>命令参数详解</strong></p>\n<ul>\n<li>-Xms 设置初始化内存分配大小/164</li>\n<li>-Xmx 设置最大分配内存，默以 1/4</li>\n<li>-XX: +PrintGCDetails // 打印 GC 垃圾回收信息</li>\n<li>-XX: +HeapDumpOnOutOfMemoryError //oom <strong>DUMP</strong></li>\n</ul>\n<h2 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h2><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501191953.png\" alt=\"在这里插入图片描述\"></p>\n<p>JVM 在进行 GC 时，并不是对这三个区域统一回收。 大部分时候，回收都是新生代~</p>\n<ul>\n<li>新生代</li>\n<li><strong>幸存区(form，to)</strong></li>\n<li>老年区</li>\n</ul>\n<p>GC 两种类:轻 GC (普通的 GC)， 重 GC (全局 GC)</p>\n<p>GC 常见面试题目:</p>\n<ul>\n<li><p><strong>JVM 的内存模型和分区~详细到每个区放什么?</strong></p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210501192059.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p><strong>堆里面的分区有哪些?</strong></p>\n<p>Eden, form, to, 老年区,说说他们的特点!</p>\n</li>\n<li><p><strong>GC 的算法有哪些?</strong></p>\n<p>标记清除法，标记整理,复制算法，引用计数器</p>\n</li>\n<li><p><strong>轻 GC 和重 GC 分别在什么时候发生?</strong></p>\n</li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/qianguyihao/p/4744233.html\">参考链接</a></p>\n","categories":[{"name":"后端开发","path":"api/categories/后端开发.json"}],"tags":[{"name":"技巧","path":"api/tags/技巧.json"},{"name":"笔记","path":"api/tags/笔记.json"}]}