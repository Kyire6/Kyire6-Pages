{"title":"Java 中的注解与反射","slug":"Java注解与反射","date":"2021-04-07T08:25:44.000Z","updated":"2021-04-07T08:26:26.000Z","comments":true,"path":"api/articles/Java注解与反射.json","excerpt":null,"covers":null,"content":"<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><p>java.Annotation</p>\n<h3 id=\"什么是注解？\"><a href=\"#什么是注解？\" class=\"headerlink\" title=\"什么是注解？\"></a>什么是注解？</h3><ul>\n<li>Annotation 是从 JDK5.0 引入的新技术</li>\n<li>Annotation 的作用：<ul>\n<li>不是程序本身，可以对程序作出解释</li>\n<li><strong>可以被其他程序(比如编译器等)读取</strong></li>\n</ul>\n</li>\n<li>Annotation 的格式：<ul>\n<li>注解是以“@注释名”在代码中存在的，还可以添加一些参数值</li>\n</ul>\n</li>\n<li>Annotation 在哪里使用？<ul>\n<li>可以附加在 package、class、method、field 等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内置注解\"><a href=\"#内置注解\" class=\"headerlink\" title=\"内置注解\"></a>内置注解</h3><ul>\n<li>@Override：定义在 java.lang.Override 中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。</li>\n<li>@Deprecated：此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择。</li>\n<li>@SuppressWarning：用来抑制编译时的警告信息。</li>\n</ul>\n<h3 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h3><ul>\n<li>元注解的作用就是负责注解其他注解。Java 定义了 4 个标准的 meta-annotation 类型，他们用来提供对其他 annotation 类型作说明</li>\n<li>在 java.lang.annotation 中可以找到：<ul>\n<li><strong>@Target</strong>：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</li>\n<li><strong>@Retention</strong>：表示需要在什么级别保存该注释信息，用于描述注解的生命周期你<ul>\n<li>（SOURCE &lt; CLASS &lt; <strong>RUNTIME</strong>）</li>\n</ul>\n</li>\n<li>@Document：说明该注解将被包含在 javadoc 中</li>\n<li>@Inherited：说明子类可以继承<strong>父类</strong>中的注解</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h3><ul>\n<li>使用 <strong>@interface</strong>自定义注解是，自动继承了 java.lang.annotation.Annotation 接口</li>\n<li>分析：<ul>\n<li>@interface 用来声明一个注解，格式：public @interface 注解名{ 定义内容 }</li>\n<li>其中的每一个方法实际上是声明了一个配置参数</li>\n<li>方法的名称就是参数的名称</li>\n<li>返回值类型就是参数的类型 （返回值只能是基本类型，Class，String，enum）</li>\n<li>可以通过 default 来声明参数的默认值</li>\n<li>如果只有一个参数成员，一般参数名为 value</li>\n<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0 作为默认值</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"反射机制\"><a href=\"#反射机制\" class=\"headerlink\" title=\"反射机制\"></a>反射机制</h2><p>Reflection（反射）是 Java 被视为动态语言的关键，反射机制允许程序在执行期借助于 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;java.lang.String&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>加载完类之后，在堆内存的方法区中就产生了一个 Class 类型的对象（一个类只要一个 Class 对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射！</p>\n<h3 id=\"反射相关的主要-API\"><a href=\"#反射相关的主要-API\" class=\"headerlink\" title=\"反射相关的主要 API\"></a>反射相关的主要 API</h3><ul>\n<li>java.lang.Class：代表一个类</li>\n<li>java.lang.reflect.Method：代表类的方法</li>\n<li>javaz.lang.reflect.Field：代表类的成员变量</li>\n<li>java.lang.reflect.Contructor：代表类的构造器</li>\n</ul>\n<h3 id=\"Class-类\"><a href=\"#Class-类\" class=\"headerlink\" title=\"Class 类\"></a>Class 类</h3><p>对于每个类而言，JRE 都为其保留了一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation)</p>\n<ul>\n<li>Class 本身也是一个类</li>\n<li>Class 对象只能由系统建立对象</li>\n<li>一个加载的类在 JVM 中只会有一个 Class 实例</li>\n<li>一个 Class 对象对应的是一个加载到 JVM 中的一个.class 文件</li>\n<li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li>\n<li>通过 Class 可以完整地得到一个类中的所有被加载的结构</li>\n<li>Class 类是 Relfection 的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 Class 对象</li>\n</ul>\n<h3 id=\"Class-类相关方法\"><a href=\"#Class-类相关方法\" class=\"headerlink\" title=\"Class 类相关方法\"></a>Class 类相关方法</h3><ul>\n<li><strong>获得类相关的方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>asSubclass(Class<U> clazz)</td>\n<td>把传递的类的对象转换成代表其子类的对象</td>\n</tr>\n<tr>\n<td>Cast</td>\n<td>把对象转换成代表类或是接口的对象</td>\n</tr>\n<tr>\n<td>getClassLoader()</td>\n<td>获得类的加载器</td>\n</tr>\n<tr>\n<td>getClasses()</td>\n<td>返回一个数组，数组中包含该类中所有公共类和接口类的对象</td>\n</tr>\n<tr>\n<td>getDeclaredClasses()</td>\n<td>返回一个数组，数组中包含该类中所有类和接口类的对象</td>\n</tr>\n<tr>\n<td>forName(String className)</td>\n<td>根据类名返回类的对象</td>\n</tr>\n<tr>\n<td>getName()</td>\n<td>获得类的完整路径名字</td>\n</tr>\n<tr>\n<td>newInstance()</td>\n<td>创建类的实例</td>\n</tr>\n<tr>\n<td>getPackage()</td>\n<td>获得类的包</td>\n</tr>\n<tr>\n<td>getSimpleName()</td>\n<td>获得类的名字</td>\n</tr>\n<tr>\n<td>getSuperclass()</td>\n<td>获得当前类继承的父类的名字</td>\n</tr>\n<tr>\n<td>getInterfaces()</td>\n<td>获得当前类实现的类或是接口</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>获得类中属性相关的方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getField(String name)</td>\n<td>获得某个公有的属性对象</td>\n</tr>\n<tr>\n<td>getFields()</td>\n<td>获得所有公有的属性对象</td>\n</tr>\n<tr>\n<td>getDeclaredField(String name)</td>\n<td>获得某个属性对象</td>\n</tr>\n<tr>\n<td>getDeclaredFields()</td>\n<td>获得所有属性对象</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>获得类中注解相关的方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getAnnotation(Class<A> annotationClass)</td>\n<td>返回该类中与参数类型匹配的公有注解对象</td>\n</tr>\n<tr>\n<td>getAnnotations()</td>\n<td>返回该类所有的公有注解对象</td>\n</tr>\n<tr>\n<td>getDeclaredAnnotation(Class<A> annotationClass)</td>\n<td>返回该类中与参数类型匹配的所有注解对象</td>\n</tr>\n<tr>\n<td>getDeclaredAnnotations()</td>\n<td>返回该类所有的注解对象</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>获得类中构造器相关的方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getConstructor(Class…&lt;?&gt; parameterTypes)</td>\n<td>获得该类中与参数类型匹配的公有构造方法</td>\n</tr>\n<tr>\n<td>getConstructors()</td>\n<td>获得该类的所有公有构造方法</td>\n</tr>\n<tr>\n<td>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td>\n<td>获得该类中与参数类型匹配的构造方法</td>\n</tr>\n<tr>\n<td>getDeclaredConstructors()</td>\n<td>获得该类所有构造方法</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>获得类中方法相关的方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getMethod(String name, Class…&lt;?&gt; parameterTypes)</td>\n<td>获得该类某个公有的方法</td>\n</tr>\n<tr>\n<td>getMethods()</td>\n<td>获得该类所有公有的方法</td>\n</tr>\n<tr>\n<td>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td>\n<td>获得该类某个方法</td>\n</tr>\n<tr>\n<td>getDeclaredMethods()</td>\n<td>获得该类所有方法</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>类中其他重要的方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>isAnnotation()</td>\n<td>如果是注解类型则返回 true</td>\n</tr>\n<tr>\n<td>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td>\n<td>如果是指定类型注解类型则返回 true</td>\n</tr>\n<tr>\n<td>isAnonymousClass()</td>\n<td>如果是匿名类则返回 true</td>\n</tr>\n<tr>\n<td>isArray()</td>\n<td>如果是一个数组类则返回 true</td>\n</tr>\n<tr>\n<td>isEnum()</td>\n<td>如果是枚举类则返回 true</td>\n</tr>\n<tr>\n<td>isInstance(Object obj)</td>\n<td>如果 obj 是该类的实例则返回 true</td>\n</tr>\n<tr>\n<td>isInterface()</td>\n<td>如果是接口类则返回 true</td>\n</tr>\n<tr>\n<td>isLocalClass()</td>\n<td>如果是局部类则返回 true</td>\n</tr>\n<tr>\n<td>isMemberClass()</td>\n<td>如果是内部类则返回 true</td>\n</tr>\n</tbody></table>\n<h3 id=\"Field-类\"><a href=\"#Field-类\" class=\"headerlink\" title=\"Field 类\"></a>Field 类</h3><p><a href=\"https://developer.android.google.cn/reference/java/lang/reflect/Field\">Field</a>代表类的成员变量（成员变量也称为类的属性）。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>equals(Object obj)</td>\n<td>属性与 obj 相等则返回 true</td>\n</tr>\n<tr>\n<td>get(Object obj)</td>\n<td>获得 obj 中对应的属性值</td>\n</tr>\n<tr>\n<td>set(Object obj, Object value)</td>\n<td>设置 obj 中对应属性值</td>\n</tr>\n</tbody></table>\n<h3 id=\"Method-类\"><a href=\"#Method-类\" class=\"headerlink\" title=\"Method 类\"></a>Method 类</h3><p><a href=\"https://developer.android.google.cn/reference/java/lang/reflect/Method\">Method</a>代表类的方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>invoke(Object obj, Object… args)</td>\n<td>传递 object 对象及参数调用该对象对应的方法</td>\n</tr>\n</tbody></table>\n<h3 id=\"Constructor-类\"><a href=\"#Constructor-类\" class=\"headerlink\" title=\"Constructor 类\"></a>Constructor 类</h3><p><a href=\"https://developer.android.google.cn/reference/java/lang/reflect/Constructor\">Constructor</a>代表类的构造方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>newInstance(Object… initargs)</td>\n<td>根据传递的参数创建类的对象</td>\n</tr>\n</tbody></table>\n<h3 id=\"获取-Class-类的实例\"><a href=\"#获取-Class-类的实例\" class=\"headerlink\" title=\"获取 Class 类的实例\"></a>获取 Class 类的实例</h3><ul>\n<li>类名.class</li>\n<li>对象.getClass</li>\n<li>Class.forName(类路径)</li>\n<li>内置基本类型包装类.TYPE</li>\n</ul>\n<h3 id=\"那些类型可以有-Class-对象\"><a href=\"#那些类型可以有-Class-对象\" class=\"headerlink\" title=\"那些类型可以有 Class 对象\"></a>那些类型可以有 Class 对象</h3><ul>\n<li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li>\n<li>interface：接口</li>\n<li>[]：数组</li>\n<li>enum：枚举</li>\n<li>annotation：注解@interface</li>\n<li>primitive type：基本数据类型</li>\n<li>void</li>\n</ul>\n<h3 id=\"类的加载与-ClassLoader-的理解\"><a href=\"#类的加载与-ClassLoader-的理解\" class=\"headerlink\" title=\"类的加载与 ClassLoader 的理解\"></a>类的加载与 ClassLoader 的理解</h3><ul>\n<li>加载：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java.lang.Class 对象</li>\n<li>链接：将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程。<ul>\n<li>验证：确保加载的类信息符合 JVM 规范，没有安全方面的问题</li>\n<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li>\n<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程</li>\n</ul>\n</li>\n<li>初始化：<ul>\n<li>执行类构造器<clint>()方法的过程。类构造器<clint>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化</li>\n<li>虚拟机会保证一个类的<clint>()方法在多线程环境中被正确加锁和同步</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么时候会发生类初始化？\"><a href=\"#什么时候会发生类初始化？\" class=\"headerlink\" title=\"什么时候会发生类初始化？\"></a>什么时候会发生类初始化？</h3><ul>\n<li>类的主动引用（一定会发生类的初始化）<ul>\n<li>当虚拟机启动，先初始化 main 方法所在的类</li>\n<li>new 一个类的对象</li>\n<li>调用类的静态成员（除了 final 常量）和静态方法</li>\n<li>使用 java.lang.reflect 包的方法对类进行反射调用</li>\n<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li>\n</ul>\n</li>\n<li>类的被动引用（不会发生类的初始化）<ul>\n<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</li>\n<li>通过数组定义类引用，不会触发此类初始化</li>\n<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类加载器的作用\"><a href=\"#类加载器的作用\" class=\"headerlink\" title=\"类加载器的作用\"></a>类加载器的作用</h3><p><strong>类加载器的作用：</strong></p>\n<p>将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区中类数据的访问入口。</p>\n<p><strong>类缓存：</strong></p>\n<p>标准的 JavaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过 JVM 垃圾回收机制可以回收这些 Class 对象</p>\n<p>三大类加载器：</p>\n<ul>\n<li>引导类加载器 – Bootstrap Classloader</li>\n<li>扩展类加载器 – Extension Classloader</li>\n<li>系统类加载器 – System Classloader</li>\n</ul>\n","more":"<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><p>java.Annotation</p>\n<h3 id=\"什么是注解？\"><a href=\"#什么是注解？\" class=\"headerlink\" title=\"什么是注解？\"></a>什么是注解？</h3><ul>\n<li>Annotation 是从 JDK5.0 引入的新技术</li>\n<li>Annotation 的作用：<ul>\n<li>不是程序本身，可以对程序作出解释</li>\n<li><strong>可以被其他程序(比如编译器等)读取</strong></li>\n</ul>\n</li>\n<li>Annotation 的格式：<ul>\n<li>注解是以“@注释名”在代码中存在的，还可以添加一些参数值</li>\n</ul>\n</li>\n<li>Annotation 在哪里使用？<ul>\n<li>可以附加在 package、class、method、field 等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内置注解\"><a href=\"#内置注解\" class=\"headerlink\" title=\"内置注解\"></a>内置注解</h3><ul>\n<li>@Override：定义在 java.lang.Override 中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。</li>\n<li>@Deprecated：此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择。</li>\n<li>@SuppressWarning：用来抑制编译时的警告信息。</li>\n</ul>\n<h3 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h3><ul>\n<li>元注解的作用就是负责注解其他注解。Java 定义了 4 个标准的 meta-annotation 类型，他们用来提供对其他 annotation 类型作说明</li>\n<li>在 java.lang.annotation 中可以找到：<ul>\n<li><strong>@Target</strong>：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</li>\n<li><strong>@Retention</strong>：表示需要在什么级别保存该注释信息，用于描述注解的生命周期你<ul>\n<li>（SOURCE &lt; CLASS &lt; <strong>RUNTIME</strong>）</li>\n</ul>\n</li>\n<li>@Document：说明该注解将被包含在 javadoc 中</li>\n<li>@Inherited：说明子类可以继承<strong>父类</strong>中的注解</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h3><ul>\n<li>使用 <strong>@interface</strong>自定义注解是，自动继承了 java.lang.annotation.Annotation 接口</li>\n<li>分析：<ul>\n<li>@interface 用来声明一个注解，格式：public @interface 注解名{ 定义内容 }</li>\n<li>其中的每一个方法实际上是声明了一个配置参数</li>\n<li>方法的名称就是参数的名称</li>\n<li>返回值类型就是参数的类型 （返回值只能是基本类型，Class，String，enum）</li>\n<li>可以通过 default 来声明参数的默认值</li>\n<li>如果只有一个参数成员，一般参数名为 value</li>\n<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0 作为默认值</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"反射机制\"><a href=\"#反射机制\" class=\"headerlink\" title=\"反射机制\"></a>反射机制</h2><p>Reflection（反射）是 Java 被视为动态语言的关键，反射机制允许程序在执行期借助于 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;java.lang.String&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>加载完类之后，在堆内存的方法区中就产生了一个 Class 类型的对象（一个类只要一个 Class 对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射！</p>\n<h3 id=\"反射相关的主要-API\"><a href=\"#反射相关的主要-API\" class=\"headerlink\" title=\"反射相关的主要 API\"></a>反射相关的主要 API</h3><ul>\n<li>java.lang.Class：代表一个类</li>\n<li>java.lang.reflect.Method：代表类的方法</li>\n<li>javaz.lang.reflect.Field：代表类的成员变量</li>\n<li>java.lang.reflect.Contructor：代表类的构造器</li>\n</ul>\n<h3 id=\"Class-类\"><a href=\"#Class-类\" class=\"headerlink\" title=\"Class 类\"></a>Class 类</h3><p>对于每个类而言，JRE 都为其保留了一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation)</p>\n<ul>\n<li>Class 本身也是一个类</li>\n<li>Class 对象只能由系统建立对象</li>\n<li>一个加载的类在 JVM 中只会有一个 Class 实例</li>\n<li>一个 Class 对象对应的是一个加载到 JVM 中的一个.class 文件</li>\n<li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li>\n<li>通过 Class 可以完整地得到一个类中的所有被加载的结构</li>\n<li>Class 类是 Relfection 的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 Class 对象</li>\n</ul>\n<h3 id=\"Class-类相关方法\"><a href=\"#Class-类相关方法\" class=\"headerlink\" title=\"Class 类相关方法\"></a>Class 类相关方法</h3><ul>\n<li><strong>获得类相关的方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>asSubclass(Class<U> clazz)</td>\n<td>把传递的类的对象转换成代表其子类的对象</td>\n</tr>\n<tr>\n<td>Cast</td>\n<td>把对象转换成代表类或是接口的对象</td>\n</tr>\n<tr>\n<td>getClassLoader()</td>\n<td>获得类的加载器</td>\n</tr>\n<tr>\n<td>getClasses()</td>\n<td>返回一个数组，数组中包含该类中所有公共类和接口类的对象</td>\n</tr>\n<tr>\n<td>getDeclaredClasses()</td>\n<td>返回一个数组，数组中包含该类中所有类和接口类的对象</td>\n</tr>\n<tr>\n<td>forName(String className)</td>\n<td>根据类名返回类的对象</td>\n</tr>\n<tr>\n<td>getName()</td>\n<td>获得类的完整路径名字</td>\n</tr>\n<tr>\n<td>newInstance()</td>\n<td>创建类的实例</td>\n</tr>\n<tr>\n<td>getPackage()</td>\n<td>获得类的包</td>\n</tr>\n<tr>\n<td>getSimpleName()</td>\n<td>获得类的名字</td>\n</tr>\n<tr>\n<td>getSuperclass()</td>\n<td>获得当前类继承的父类的名字</td>\n</tr>\n<tr>\n<td>getInterfaces()</td>\n<td>获得当前类实现的类或是接口</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>获得类中属性相关的方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getField(String name)</td>\n<td>获得某个公有的属性对象</td>\n</tr>\n<tr>\n<td>getFields()</td>\n<td>获得所有公有的属性对象</td>\n</tr>\n<tr>\n<td>getDeclaredField(String name)</td>\n<td>获得某个属性对象</td>\n</tr>\n<tr>\n<td>getDeclaredFields()</td>\n<td>获得所有属性对象</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>获得类中注解相关的方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getAnnotation(Class<A> annotationClass)</td>\n<td>返回该类中与参数类型匹配的公有注解对象</td>\n</tr>\n<tr>\n<td>getAnnotations()</td>\n<td>返回该类所有的公有注解对象</td>\n</tr>\n<tr>\n<td>getDeclaredAnnotation(Class<A> annotationClass)</td>\n<td>返回该类中与参数类型匹配的所有注解对象</td>\n</tr>\n<tr>\n<td>getDeclaredAnnotations()</td>\n<td>返回该类所有的注解对象</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>获得类中构造器相关的方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getConstructor(Class…&lt;?&gt; parameterTypes)</td>\n<td>获得该类中与参数类型匹配的公有构造方法</td>\n</tr>\n<tr>\n<td>getConstructors()</td>\n<td>获得该类的所有公有构造方法</td>\n</tr>\n<tr>\n<td>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td>\n<td>获得该类中与参数类型匹配的构造方法</td>\n</tr>\n<tr>\n<td>getDeclaredConstructors()</td>\n<td>获得该类所有构造方法</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>获得类中方法相关的方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getMethod(String name, Class…&lt;?&gt; parameterTypes)</td>\n<td>获得该类某个公有的方法</td>\n</tr>\n<tr>\n<td>getMethods()</td>\n<td>获得该类所有公有的方法</td>\n</tr>\n<tr>\n<td>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td>\n<td>获得该类某个方法</td>\n</tr>\n<tr>\n<td>getDeclaredMethods()</td>\n<td>获得该类所有方法</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>类中其他重要的方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>isAnnotation()</td>\n<td>如果是注解类型则返回 true</td>\n</tr>\n<tr>\n<td>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td>\n<td>如果是指定类型注解类型则返回 true</td>\n</tr>\n<tr>\n<td>isAnonymousClass()</td>\n<td>如果是匿名类则返回 true</td>\n</tr>\n<tr>\n<td>isArray()</td>\n<td>如果是一个数组类则返回 true</td>\n</tr>\n<tr>\n<td>isEnum()</td>\n<td>如果是枚举类则返回 true</td>\n</tr>\n<tr>\n<td>isInstance(Object obj)</td>\n<td>如果 obj 是该类的实例则返回 true</td>\n</tr>\n<tr>\n<td>isInterface()</td>\n<td>如果是接口类则返回 true</td>\n</tr>\n<tr>\n<td>isLocalClass()</td>\n<td>如果是局部类则返回 true</td>\n</tr>\n<tr>\n<td>isMemberClass()</td>\n<td>如果是内部类则返回 true</td>\n</tr>\n</tbody></table>\n<h3 id=\"Field-类\"><a href=\"#Field-类\" class=\"headerlink\" title=\"Field 类\"></a>Field 类</h3><p><a href=\"https://developer.android.google.cn/reference/java/lang/reflect/Field\">Field</a>代表类的成员变量（成员变量也称为类的属性）。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>equals(Object obj)</td>\n<td>属性与 obj 相等则返回 true</td>\n</tr>\n<tr>\n<td>get(Object obj)</td>\n<td>获得 obj 中对应的属性值</td>\n</tr>\n<tr>\n<td>set(Object obj, Object value)</td>\n<td>设置 obj 中对应属性值</td>\n</tr>\n</tbody></table>\n<h3 id=\"Method-类\"><a href=\"#Method-类\" class=\"headerlink\" title=\"Method 类\"></a>Method 类</h3><p><a href=\"https://developer.android.google.cn/reference/java/lang/reflect/Method\">Method</a>代表类的方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>invoke(Object obj, Object… args)</td>\n<td>传递 object 对象及参数调用该对象对应的方法</td>\n</tr>\n</tbody></table>\n<h3 id=\"Constructor-类\"><a href=\"#Constructor-类\" class=\"headerlink\" title=\"Constructor 类\"></a>Constructor 类</h3><p><a href=\"https://developer.android.google.cn/reference/java/lang/reflect/Constructor\">Constructor</a>代表类的构造方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>newInstance(Object… initargs)</td>\n<td>根据传递的参数创建类的对象</td>\n</tr>\n</tbody></table>\n<h3 id=\"获取-Class-类的实例\"><a href=\"#获取-Class-类的实例\" class=\"headerlink\" title=\"获取 Class 类的实例\"></a>获取 Class 类的实例</h3><ul>\n<li>类名.class</li>\n<li>对象.getClass</li>\n<li>Class.forName(类路径)</li>\n<li>内置基本类型包装类.TYPE</li>\n</ul>\n<h3 id=\"那些类型可以有-Class-对象\"><a href=\"#那些类型可以有-Class-对象\" class=\"headerlink\" title=\"那些类型可以有 Class 对象\"></a>那些类型可以有 Class 对象</h3><ul>\n<li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li>\n<li>interface：接口</li>\n<li>[]：数组</li>\n<li>enum：枚举</li>\n<li>annotation：注解@interface</li>\n<li>primitive type：基本数据类型</li>\n<li>void</li>\n</ul>\n<h3 id=\"类的加载与-ClassLoader-的理解\"><a href=\"#类的加载与-ClassLoader-的理解\" class=\"headerlink\" title=\"类的加载与 ClassLoader 的理解\"></a>类的加载与 ClassLoader 的理解</h3><ul>\n<li>加载：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java.lang.Class 对象</li>\n<li>链接：将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程。<ul>\n<li>验证：确保加载的类信息符合 JVM 规范，没有安全方面的问题</li>\n<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li>\n<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程</li>\n</ul>\n</li>\n<li>初始化：<ul>\n<li>执行类构造器<clint>()方法的过程。类构造器<clint>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化</li>\n<li>虚拟机会保证一个类的<clint>()方法在多线程环境中被正确加锁和同步</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么时候会发生类初始化？\"><a href=\"#什么时候会发生类初始化？\" class=\"headerlink\" title=\"什么时候会发生类初始化？\"></a>什么时候会发生类初始化？</h3><ul>\n<li>类的主动引用（一定会发生类的初始化）<ul>\n<li>当虚拟机启动，先初始化 main 方法所在的类</li>\n<li>new 一个类的对象</li>\n<li>调用类的静态成员（除了 final 常量）和静态方法</li>\n<li>使用 java.lang.reflect 包的方法对类进行反射调用</li>\n<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li>\n</ul>\n</li>\n<li>类的被动引用（不会发生类的初始化）<ul>\n<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</li>\n<li>通过数组定义类引用，不会触发此类初始化</li>\n<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类加载器的作用\"><a href=\"#类加载器的作用\" class=\"headerlink\" title=\"类加载器的作用\"></a>类加载器的作用</h3><p><strong>类加载器的作用：</strong></p>\n<p>将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区中类数据的访问入口。</p>\n<p><strong>类缓存：</strong></p>\n<p>标准的 JavaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过 JVM 垃圾回收机制可以回收这些 Class 对象</p>\n<p>三大类加载器：</p>\n<ul>\n<li>引导类加载器 – Bootstrap Classloader</li>\n<li>扩展类加载器 – Extension Classloader</li>\n<li>系统类加载器 – System Classloader</li>\n</ul>\n","categories":[{"name":"后端开发","path":"api/categories/后端开发.json"}],"tags":[{"name":"技巧","path":"api/tags/技巧.json"},{"name":"笔记","path":"api/tags/笔记.json"}]}