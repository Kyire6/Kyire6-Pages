{"title":"MapStruct 对象转换","slug":"MapStruct对象转换","date":"2022-08-07T08:36:53.000Z","updated":"2022-08-07T08:36:53.000Z","comments":true,"path":"api/articles/MapStruct对象转换.json","excerpt":null,"covers":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>随着微服务和分布式应用程序迅速占领开发领域，数据完整性和安全性比以往任何时候都更加重要。在这些松散耦合的系统之间，安全的通信渠道和有限的数据传输是最重要的。大多数时候，终端用户或服务不需要访问模型中的全部数据，而只需要访问某些特定的部分。</p>\n<p>数据传输对象(Data Transfer Objects, DTO)经常被用于这些应用中。DTO 只是持有另一个对象中被请求的信息的对象。通常情况下，这些信息是有限的一部分。例如，在持久化层定义的实体和发往客户端的 DTO 之间经常会出现相互之间的转换。由于 DTO 是原始对象的反映，因此这些类之间的映射器在转换过程中扮演着关键角色。</p>\n<p>这就是 MapStruct 解决的问题：手动创建 bean 映射器非常耗时。 但是该库可以自动生成 Bean 映射器类。</p>\n<h2 id=\"简介-MapStruct\"><a href=\"#简介-MapStruct\" class=\"headerlink\" title=\"简介 MapStruct\"></a>简介 MapStruct</h2><p>MapStruct 是一个开源的基于 Java 的代码生成器，用于创建实现 Java Bean 之间转换的扩展映射器。使用 MapStruct，我们只需要创建接口，而该库会通过注解在编译过程中自动创建具体的映射实现，大大减少了通常需要手工编写的样板代码的数量。</p>\n<h2 id=\"MapStruct-依赖\"><a href=\"#MapStruct-依赖\" class=\"headerlink\" title=\"MapStruct 依赖\"></a><strong>MapStruct 依赖</strong></h2><p><strong>如果你使用</strong><code>**Maven**</code><strong>的话，可以通过引入依赖安装</strong><code>**MapStruct**</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mapstruct<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mapstruct<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个依赖项会导入<code>MapStruct</code>的核心注释。由于<code>MapStruct</code>在编译时工作，并且会集成到像<code>Maven</code>和<code>Gradle</code>这样的构建工具上，我们还必须在<build/>标签中添加一个插件<code>maven-compiler-plugin</code>，并在其配置中添加<code>annotationProcessorPaths</code>，该插件会在构建时生成对应的代码。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">annotationProcessorPaths</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">path</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mapstruct<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mapstruct-processor<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">annotationProcessorPaths</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>**[MapStruct](<a href=\"https://link.zhihu.com/?target=https://search.maven.org/classic/#search|ga|1|g%3A&quot;org.mapstruct&quot;\">https://link.zhihu.com/?target=https://search.maven.org/classic/#search|ga|1|g%3A&quot;org.mapstruct&quot;</a> AND a%3A”mapstruct”)<strong>及其</strong>[处理器](<a href=\"https://link.zhihu.com/?target=https://search.maven.org/classic/#search|ga|1|g%3A&quot;org.mapstruct&quot;\">https://link.zhihu.com/?target=https://search.maven.org/classic/#search|ga|1|g%3A&quot;org.mapstruct&quot;</a> AND a%3A”mapstruct-processor”)<strong>的最新稳定版本都可以从</strong><a href=\"https://link.zhihu.com/?target=https://search.maven.org/search?q=g:org.mapstruct\">Maven 中央仓库</a>**中获得。</p>\n<h2 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a><strong>映射</strong></h2><h3 id=\"基本映射\"><a href=\"#基本映射\" class=\"headerlink\" title=\"基本映射\"></a><strong>基本映射</strong></h3><p>我们先从一些基本的映射开始。我们会创建一个<code>Doctor</code>对象和一个<code>DoctorDto</code>。为了方便起见，它们的属性字段都使用相同的名称：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Doctor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DoctorDto</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，为了在这两者之间进行映射，我们要创建一个<code>DoctorMapper</code>接口。对该接口使用<code>@Mapper</code>注解，<code>MapStruct</code>就会知道这是两个类之间的映射器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DoctorMapper</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">DoctorMapper</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> Mappers.getMapper(DoctorMapper.class);</span><br><span class=\"line\">    DoctorDto <span class=\"title function_\">toDto</span><span class=\"params\">(Doctor doctor)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码中创建了一个<code>DoctorMapper</code>类型的实例<code>INSTANCE</code>，在生成对应的实现代码后，这就是我们调用的“入口”。</p>\n<p>我们在接口中定义了<code>toDto()</code>方法，该方法接收一个<code>Doctor</code>实例为参数，并返回一个<code>DoctorDto</code>实例。这足以让 MapStruct 知道我们想把一个<code>Doctor</code>实例映射到一个<code>DoctorDto</code>实例。</p>\n<p>当我们构建/编译应用程序时，<code>MapStruct</code>注解处理器插件会识别出<code>DoctorMapper</code>接口并为其生成一个实现类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DoctorMapperImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DoctorMapper</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DoctorDto <span class=\"title function_\">toDto</span><span class=\"params\">(Doctor doctor)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( doctor == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">DoctorDtoBuilder</span> <span class=\"variable\">doctorDto</span> <span class=\"operator\">=</span> DoctorDto.builder();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.id(doctor.getId());</span><br><span class=\"line\">        doctorDto.name(doctor.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> doctorDto.build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>DoctorMapperImpl</code>类中包含一个<code>toDto()</code>方法，将我们的<code>Doctor</code>属性值映射到<code>DoctorDto</code>的属性字段中。如果要将<code>Doctor</code>实例映射到一个<code>DoctorDto</code>实例，可以这样写</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">DoctorDto</span> doctorDto = DoctorMapper.INSTANCE.toDto(doctor);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：你可能也注意到了上面实现代码中的<code>DoctorDtoBuilder</code>。因为 builder 代码往往比较长，为了简洁起见，这里省略了 builder 模式的实现代码。如果你的类中包含 Builder，MapStruct 会尝试使用它来创建实例；如果没有的话，MapStruct 将通过<code>new</code>关键字进行实例化。</p>\n<ul>\n<li><h5 id=\"不同字段间映射\"><a href=\"#不同字段间映射\" class=\"headerlink\" title=\"不同字段间映射\"></a><strong>不同字段间映射</strong></h5></li>\n</ul>\n<p>通常，模型和<code>DTO</code>的字段名不会完全相同。由于团队成员各自指定命名，以及针对不同的调用服务，开发者对返回信息的打包方式选择不同，名称可能会有轻微的变化。</p>\n<p><code>MapStruct</code>通过<code>@Mapping</code>注解对这类情况提供了支持。</p>\n<p>我们先更新<code>Doctor</code>类，添加一个属性<code>specialty</code>：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Doctor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String specialty;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>DoctorDto</code>类中添加一个<code>specialization</code>属性：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoctorDto</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String specialization;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们需要让 <code>DoctorMapper</code> 知道这里的不一致。我们可以使用 <code>@Mapping</code> 注解，并设置其内部的 <code>source</code> 和 <code>target</code> 标记分别指向不一致的两个字段。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DoctorMapper</span> </span>&#123;</span><br><span class=\"line\">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.<span class=\"keyword\">class</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"string\">&quot;doctor.specialty&quot;</span>, target = <span class=\"string\">&quot;specialization&quot;</span>)</span></span><br><span class=\"line\">    DoctorDto toDto(Doctor doctor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Mapping</span>`这个注解代码的含义是：`Doctor`中的`specialty`字段对应于`DoctorDto`类的 `specialization</span><br></pre></td></tr></table></figure>\n\n<p>编译之后，会生成如下实现代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DoctorMapperImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DoctorMapper</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DoctorDto <span class=\"title function_\">toDto</span><span class=\"params\">(Doctor doctor)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (doctor == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">DoctorDtoBuilder</span> <span class=\"variable\">doctorDto</span> <span class=\"operator\">=</span> DoctorDto.builder();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.specialization(doctor.getSpecialty());</span><br><span class=\"line\">        doctorDto.id(doctor.getId());</span><br><span class=\"line\">        doctorDto.name(doctor.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> doctorDto.build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h5 id=\"多个源类\"><a href=\"#多个源类\" class=\"headerlink\" title=\"多个源类\"></a><strong>多个源类</strong></h5></li>\n</ul>\n<p>有时，单个类不足以构建<code>DTO</code>，我们可能希望将多个类中的值聚合为一个<code>DTO</code>，供终端用户使用。这也可以通过在<code>@Mapping</code>注解中设置适当的标志来完成。</p>\n<p>我们先新建另一个对象 <code>Education</code>:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Education</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String degreeName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String institute;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer yearOfPassing;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后向 <code>DoctorDto</code>中添加一个新的字段：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoctorDto</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String degree;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String specialization;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，将 <code>DoctorMapper</code> 接口更新为如下代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DoctorMapper</span> </span>&#123;</span><br><span class=\"line\">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.<span class=\"keyword\">class</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"string\">&quot;doctor.specialty&quot;</span>, target = <span class=\"string\">&quot;specialization&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"string\">&quot;education.degreeName&quot;</span>, target = <span class=\"string\">&quot;degree&quot;</span>)</span></span><br><span class=\"line\">    DoctorDto toDto(Doctor doctor, Education education);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们添加了另一个<code>@Mapping</code>注解，并将其<code>source</code>设置为<code>Education</code>类的<code>degreeName</code>，将<code>target</code>设置为<code>DoctorDto</code>类的<code>degree</code>字段。</p>\n<p>如果 <code>Education</code> 类和 <code>Doctor</code> 类包含同名的字段，我们必须让映射器知道使用哪一个，否则它会抛出一个异常。举例来说，如果两个模型都包含一个<code>id</code>字段，我们就要选择将哪个类中的<code>id</code>映射到 DTO 属性中。</p>\n<ul>\n<li><h5 id=\"子对象映射\"><a href=\"#子对象映射\" class=\"headerlink\" title=\"子对象映射\"></a><strong>子对象映射</strong></h5></li>\n</ul>\n<p>多数情况下，POJO 中不会<em>只</em>包含基本数据类型，其中往往会包含其它类。比如说，一个<code>Doctor</code>类中会有多个患者类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Patient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 Doctor 中添加一个患者列表<code>List</code>:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Doctor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String specialty;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Patient&gt; patientList;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>Patient</code>需要转换，为其创建一个对应的 DTO</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PatientDto</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，在 <code>DoctorDto</code> 中新增一个存储 <code>PatientDto</code>的列表：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoctorDto</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String degree;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String specialization;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;PatientDto&gt; patientDtoList;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在修改 <code>DoctorMapper</code>之前，我们先创建一个支持 <code>Patient</code> 和 <code>PatientDto</code> 转换的映射器接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">PatientMapper</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">PatientMapper</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> Mappers.getMapper(PatientMapper.class);</span><br><span class=\"line\">    PatientDto <span class=\"title function_\">toDto</span><span class=\"params\">(Patient patient)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个基本映射器，只会处理几个基本数据类型。</p>\n<p>然后，我们再来修改 <code>DoctorMapper</code> 处理一下患者列表：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper(uses = &#123;PatientMapper.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DoctorMapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.<span class=\"keyword\">class</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"string\">&quot;doctor.patientList&quot;</span>, target = <span class=\"string\">&quot;patientDtoList&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"string\">&quot;doctor.specialty&quot;</span>, target = <span class=\"string\">&quot;specialization&quot;</span>)</span></span><br><span class=\"line\">    DoctorDto toDto(Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为我们要处理另一个需要映射的类，所以这里设置了<code>@Mapper</code>注解的<code>uses</code>标志，这样现在的 <code>@Mapper</code> 就可以使用另一个 <code>@Mapper</code>映射器。我们这里只加了一个，但你想在这里添加多少 class/mapper 都可以。</p>\n<p>我们已经添加了<code>uses</code>标志，所以在为<code>DoctorMapper</code>接口生成映射器实现时，MapStruct 也会把 <code>Patient</code> 模型转换成 <code>PatientDto</code> ——因为我们已经为这个任务注册了 <code>PatientMapper</code>。</p>\n<p>编译查看最新想实现代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DoctorMapperImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DoctorMapper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> final <span class=\"title class_\">PatientMapper</span> patientMapper = <span class=\"title class_\">Mappers</span>.<span class=\"title function_\">getMapper</span>( <span class=\"title class_\">PatientMapper</span>.<span class=\"property\">class</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title class_\">DoctorDto</span> <span class=\"title function_\">toDto</span>(<span class=\"params\">Doctor doctor</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( doctor == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"title class_\">DoctorDtoBuilder</span> doctorDto = <span class=\"title class_\">DoctorDto</span>.<span class=\"title function_\">builder</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.<span class=\"title function_\">patientDtoList</span>( <span class=\"title function_\">patientListToPatientDtoList</span>(doctor.<span class=\"title function_\">getPatientList</span>()));</span><br><span class=\"line\">        doctorDto.<span class=\"title function_\">specialization</span>( doctor.<span class=\"title function_\">getSpecialty</span>() );</span><br><span class=\"line\">        doctorDto.<span class=\"title function_\">id</span>( doctor.<span class=\"title function_\">getId</span>() );</span><br><span class=\"line\">        doctorDto.<span class=\"title function_\">name</span>( doctor.<span class=\"title function_\">getName</span>() );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> doctorDto.<span class=\"title function_\">build</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title class_\">List</span>&lt;<span class=\"title class_\">PatientDto</span>&gt; <span class=\"title function_\">patientListToPatientDtoList</span>(<span class=\"params\">List&lt;Patient&gt; list</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( list == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"title class_\">List</span>&lt;<span class=\"title class_\">PatientDto</span>&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;<span class=\"title class_\">PatientDto</span>&gt;( list.<span class=\"title function_\">size</span>() );</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"title class_\">Patient</span> patient : list ) &#123;</span><br><span class=\"line\">            list1.<span class=\"title function_\">add</span>( patientMapper.<span class=\"title function_\">toDto</span>( patient ) );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> list1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显然，除了<code>toDto()</code>映射方法外，最终实现中还添加了一个新的映射方法——&gt;<code>patientListToPatientDtoList()</code>。这个方法是在没有显式定义的情况下添加的，只是因为我们把<code>PatientMapper</code>添加到了<code>DoctorMapper</code>中。</p>\n<p>该方法会遍历一个<code>Patient</code>列表，将每个元素转换为<code>PatientDto</code>，并将转换后的对象添加到<code>DoctorDto</code>对象内中的列表中。</p>\n<h3 id=\"更新现有实例\"><a href=\"#更新现有实例\" class=\"headerlink\" title=\"更新现有实例\"></a><strong>更新现有实例</strong></h3><p>有时，我们希望用 DTO 的最新值更新一个模型中的属性，对目标对象(我们的例子中是<code>DoctorDto</code>)使用<code>@MappingTarget</code>注解，就可以更新现有的实例.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class&#125;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)</span><br><span class=\"line\">    void updateModel(DoctorDto doctorDto, @MappingTarget Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重新生成实现代码，就可以得到<code>updateModel()</code>方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void updateModel(DoctorDto doctorDto, Doctor doctor) &#123;</span><br><span class=\"line\">        if (doctorDto == null) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (doctor.getPatientList() != null) &#123;</span><br><span class=\"line\">            List&lt;Patient&gt; list = patientDtoListToPatientList(doctorDto.getPatientDtoList());</span><br><span class=\"line\">            if (list != null) &#123;</span><br><span class=\"line\">                doctor.getPatientList().clear();</span><br><span class=\"line\">                doctor.getPatientList().addAll(list);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                doctor.setPatientList(null);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            List&lt;Patient&gt; list = patientDtoListToPatientList(doctorDto.getPatientDtoList());</span><br><span class=\"line\">            if (list != null) &#123;</span><br><span class=\"line\">                doctor.setPatientList(list);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        doctor.setSpecialty(doctorDto.getSpecialization());</span><br><span class=\"line\">        doctor.setId(doctorDto.getId());</span><br><span class=\"line\">        doctor.setName(doctorDto.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是，由于患者列表是该模型中的子实体，因此患者列表也会进行更新。</p>\n<h3 id=\"数据类型映射\"><a href=\"#数据类型映射\" class=\"headerlink\" title=\"数据类型映射\"></a><strong>数据类型映射</strong></h3><p>MapStruct 支持<code>source</code>和<code>target</code>属性之间的数据类型转换。它还提供了基本类型及其相应的包装类之间的自动转换。</p>\n<p>自动类型转换适用于：</p>\n<ul>\n<li>基本类型及其对应的包装类之间。比如， <code>int</code> 和 <code>Integer</code>， <code>float</code> 和 <code>Float</code>， <code>long</code> 和 <code>Long</code>，<code>boolean</code> 和 <code>Boolean</code> 等。</li>\n<li>任意基本类型与任意包装类之间。如 <code>int</code> 和 <code>long</code>， <code>byte</code> 和 <code>Integer</code> 等。</li>\n<li>所有基本类型及包装类与<code>String</code>之间。如 <code>boolean</code> 和 <code>String</code>， <code>Integer</code> 和 <code>String</code>， <code>float</code> 和 <code>String</code> 等。</li>\n<li>枚举和<code>String</code>之间。</li>\n<li>Java 大数类型(<code>java.math.BigInteger</code>， <code>java.math.BigDecimal</code>) 和 Java 基本类型(包括其包装类)与<code>String</code>之间。</li>\n<li>其它情况详见 **<a href=\"https://link.zhihu.com/?target=https://mapstruct.org/documentation/stable/reference/html/#implicit-type-conversions\">MapStruct 官方文档</a>**。</li>\n</ul>\n<p>因此，在生成映射器代码的过程中，如果源字段和目标字段之间属于上述任何一种情况，则 MapStrcut 会自行处理类型转换。</p>\n<p>我们修改 <code>PatientDto</code> ，新增一个 <code>dateofBirth</code>字段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PatientDto &#123;</span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private LocalDate dateOfBirth;</span><br><span class=\"line\">    // getters and setters or builder</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一方面，加入 <code>Patient</code> 对象中有一个<code>String</code> 类型的 <code>dateOfBirth</code> ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Patient &#123;</span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String dateOfBirth;</span><br><span class=\"line\">    // getters and setters or builder</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在两者之间创建一个映射器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper</span><br><span class=\"line\">public interface PatientMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)</span><br><span class=\"line\">    Patient toModel(PatientDto patientDto);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当对日期进行转换时，我们也可以使用 <code>dateFormat</code> 设置格式声明。生成的实现代码形式大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PatientMapperImpl implements PatientMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Patient toModel(PatientDto patientDto) &#123;</span><br><span class=\"line\">        if (patientDto == null) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PatientBuilder patient = Patient.builder();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (patientDto.getDateOfBirth() != null) &#123;</span><br><span class=\"line\">            patient.dateOfBirth(DateTimeFormatter.ofPattern(&quot;dd/MMM/yyyy&quot;)</span><br><span class=\"line\">                                .format(patientDto.getDateOfBirth()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        patient.id(patientDto.getId());</span><br><span class=\"line\">        patient.name(patientDto.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        return patient.build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这里使用了 <code>dateFormat</code> 声明的日期格式。如果我们没有声明格式的话，MapStruct 会使用 <code>LocalDate</code>的默认格式，大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (patientDto.getDateOfBirth() != null) &#123;</span><br><span class=\"line\">    patient.dateOfBirth(DateTimeFormatter.ISO_LOCAL_DATE</span><br><span class=\"line\">                        .format(patientDto.getDateOfBirth()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h5 id=\"数字格式转换\"><a href=\"#数字格式转换\" class=\"headerlink\" title=\"数字格式转换\"></a><strong>数字格式转换</strong></h5></li>\n</ul>\n<p>上面的例子中可以看到，在进行日期转换的时候，可以通过<code>dateFormat</code>标志指定日期的格式。</p>\n<p>除此之外，对于数字的转换，也可以使用<code>numberFormat</code>指定显示格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 数字格式转换示例</span><br><span class=\"line\">   @Mapping(source = &quot;price&quot;, target = &quot;price&quot;, numberFormat = &quot;$#.00&quot;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"枚举映射\"><a href=\"#枚举映射\" class=\"headerlink\" title=\"枚举映射\"></a><strong>枚举映射</strong></h3><p>枚举映射的工作方式与字段映射相同。MapStruct 会对具有相同名称的枚举进行映射，这一点没有问题。但是，对于具有不同名称的枚举项，我们需要使用<code>@ValueMapping</code>注解。同样，这与普通类型的<code>@Mapping</code>注解也相似。</p>\n<p>我们先创建两个枚举。第一个是 <code>PaymentType</code>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum PaymentType &#123;</span><br><span class=\"line\">    CASH,</span><br><span class=\"line\">    CHEQUE,</span><br><span class=\"line\">    CARD_VISA,</span><br><span class=\"line\">    CARD_MASTER,</span><br><span class=\"line\">    CARD_CREDIT</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如说，这是一个应用内可用的支付方式，现在我们要根据这些选项创建一个更一般、有限的识图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum PaymentTypeView &#123;</span><br><span class=\"line\">    CASH,</span><br><span class=\"line\">    CHEQUE,</span><br><span class=\"line\">    CARD</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们创建这两个<code>enum</code>之间的映射器接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper</span><br><span class=\"line\">public interface PaymentTypeMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    PaymentTypeMapper INSTANCE = Mappers.getMapper(PaymentTypeMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @ValueMappings(&#123;</span><br><span class=\"line\">            @ValueMapping(source = &quot;CARD_VISA&quot;, target = &quot;CARD&quot;),</span><br><span class=\"line\">            @ValueMapping(source = &quot;CARD_MASTER&quot;, target = &quot;CARD&quot;),</span><br><span class=\"line\">            @ValueMapping(source = &quot;CARD_CREDIT&quot;, target = &quot;CARD&quot;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个例子中，我们设置了一般性的<code>CARD</code>值，和更具体的 <code>CARD_VISA</code>, <code>CARD_MASTER</code> 和 <code>CARD_CREDIT</code> 。两个枚举间的枚举项数量不匹配—— <code>PaymentType</code> 有 5 个值，而 <code>PaymentTypeView</code> 只有 3 个。</p>\n<p>为了在这些枚举项之间建立桥梁，我们可以使用<code>@ValueMappings</code>注解，该注解中可以包含多个<code>@ValueMapping</code>注解。这里，我们将<code>source</code>设置为三个具体枚举项之一，并将<code>target</code>设置为<code>CARD</code>。</p>\n<p>MapStruct 自然会处理这些情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PaymentTypeMapperImpl implements PaymentTypeMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType) &#123;</span><br><span class=\"line\">        if (paymentType == null) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PaymentTypeView paymentTypeView;</span><br><span class=\"line\"></span><br><span class=\"line\">        switch (paymentType) &#123;</span><br><span class=\"line\">            case CARD_VISA: paymentTypeView = PaymentTypeView.CARD;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">            case CARD_MASTER: paymentTypeView = PaymentTypeView.CARD;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">            case CARD_CREDIT: paymentTypeView = PaymentTypeView.CARD;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">            case CASH: paymentTypeView = PaymentTypeView.CASH;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">            case CHEQUE: paymentTypeView = PaymentTypeView.CHEQUE;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">            default: throw new IllegalArgumentException( &quot;Unexpected enum constant: &quot; + paymentType );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return paymentTypeView;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>CASH</code>和<code>CHEQUE</code>默认转换为对应值，特殊的 <code>CARD</code> 值通过<code>switch</code>循环处理。</p>\n<p>但是，如果你要将很多值转换为一个更一般的值，这种方式就有些不切实际了。其实我们不必手动分配每一个值，只需要让 MapStruct 将所有剩余的可用枚举项（在目标枚举中找不到相同名称的枚举项），直接转换为对应的另一个枚举项。</p>\n<p>可以通过 <code>MappingConstants</code>实现这一点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ValueMapping(source = MappingConstants.ANY_REMAINING, target = &quot;CARD&quot;)</span><br><span class=\"line\">PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType);</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，完成默认映射之后，所有剩余（未匹配）的枚举项都会映射为<code>CARD</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType) &#123;</span><br><span class=\"line\">    if ( paymentType == null ) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PaymentTypeView paymentTypeView;</span><br><span class=\"line\"></span><br><span class=\"line\">    switch ( paymentType ) &#123;</span><br><span class=\"line\">        case CASH: paymentTypeView = PaymentTypeView.CASH;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">        case CHEQUE: paymentTypeView = PaymentTypeView.CHEQUE;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">        default: paymentTypeView = PaymentTypeView.CARD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return paymentTypeView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有一种选择是使用<code>ANY UNMAPPED</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ValueMapping(source = MappingConstants.ANY_UNMAPPED, target = &quot;CARD&quot;)</span><br><span class=\"line\">PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType);</span><br></pre></td></tr></table></figure>\n\n<p>采用这种方式时，MapStruct 不会像前面那样先处理默认映射，再将剩余的枚举项映射到<code>target</code>值。而是，直接将<em>所有</em>未通过<code>@ValueMapping</code>注解做显式映射的值都转换为<code>target</code>值。</p>\n<h3 id=\"集合映射\"><a href=\"#集合映射\" class=\"headerlink\" title=\"集合映射\"></a><strong>集合映射</strong></h3><p>简单来说，使用 MapStruct 处理集合映射的方式与处理简单类型相同。</p>\n<p>我们创建一个简单的接口或抽象类并声明映射方法。 MapStruct 将根据我们的声明自动生成映射代码。 通常，生成的代码会遍历源集合，将每个元素转换为目标类型，并将每个转换后元素添加到目标集合中。</p>\n<ul>\n<li><h5 id=\"List-映射\"><a href=\"#List-映射\" class=\"headerlink\" title=\"List 映射\"></a><strong>List 映射</strong></h5></li>\n</ul>\n<p>我们先定义一个新的映射方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\">    List&lt;DoctorDto&gt; map(List&lt;Doctor&gt; doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成的代码大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public List&lt;DoctorDto&gt; map(List&lt;Doctor&gt; doctor) &#123;</span><br><span class=\"line\">        if ( doctor == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;DoctorDto&gt; list = new ArrayList&lt;DoctorDto&gt;( doctor.size() );</span><br><span class=\"line\">        for ( Doctor doctor1 : doctor ) &#123;</span><br><span class=\"line\">            list.add( doctorToDoctorDto( doctor1 ) );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected DoctorDto doctorToDoctorDto(Doctor doctor) &#123;</span><br><span class=\"line\">        if ( doctor == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DoctorDto doctorDto = new DoctorDto();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.setId( doctor.getId() );</span><br><span class=\"line\">        doctorDto.setName( doctor.getName() );</span><br><span class=\"line\">        doctorDto.setSpecialization( doctor.getSpecialization() );</span><br><span class=\"line\"></span><br><span class=\"line\">        return doctorDto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，MapStruct 为我们自动生成了从<code>Doctor</code>到<code>DoctorDto</code>的映射方法。</p>\n<p>但是需要注意，如果我们在 DTO 中新增一个字段<code>fullName</code>，生成代码时会出现错误：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">警告: Unmapped target property: &quot;fullName&quot;.</span><br></pre></td></tr></table></figure>\n\n<p>基本上，这意味着 MapStruct 在当前情况下无法为我们自动生成映射方法。因此，我们需要手动定义<code>Doctor</code>和<code>DoctorDto</code>之间的映射方法。具体参考之前的小节。</p>\n<ul>\n<li><h5 id=\"Set-和-Map-映射\"><a href=\"#Set-和-Map-映射\" class=\"headerlink\" title=\"Set 和 Map 映射\"></a><strong>Set 和 Map 映射</strong></h5></li>\n</ul>\n<p>Set 与 Map 型数据的处理方式与 List 相似。按照以下方式修改<code>DoctorMapper</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Set&lt;DoctorDto&gt; setConvert(Set&lt;Doctor&gt; doctor);</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, DoctorDto&gt; mapConvert(Map&lt;String, Doctor&gt; doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成的最终实现代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Set&lt;DoctorDto&gt; setConvert(Set&lt;Doctor&gt; doctor) &#123;</span><br><span class=\"line\">        if ( doctor == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Set&lt;DoctorDto&gt; set = new HashSet&lt;DoctorDto&gt;( Math.max( (int) ( doctor.size() / .75f ) + 1, 16 ) );</span><br><span class=\"line\">        for ( Doctor doctor1 : doctor ) &#123;</span><br><span class=\"line\">            set.add( doctorToDoctorDto( doctor1 ) );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return set;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Map&lt;String, DoctorDto&gt; mapConvert(Map&lt;String, Doctor&gt; doctor) &#123;</span><br><span class=\"line\">        if ( doctor == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;String, DoctorDto&gt; map = new HashMap&lt;String, DoctorDto&gt;( Math.max( (int) ( doctor.size() / .75f ) + 1, 16 ) );</span><br><span class=\"line\"></span><br><span class=\"line\">        for ( java.util.Map.Entry&lt;String, Doctor&gt; entry : doctor.entrySet() ) &#123;</span><br><span class=\"line\">            String key = entry.getKey();</span><br><span class=\"line\">            DoctorDto value = doctorToDoctorDto( entry.getValue() );</span><br><span class=\"line\">            map.put( key, value );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return map;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected DoctorDto doctorToDoctorDto(Doctor doctor) &#123;</span><br><span class=\"line\">        if ( doctor == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DoctorDto doctorDto = new DoctorDto();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.setId( doctor.getId() );</span><br><span class=\"line\">        doctorDto.setName( doctor.getName() );</span><br><span class=\"line\">        doctorDto.setSpecialization( doctor.getSpecialization() );</span><br><span class=\"line\"></span><br><span class=\"line\">        return doctorDto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与 List 映射类似，MapStruct 自动生成了<code>Doctor</code>转换为<code>DoctorDto</code>的映射方法。</p>\n<ul>\n<li><h5 id=\"集合映射策略\"><a href=\"#集合映射策略\" class=\"headerlink\" title=\"集合映射策略\"></a><strong>集合映射策略</strong></h5></li>\n</ul>\n<p>很多场景中，我们需要对具有父子关系的数据类型进行转换。通常来说，会有一个数据类型（父），其字段是另一个数据类型（子）的集合。</p>\n<p>对于这种情况，MapStruct 提供了一种方法来选择如何将子类型设置或添加到父类型中。具体来说，就是<code>@Mapper</code>注解中的<code>collectionMappingStrategy</code>属性，该属性可以取值为<code>ACCESSOR_ONLY</code>， <code>SETTER_PREFERRED</code>， <code>ADDER_PREFERRED</code> 或<code>TARGET_IMMUTABLE</code>。</p>\n<p>这些值分别表示不同的为子类型集合赋值的方式。默认值是<code>ACCESSOR_ONLY</code>，这意味着只能使用访问器来设置子集合。</p>\n<p>当父类型中的<em>Collection</em>字段<code>setter</code>方法不可用，但我们有一个子类型<code>add</code>方法时，这个选项就派上用场了；另一种有用的情况是父类型中的<em>Collection</em>字段是不可变的。</p>\n<p>我们新建一个类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Hospital &#123;</span><br><span class=\"line\">    private List&lt;Doctor&gt; doctors;</span><br><span class=\"line\">    // getters and setters or builder</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时定义一个映射目标 DTO 类，同时定义子类型集合字段的 getter、setter 和 adder：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HospitalDto &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;DoctorDto&gt; doctors;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 子类型集合字段getter</span><br><span class=\"line\">    public List&lt;DoctorDto&gt; getDoctors() &#123;</span><br><span class=\"line\">        return doctors;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  // 子类型集合字段setter</span><br><span class=\"line\">    public void setDoctors(List&lt;DoctorDto&gt; doctors) &#123;</span><br><span class=\"line\">        this.doctors = doctors;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  // 子类型数据adder</span><br><span class=\"line\">    public void addDoctor(DoctorDto doctorDTO) &#123;</span><br><span class=\"line\">        if (doctors == null) &#123;</span><br><span class=\"line\">            doctors = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        doctors.add(doctorDTO);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建对应的映射器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = DoctorMapper.class)</span><br><span class=\"line\">public interface HospitalMapper &#123;</span><br><span class=\"line\">    HospitalMapper INSTANCE = Mappers.getMapper(HospitalMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    HospitalDto toDto(Hospital hospital);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成的最终实现代码为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HospitalMapperImpl implements HospitalMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public HospitalDto toDto(Hospital hospital) &#123;</span><br><span class=\"line\">        if ( hospital == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        HospitalDto hospitalDto = new HospitalDto();</span><br><span class=\"line\"></span><br><span class=\"line\">        hospitalDto.setDoctors( doctorListToDoctorDtoList( hospital.getDoctors() ) );</span><br><span class=\"line\"></span><br><span class=\"line\">        return hospitalDto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在默认情况下采用的策略是<code>ACCESSOR_ONLY</code>，使用 setter 方法<code>setDoctors()</code>向<code>HospitalDto</code>对象中写入列表数据。</p>\n<p>相对的，如果使用 <code>ADDER_PREFERRED</code> 作为映射策略：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(collectionMappingStrategy = CollectionMappingStrategy.ADDER_PREFERRED,</span><br><span class=\"line\">        uses = DoctorMapper.class)</span><br><span class=\"line\">public interface HospitalMapper &#123;</span><br><span class=\"line\">    HospitalMapper INSTANCE = Mappers.getMapper(HospitalMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    HospitalDto toDto(Hospital hospital);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时，会使用 adder 方法逐个将转换后的子类型 DTO 对象加入父类型的集合字段中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CompanyMapperAdderPreferredImpl implements CompanyMapperAdderPreferred &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final EmployeeMapper employeeMapper = Mappers.getMapper( EmployeeMapper.class );</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public CompanyDTO map(Company company) &#123;</span><br><span class=\"line\">        if ( company == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        CompanyDTO companyDTO = new CompanyDTO();</span><br><span class=\"line\"></span><br><span class=\"line\">        if ( company.getEmployees() != null ) &#123;</span><br><span class=\"line\">            for ( Employee employee : company.getEmployees() ) &#123;</span><br><span class=\"line\">                companyDTO.addEmployee( employeeMapper.map( employee ) );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return companyDTO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果目标 DTO 中既没有<code>setter</code>方法也没有<code>adder</code>方法，会先通过<code>getter</code>方法获取子类型集合，再调用集合的对应接口添加子类型对象。</p>\n<p>可以在**<a href=\"https://link.zhihu.com/?target=https://mapstruct.org/documentation/stable/reference/html/#collection-mapping-strategies\">参考文档</a>**中看到不同类型的 DTO 定义（是否包含 setter 方法或 adder 方法），采用不同的映射策略时，所使用的添加子类型到集合中的方式。</p>\n<ul>\n<li><h5 id=\"目标集合实现类型\"><a href=\"#目标集合实现类型\" class=\"headerlink\" title=\"目标集合实现类型\"></a><strong>目标集合实现类型</strong></h5></li>\n</ul>\n<p>MapStruct 支持将集合接口作为映射方法的目标类型。</p>\n<p>在这种情况下，在生成的代码中会使用一些集合接口默认实现。 例如，上面的示例中，<code>List</code>的默认实现是<code>ArrayList</code>。</p>\n<p>常见接口及其对应的默认实现如下：</p>\n<p>无法复制加载中的内容</p>\n<p>你可以在**<a href=\"https://link.zhihu.com/?target=https://mapstruct.org/documentation/stable/reference/html/#implementation-types-for-collection-mappings\">参考文档</a>**中找到 MapStruct 支持的所有接口列表，以及每个接口对应的默认实现类型。</p>\n<h2 id=\"进阶操作\"><a href=\"#进阶操作\" class=\"headerlink\" title=\"进阶操作\"></a><strong>进阶操作</strong></h2><h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a><strong>依赖注入</strong></h3><p>到目前为止，我们一直在通过<code>getMapper()</code>方法访问生成的映射器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果你使用的是 Spring，只需要简单修改映射器配置，就可以像常规依赖项一样注入映射器。</p>\n<p>修改 <code>DoctorMapper</code> 以支持 Spring 框架：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public interface DoctorMapper &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>@Mapper</code>注解中添加<code>（componentModel = &quot;spring&quot;）</code>，是为了告诉 MapStruct，在生成映射器实现类时，我们希望它能支持通过 Spring 的依赖注入来创建。现在，就不需要在接口中添加 <code>INSTANCE</code> 字段了。</p>\n<p>这次生成的 <code>DoctorMapperImpl</code> 会带有 <code>@Component</code> 注解：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class DoctorMapperImpl implements DoctorMapper &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只要被标记为<code>@Component</code>，Spring 就可以把它作为一个 bean 来处理，你就可以在其它类（如控制器）中通过<code>@Autowire</code>注解来使用它：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class DoctorController() &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private DoctorMapper doctorMapper;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你不使用 Spring, MapStruct 也支持**<a href=\"https://link.zhihu.com/?target=https://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html\">Java CDI</a>**：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(componentModel = &quot;cdi&quot;)</span><br><span class=\"line\">public interface DoctorMapper &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加默认值\"><a href=\"#添加默认值\" class=\"headerlink\" title=\"添加默认值\"></a><strong>添加默认值</strong></h3><p><code>@Mapping</code> 注解有两个很实用的标志就是常量 <code>constant</code> 和默认值 <code>defaultValue</code> 。无论<code>source</code>如何取值，都将始终使用常量值； 如果<code>source</code>取值为<code>null</code>，则会使用默认值。</p>\n<p>修改一下 <code>DoctorMapper</code> ，添加一个 <code>constant</code> 和一个 <code>defaultValue</code> ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class&#125;, componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\">    @Mapping(target = &quot;id&quot;, constant = &quot;-1&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;, defaultValue = &quot;Information Not Available&quot;)</span><br><span class=\"line\">    DoctorDto toDto(Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>specialty</code>不可用，我们会替换为<code>&quot;Information Not Available&quot;</code>字符串，此外，我们将<code>id</code>硬编码为<code>-1</code>。</p>\n<p>生成代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private PatientMapper patientMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public DoctorDto toDto(Doctor doctor) &#123;</span><br><span class=\"line\">        if (doctor == null) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DoctorDto doctorDto = new DoctorDto();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (doctor.getSpecialty() != null) &#123;</span><br><span class=\"line\">            doctorDto.setSpecialization(doctor.getSpecialty());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            doctorDto.setSpecialization(&quot;Information Not Available&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        doctorDto.setPatientDtoList(patientListToPatientDtoList(doctor.getPatientList()));</span><br><span class=\"line\">        doctorDto.setName(doctor.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.setId(-1);</span><br><span class=\"line\"></span><br><span class=\"line\">        return doctorDto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，如果 <code>doctor.getSpecialty()</code> 返回值为<code>null</code>，则将<code>specialization</code>设置为我们的默认信息。无论任何情况，都会对 <code>id</code>赋值，因为这是一个<code>constant</code>。</p>\n<h3 id=\"添加表达式\"><a href=\"#添加表达式\" class=\"headerlink\" title=\"添加表达式\"></a><strong>添加表达式</strong></h3><p>MapStruct 甚至允许在<code>@Mapping</code>注解中输入 Java 表达式。你可以设置 <code>defaultExpression</code> （ <code>source</code> 取值为 <code>null</code>时生效），或者一个<code>expression</code>（类似常量，永久生效）。</p>\n<p>在 <code>Doctor</code> 和 <code>DoctorDto</code>两个类中都加了两个新属性，一个是 <code>String</code> 类型的 <code>externalId</code> ，另一个是<code>LocalDateTime</code>类型的 <code>appointment</code> ，两个类大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Doctor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String externalId;</span><br><span class=\"line\">    private String specialty;</span><br><span class=\"line\">    private LocalDateTime availability;</span><br><span class=\"line\">    private List&lt;Patient&gt; patientList;</span><br><span class=\"line\">    // getters and setters or builder</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class DoctorDto &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String externalId;</span><br><span class=\"line\">    private String specialization;</span><br><span class=\"line\">    private LocalDateTime availability;</span><br><span class=\"line\">    private List&lt;PatientDto&gt; patientDtoList;</span><br><span class=\"line\">    // getters and setters or builder</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改 <code>DoctorMapper</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class&#125;, componentModel = &quot;spring&quot;, imports = &#123;LocalDateTime.class, UUID.class&#125;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(target = &quot;externalId&quot;, expression = &quot;java(UUID.randomUUID().toString())&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.availability&quot;, target = &quot;availability&quot;, defaultExpression = &quot;java(LocalDateTime.now())&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)</span><br><span class=\"line\">    DoctorDto toDtoWithExpression(Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这里将 <code>externalId</code>的值设置为 <code>java(UUID.randomUUID().toString())</code> ，如果源对象中没有 <code>availability</code> 属性，则会把目标对象中的 <code>availability</code> 设置为一个新的 <code>LocalDateTime</code>对象。</p>\n<p>由于表达式只是字符串，我们必须在表达式中指定使用的类。但是这里的表达式并不是最终执行的代码，只是一个字母的文本值。因此，我们要在 <code>@Mapper</code> 中添加 <code>imports = &#123;LocalDateTime.class, UUID.class&#125;</code> 。</p>\n<h3 id=\"添加自定义方法\"><a href=\"#添加自定义方法\" class=\"headerlink\" title=\"添加自定义方法\"></a><strong>添加自定义方法</strong></h3><p>到目前为止，我们一直使用的策略是添加一个“占位符”方法，并期望 MapStruct 能为我们实现它。其实我们还可以向接口中添加自定义的<code>default</code>方法，也可以通过<code>default</code>方法直接实现一个映射。然后我们可以通过实例直接调用该方法，没有任何问题。</p>\n<p>为此，我们创建一个 <code>DoctorPatientSummary</code>类，其中包含一个 <code>Doctor</code> 及其 <code>Patient</code>列表的汇总信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DoctorPatientSummary &#123;</span><br><span class=\"line\">    private int doctorId;</span><br><span class=\"line\">    private int patientCount;</span><br><span class=\"line\">    private String doctorName;</span><br><span class=\"line\">    private String specialization;</span><br><span class=\"line\">    private String institute;</span><br><span class=\"line\">    private List&lt;Integer&gt; patientIds;</span><br><span class=\"line\">    // getters and setters or builder</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们在 <code>DoctorMapper</code>中添加一个<code>default</code>方法，该方法会将 <code>Doctor</code> 和 <code>Education</code> 对象转换为一个 <code>DoctorPatientSummary</code>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    default DoctorPatientSummary toDoctorPatientSummary(Doctor doctor, Education education) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return DoctorPatientSummary.builder()</span><br><span class=\"line\">                .doctorId(doctor.getId())</span><br><span class=\"line\">                .doctorName(doctor.getName())</span><br><span class=\"line\">                .patientCount(doctor.getPatientList().size())</span><br><span class=\"line\">        .patientIds(doctor.getPatientList()</span><br><span class=\"line\">                     .stream()</span><br><span class=\"line\">                      .map(Patient::getId)</span><br><span class=\"line\">                     .collect(Collectors.toList()))</span><br><span class=\"line\">              .institute(education.getInstitute())</span><br><span class=\"line\">                .specialization(education.getDegreeName())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里使用了 Builder 模式创建<code>DoctorPatientSummary</code>对象。</p>\n<p>在 MapStruct 生成映射器实现类之后，你就可以使用这个实现方法，就像访问任何其它映射器方法一样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DoctorPatientSummary summary = doctorMapper.toDoctorPatientSummary(dotor, education);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建自定义映射器\"><a href=\"#创建自定义映射器\" class=\"headerlink\" title=\"创建自定义映射器\"></a><strong>创建自定义映射器</strong></h3><p>前面我们一直是通过接口来设计映射器功能，其实我们也可以通过一个带 <code>@Mapper</code> 的 <code>abstract</code> 类来实现一个映射器。MapStruct 也会为这个类创建一个实现，类似于创建一个接口实现。</p>\n<p>我们重写一下前面的示例，这一次，我们将它修改为一个抽象类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper</span><br><span class=\"line\">public abstract class DoctorCustomMapper &#123;</span><br><span class=\"line\">    public DoctorPatientSummary toDoctorPatientSummary(Doctor doctor, Education education) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return DoctorPatientSummary.builder()</span><br><span class=\"line\">                .doctorId(doctor.getId())</span><br><span class=\"line\">                .doctorName(doctor.getName())</span><br><span class=\"line\">                .patientCount(doctor.getPatientList().size())</span><br><span class=\"line\">                .patientIds(doctor.getPatientList()</span><br><span class=\"line\">                        .stream()</span><br><span class=\"line\">                        .map(Patient::getId)</span><br><span class=\"line\">                        .collect(Collectors.toList()))</span><br><span class=\"line\">                .institute(education.getInstitute())</span><br><span class=\"line\">                .specialization(education.getDegreeName())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以用同样的方式使用这个映射器。由于限制较少，使用抽象类可以在创建自定义实现时给我们更多的控制和选择。另一个好处是可以添加<code>@BeforeMapping</code>和<code>@AfterMapping</code>方法。</p>\n<h3 id=\"BeforeMapping-和-AfterMapping\"><a href=\"#BeforeMapping-和-AfterMapping\" class=\"headerlink\" title=\"@BeforeMapping 和 @AfterMapping\"></a><strong>@BeforeMapping 和 @AfterMapping</strong></h3><p>为了进一步控制和定制化，我们可以定义 <code>@BeforeMapping</code> 和 <code>@AfterMapping</code>方法。显然，这两个方法是在每次映射之前和之后执行的。也就是说，在最终的实现代码中，会在两个对象真正映射之前和之后添加并执行这两个方法。</p>\n<p>可以在 <code>DoctorCustomMapper</code>中添加两个方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class&#125;, componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public abstract class DoctorCustomMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @BeforeMapping</span><br><span class=\"line\">    protected void validate(Doctor doctor) &#123;</span><br><span class=\"line\">        if(doctor.getPatientList() == null)&#123;</span><br><span class=\"line\">            doctor.setPatientList(new ArrayList&lt;&gt;());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @AfterMapping</span><br><span class=\"line\">    protected void updateResult(@MappingTarget DoctorDto doctorDto) &#123;</span><br><span class=\"line\">        doctorDto.setName(doctorDto.getName().toUpperCase());</span><br><span class=\"line\">        doctorDto.setDegree(doctorDto.getDegree().toUpperCase());</span><br><span class=\"line\">        doctorDto.setSpecialization(doctorDto.getSpecialization().toUpperCase());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)</span><br><span class=\"line\">    public abstract DoctorDto toDoctorDto(Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基于该抽象类生成一个映射器实现类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class DoctorCustomMapperImpl extends DoctorCustomMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private PatientMapper patientMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public DoctorDto toDoctorDto(Doctor doctor) &#123;</span><br><span class=\"line\">        validate(doctor);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (doctor == null) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DoctorDto doctorDto = new DoctorDto();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.setPatientDtoList(patientListToPatientDtoList(doctor</span><br><span class=\"line\">            .getPatientList()));</span><br><span class=\"line\">        doctorDto.setSpecialization(doctor.getSpecialty());</span><br><span class=\"line\">        doctorDto.setId(doctor.getId());</span><br><span class=\"line\">        doctorDto.setName(doctor.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        updateResult(doctorDto);</span><br><span class=\"line\"></span><br><span class=\"line\">        return doctorDto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到， <code>validate()</code> 方法会在 <code>DoctorDto</code> 对象实例化之前执行，而<code>updateResult()</code>方法会在映射结束之后执行。</p>\n<h3 id=\"映射异常处理\"><a href=\"#映射异常处理\" class=\"headerlink\" title=\"映射异常处理\"></a><strong>映射异常处理</strong></h3><p>异常处理是不可避免的，应用程序随时会产生异常状态。MapStruct 提供了对异常处理的支持，可以简化开发者的工作。</p>\n<p>考虑这样一个场景，我们想在 <code>Doctor</code> 映射为<code>DoctorDto</code>之前校验一下 <code>Doctor</code> 的数据。我们新建一个独立的 <code>Validator</code> 类进行校验：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Validator &#123;</span><br><span class=\"line\">    public int validateId(int id) throws ValidationException &#123;</span><br><span class=\"line\">        if(id == -1)&#123;</span><br><span class=\"line\">            throw new ValidationException(&quot;Invalid value in ID&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们修改一下 <code>DoctorMapper</code> 以使用 <code>Validator</code> 类，无需指定实现。跟之前一样， 在<code>@Mapper</code>使用的类列表中添加该类。我们还需要做的就是告诉 MapStruct 我们的 <code>toDto()</code> 会抛出 <code>throws ValidationException</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class, Validator.class&#125;, componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)</span><br><span class=\"line\">    DoctorDto toDto(Doctor doctor) throws ValidationException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终生成的映射器代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private PatientMapper patientMapper;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private Validator validator;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public DoctorDto toDto(Doctor doctor) throws ValidationException &#123;</span><br><span class=\"line\">        if (doctor == null) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DoctorDto doctorDto = new DoctorDto();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.setPatientDtoList(patientListToPatientDtoList(doctor</span><br><span class=\"line\">            .getPatientList()));</span><br><span class=\"line\">        doctorDto.setSpecialization(doctor.getSpecialty());</span><br><span class=\"line\">        doctorDto.setId(validator.validateId(doctor.getId()));</span><br><span class=\"line\">        doctorDto.setName(doctor.getName());</span><br><span class=\"line\">        doctorDto.setExternalId(doctor.getExternalId());</span><br><span class=\"line\">        doctorDto.setAvailability(doctor.getAvailability());</span><br><span class=\"line\"></span><br><span class=\"line\">        return doctorDto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>MapStruct 自动将<code>doctorDto</code>的<code>id</code>设置为<code>Validator</code>实例的方法返回值。它还在该方法签名中添加了一个 throws 子句。</p>\n<p>注意，如果映射前后的一对属性的类型与<code>Validator</code>中的方法出入参类型一致，那该字段映射时就会调用<code>Validator</code>中的方法，所以该方式请谨慎使用。</p>\n<h3 id=\"映射配置\"><a href=\"#映射配置\" class=\"headerlink\" title=\"映射配置\"></a><strong>映射配置</strong></h3><p>MapStruct 为编写映射器方法提供了一些非常有用的配置。多数情况下，如果我们已经定义了两个类型之间的映射方法，当我们要添加相同类型之间的另一个映射方法时，我们往往会直接复制已有方法的映射配置。</p>\n<p>其实我们不必手动复制这些注解，只需要简单的配置就可以创建一个相同/相似的映射方法。</p>\n<h5 id=\"继承配置\"><a href=\"#继承配置\" class=\"headerlink\" title=\"继承配置\"></a><strong>继承配置</strong></h5><p>我们回顾一下“**<a href=\"https://zhuanlan.zhihu.com/p/368731266/edit#%E6%9B%B4%E6%96%B0%E7%8E%B0%E6%9C%89%E5%AE%9E%E4%BE%8B\">更新现有实例</a>**”，在该场景中，我们创建了一个映射器，根据 DoctorDto 对象的属性更新现有的 Doctor 对象的属性值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class&#125;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)</span><br><span class=\"line\">    void updateModel(DoctorDto doctorDto, @MappingTarget Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设我们还有另一个映射器，将 <code>DoctorDto</code>转换为 <code>Doctor</code> ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class, Validator.class&#125;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)</span><br><span class=\"line\">    Doctor toModel(DoctorDto doctorDto);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个映射方法使用了相同的注解配置， <code>source</code>和 <code>target</code>都是相同的。其实我们可以使用<code>@InheritConfiguration</code>注释，从而避免这两个映射器方法的重复配置。</p>\n<p>如果对一个方法添加 <code>@InheritConfiguration</code> 注解，MapStruct 会检索其它的已配置方法，寻找可用于当前方法的注解配置。一般来说，这个注解都用于<code>mapping</code>方法后面的<code>update</code>方法，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class, Validator.class&#125;, componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)</span><br><span class=\"line\">    Doctor toModel(DoctorDto doctorDto);</span><br><span class=\"line\"></span><br><span class=\"line\">    @InheritConfiguration</span><br><span class=\"line\">    void updateModel(DoctorDto doctorDto, @MappingTarget Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"继承逆向配置\"><a href=\"#继承逆向配置\" class=\"headerlink\" title=\"继承逆向配置\"></a><strong>继承逆向配置</strong></h5><p>还有另外一个类似的场景，就是编写映射函数将**<em>Model</em>** 转为 **<em>DTO</em>**，以及将 <strong><em>DTO</em></strong> 转为 **<em>Model</em>**。如下面的代码所示，我们必须在两个函数上添加相同的注释。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public interface PatientMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)</span><br><span class=\"line\">    Patient toModel(PatientDto patientDto);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)</span><br><span class=\"line\">    PatientDto toDto(Patient patient);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两个方法的配置不会是完全相同的，实际上，它们应该是相反的。将 <strong>Model</strong> 转为 **<em>DTO</em>**，以及将 <strong><em>DTO</em></strong> 转为 **<em>Model</em>**——映射前后的字段相同，但是源属性字段与目标属性字段是相反的。</p>\n<p>我们可以在第二个方法上使用<code>@InheritInverseConfiguration</code>注解，避免写两遍映射配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public interface PatientMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)</span><br><span class=\"line\">    Patient toModel(PatientDto patientDto);</span><br><span class=\"line\"></span><br><span class=\"line\">    @InheritInverseConfiguration</span><br><span class=\"line\">    PatientDto toDto(Patient patient);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个 Mapper 生成的代码是相同的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>在本文中，我们探讨了 MapStruct——一个用于创建映射器类的库。从基本映射到自定义方法和自定义映射器，此外， 我们还介绍了 MapStruct 提供的一些高级操作选项，包括依赖注入，数据类型映射、枚举映射和表达式使用。</p>\n<p>MapStruct 提供了一个功能强大的集成插件，可减少开发人员编写模板代码的工作量，使创建映射器的过程变得简单快捷。</p>\n","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>随着微服务和分布式应用程序迅速占领开发领域，数据完整性和安全性比以往任何时候都更加重要。在这些松散耦合的系统之间，安全的通信渠道和有限的数据传输是最重要的。大多数时候，终端用户或服务不需要访问模型中的全部数据，而只需要访问某些特定的部分。</p>\n<p>数据传输对象(Data Transfer Objects, DTO)经常被用于这些应用中。DTO 只是持有另一个对象中被请求的信息的对象。通常情况下，这些信息是有限的一部分。例如，在持久化层定义的实体和发往客户端的 DTO 之间经常会出现相互之间的转换。由于 DTO 是原始对象的反映，因此这些类之间的映射器在转换过程中扮演着关键角色。</p>\n<p>这就是 MapStruct 解决的问题：手动创建 bean 映射器非常耗时。 但是该库可以自动生成 Bean 映射器类。</p>\n<h2 id=\"简介-MapStruct\"><a href=\"#简介-MapStruct\" class=\"headerlink\" title=\"简介 MapStruct\"></a>简介 MapStruct</h2><p>MapStruct 是一个开源的基于 Java 的代码生成器，用于创建实现 Java Bean 之间转换的扩展映射器。使用 MapStruct，我们只需要创建接口，而该库会通过注解在编译过程中自动创建具体的映射实现，大大减少了通常需要手工编写的样板代码的数量。</p>\n<h2 id=\"MapStruct-依赖\"><a href=\"#MapStruct-依赖\" class=\"headerlink\" title=\"MapStruct 依赖\"></a><strong>MapStruct 依赖</strong></h2><p><strong>如果你使用</strong><code>**Maven**</code><strong>的话，可以通过引入依赖安装</strong><code>**MapStruct**</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mapstruct<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mapstruct<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个依赖项会导入<code>MapStruct</code>的核心注释。由于<code>MapStruct</code>在编译时工作，并且会集成到像<code>Maven</code>和<code>Gradle</code>这样的构建工具上，我们还必须在<build/>标签中添加一个插件<code>maven-compiler-plugin</code>，并在其配置中添加<code>annotationProcessorPaths</code>，该插件会在构建时生成对应的代码。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">annotationProcessorPaths</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">path</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mapstruct<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mapstruct-processor<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">annotationProcessorPaths</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>**[MapStruct](<a href=\"https://link.zhihu.com/?target=https://search.maven.org/classic/#search|ga|1|g%3A&quot;org.mapstruct&quot;\">https://link.zhihu.com/?target=https://search.maven.org/classic/#search|ga|1|g%3A&quot;org.mapstruct&quot;</a> AND a%3A”mapstruct”)<strong>及其</strong>[处理器](<a href=\"https://link.zhihu.com/?target=https://search.maven.org/classic/#search|ga|1|g%3A&quot;org.mapstruct&quot;\">https://link.zhihu.com/?target=https://search.maven.org/classic/#search|ga|1|g%3A&quot;org.mapstruct&quot;</a> AND a%3A”mapstruct-processor”)<strong>的最新稳定版本都可以从</strong><a href=\"https://link.zhihu.com/?target=https://search.maven.org/search?q=g:org.mapstruct\">Maven 中央仓库</a>**中获得。</p>\n<h2 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a><strong>映射</strong></h2><h3 id=\"基本映射\"><a href=\"#基本映射\" class=\"headerlink\" title=\"基本映射\"></a><strong>基本映射</strong></h3><p>我们先从一些基本的映射开始。我们会创建一个<code>Doctor</code>对象和一个<code>DoctorDto</code>。为了方便起见，它们的属性字段都使用相同的名称：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Doctor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DoctorDto</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，为了在这两者之间进行映射，我们要创建一个<code>DoctorMapper</code>接口。对该接口使用<code>@Mapper</code>注解，<code>MapStruct</code>就会知道这是两个类之间的映射器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">DoctorMapper</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">DoctorMapper</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> Mappers.getMapper(DoctorMapper.class);</span><br><span class=\"line\">    DoctorDto <span class=\"title function_\">toDto</span><span class=\"params\">(Doctor doctor)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码中创建了一个<code>DoctorMapper</code>类型的实例<code>INSTANCE</code>，在生成对应的实现代码后，这就是我们调用的“入口”。</p>\n<p>我们在接口中定义了<code>toDto()</code>方法，该方法接收一个<code>Doctor</code>实例为参数，并返回一个<code>DoctorDto</code>实例。这足以让 MapStruct 知道我们想把一个<code>Doctor</code>实例映射到一个<code>DoctorDto</code>实例。</p>\n<p>当我们构建/编译应用程序时，<code>MapStruct</code>注解处理器插件会识别出<code>DoctorMapper</code>接口并为其生成一个实现类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DoctorMapperImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DoctorMapper</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DoctorDto <span class=\"title function_\">toDto</span><span class=\"params\">(Doctor doctor)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( doctor == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">DoctorDtoBuilder</span> <span class=\"variable\">doctorDto</span> <span class=\"operator\">=</span> DoctorDto.builder();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.id(doctor.getId());</span><br><span class=\"line\">        doctorDto.name(doctor.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> doctorDto.build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>DoctorMapperImpl</code>类中包含一个<code>toDto()</code>方法，将我们的<code>Doctor</code>属性值映射到<code>DoctorDto</code>的属性字段中。如果要将<code>Doctor</code>实例映射到一个<code>DoctorDto</code>实例，可以这样写</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">DoctorDto</span> doctorDto = DoctorMapper.INSTANCE.toDto(doctor);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：你可能也注意到了上面实现代码中的<code>DoctorDtoBuilder</code>。因为 builder 代码往往比较长，为了简洁起见，这里省略了 builder 模式的实现代码。如果你的类中包含 Builder，MapStruct 会尝试使用它来创建实例；如果没有的话，MapStruct 将通过<code>new</code>关键字进行实例化。</p>\n<ul>\n<li><h5 id=\"不同字段间映射\"><a href=\"#不同字段间映射\" class=\"headerlink\" title=\"不同字段间映射\"></a><strong>不同字段间映射</strong></h5></li>\n</ul>\n<p>通常，模型和<code>DTO</code>的字段名不会完全相同。由于团队成员各自指定命名，以及针对不同的调用服务，开发者对返回信息的打包方式选择不同，名称可能会有轻微的变化。</p>\n<p><code>MapStruct</code>通过<code>@Mapping</code>注解对这类情况提供了支持。</p>\n<p>我们先更新<code>Doctor</code>类，添加一个属性<code>specialty</code>：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Doctor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String specialty;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>DoctorDto</code>类中添加一个<code>specialization</code>属性：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoctorDto</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String specialization;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们需要让 <code>DoctorMapper</code> 知道这里的不一致。我们可以使用 <code>@Mapping</code> 注解，并设置其内部的 <code>source</code> 和 <code>target</code> 标记分别指向不一致的两个字段。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DoctorMapper</span> </span>&#123;</span><br><span class=\"line\">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.<span class=\"keyword\">class</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"string\">&quot;doctor.specialty&quot;</span>, target = <span class=\"string\">&quot;specialization&quot;</span>)</span></span><br><span class=\"line\">    DoctorDto toDto(Doctor doctor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Mapping</span>`这个注解代码的含义是：`Doctor`中的`specialty`字段对应于`DoctorDto`类的 `specialization</span><br></pre></td></tr></table></figure>\n\n<p>编译之后，会生成如下实现代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DoctorMapperImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DoctorMapper</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DoctorDto <span class=\"title function_\">toDto</span><span class=\"params\">(Doctor doctor)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (doctor == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">DoctorDtoBuilder</span> <span class=\"variable\">doctorDto</span> <span class=\"operator\">=</span> DoctorDto.builder();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.specialization(doctor.getSpecialty());</span><br><span class=\"line\">        doctorDto.id(doctor.getId());</span><br><span class=\"line\">        doctorDto.name(doctor.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> doctorDto.build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h5 id=\"多个源类\"><a href=\"#多个源类\" class=\"headerlink\" title=\"多个源类\"></a><strong>多个源类</strong></h5></li>\n</ul>\n<p>有时，单个类不足以构建<code>DTO</code>，我们可能希望将多个类中的值聚合为一个<code>DTO</code>，供终端用户使用。这也可以通过在<code>@Mapping</code>注解中设置适当的标志来完成。</p>\n<p>我们先新建另一个对象 <code>Education</code>:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Education</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String degreeName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String institute;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer yearOfPassing;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后向 <code>DoctorDto</code>中添加一个新的字段：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoctorDto</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String degree;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String specialization;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，将 <code>DoctorMapper</code> 接口更新为如下代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DoctorMapper</span> </span>&#123;</span><br><span class=\"line\">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.<span class=\"keyword\">class</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"string\">&quot;doctor.specialty&quot;</span>, target = <span class=\"string\">&quot;specialization&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"string\">&quot;education.degreeName&quot;</span>, target = <span class=\"string\">&quot;degree&quot;</span>)</span></span><br><span class=\"line\">    DoctorDto toDto(Doctor doctor, Education education);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们添加了另一个<code>@Mapping</code>注解，并将其<code>source</code>设置为<code>Education</code>类的<code>degreeName</code>，将<code>target</code>设置为<code>DoctorDto</code>类的<code>degree</code>字段。</p>\n<p>如果 <code>Education</code> 类和 <code>Doctor</code> 类包含同名的字段，我们必须让映射器知道使用哪一个，否则它会抛出一个异常。举例来说，如果两个模型都包含一个<code>id</code>字段，我们就要选择将哪个类中的<code>id</code>映射到 DTO 属性中。</p>\n<ul>\n<li><h5 id=\"子对象映射\"><a href=\"#子对象映射\" class=\"headerlink\" title=\"子对象映射\"></a><strong>子对象映射</strong></h5></li>\n</ul>\n<p>多数情况下，POJO 中不会<em>只</em>包含基本数据类型，其中往往会包含其它类。比如说，一个<code>Doctor</code>类中会有多个患者类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Patient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 Doctor 中添加一个患者列表<code>List</code>:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Doctor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String specialty;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Patient&gt; patientList;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>Patient</code>需要转换，为其创建一个对应的 DTO</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PatientDto</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，在 <code>DoctorDto</code> 中新增一个存储 <code>PatientDto</code>的列表：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoctorDto</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String degree;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String specialization;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;PatientDto&gt; patientDtoList;</span><br><span class=\"line\">    <span class=\"comment\">// getters and setters or builder</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在修改 <code>DoctorMapper</code>之前，我们先创建一个支持 <code>Patient</code> 和 <code>PatientDto</code> 转换的映射器接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">PatientMapper</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">PatientMapper</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> Mappers.getMapper(PatientMapper.class);</span><br><span class=\"line\">    PatientDto <span class=\"title function_\">toDto</span><span class=\"params\">(Patient patient)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个基本映射器，只会处理几个基本数据类型。</p>\n<p>然后，我们再来修改 <code>DoctorMapper</code> 处理一下患者列表：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper(uses = &#123;PatientMapper.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DoctorMapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.<span class=\"keyword\">class</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"string\">&quot;doctor.patientList&quot;</span>, target = <span class=\"string\">&quot;patientDtoList&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"string\">&quot;doctor.specialty&quot;</span>, target = <span class=\"string\">&quot;specialization&quot;</span>)</span></span><br><span class=\"line\">    DoctorDto toDto(Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为我们要处理另一个需要映射的类，所以这里设置了<code>@Mapper</code>注解的<code>uses</code>标志，这样现在的 <code>@Mapper</code> 就可以使用另一个 <code>@Mapper</code>映射器。我们这里只加了一个，但你想在这里添加多少 class/mapper 都可以。</p>\n<p>我们已经添加了<code>uses</code>标志，所以在为<code>DoctorMapper</code>接口生成映射器实现时，MapStruct 也会把 <code>Patient</code> 模型转换成 <code>PatientDto</code> ——因为我们已经为这个任务注册了 <code>PatientMapper</code>。</p>\n<p>编译查看最新想实现代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DoctorMapperImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DoctorMapper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> final <span class=\"title class_\">PatientMapper</span> patientMapper = <span class=\"title class_\">Mappers</span>.<span class=\"title function_\">getMapper</span>( <span class=\"title class_\">PatientMapper</span>.<span class=\"property\">class</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title class_\">DoctorDto</span> <span class=\"title function_\">toDto</span>(<span class=\"params\">Doctor doctor</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( doctor == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"title class_\">DoctorDtoBuilder</span> doctorDto = <span class=\"title class_\">DoctorDto</span>.<span class=\"title function_\">builder</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.<span class=\"title function_\">patientDtoList</span>( <span class=\"title function_\">patientListToPatientDtoList</span>(doctor.<span class=\"title function_\">getPatientList</span>()));</span><br><span class=\"line\">        doctorDto.<span class=\"title function_\">specialization</span>( doctor.<span class=\"title function_\">getSpecialty</span>() );</span><br><span class=\"line\">        doctorDto.<span class=\"title function_\">id</span>( doctor.<span class=\"title function_\">getId</span>() );</span><br><span class=\"line\">        doctorDto.<span class=\"title function_\">name</span>( doctor.<span class=\"title function_\">getName</span>() );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> doctorDto.<span class=\"title function_\">build</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title class_\">List</span>&lt;<span class=\"title class_\">PatientDto</span>&gt; <span class=\"title function_\">patientListToPatientDtoList</span>(<span class=\"params\">List&lt;Patient&gt; list</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( list == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"title class_\">List</span>&lt;<span class=\"title class_\">PatientDto</span>&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;<span class=\"title class_\">PatientDto</span>&gt;( list.<span class=\"title function_\">size</span>() );</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"title class_\">Patient</span> patient : list ) &#123;</span><br><span class=\"line\">            list1.<span class=\"title function_\">add</span>( patientMapper.<span class=\"title function_\">toDto</span>( patient ) );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> list1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显然，除了<code>toDto()</code>映射方法外，最终实现中还添加了一个新的映射方法——&gt;<code>patientListToPatientDtoList()</code>。这个方法是在没有显式定义的情况下添加的，只是因为我们把<code>PatientMapper</code>添加到了<code>DoctorMapper</code>中。</p>\n<p>该方法会遍历一个<code>Patient</code>列表，将每个元素转换为<code>PatientDto</code>，并将转换后的对象添加到<code>DoctorDto</code>对象内中的列表中。</p>\n<h3 id=\"更新现有实例\"><a href=\"#更新现有实例\" class=\"headerlink\" title=\"更新现有实例\"></a><strong>更新现有实例</strong></h3><p>有时，我们希望用 DTO 的最新值更新一个模型中的属性，对目标对象(我们的例子中是<code>DoctorDto</code>)使用<code>@MappingTarget</code>注解，就可以更新现有的实例.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class&#125;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)</span><br><span class=\"line\">    void updateModel(DoctorDto doctorDto, @MappingTarget Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重新生成实现代码，就可以得到<code>updateModel()</code>方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void updateModel(DoctorDto doctorDto, Doctor doctor) &#123;</span><br><span class=\"line\">        if (doctorDto == null) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (doctor.getPatientList() != null) &#123;</span><br><span class=\"line\">            List&lt;Patient&gt; list = patientDtoListToPatientList(doctorDto.getPatientDtoList());</span><br><span class=\"line\">            if (list != null) &#123;</span><br><span class=\"line\">                doctor.getPatientList().clear();</span><br><span class=\"line\">                doctor.getPatientList().addAll(list);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                doctor.setPatientList(null);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            List&lt;Patient&gt; list = patientDtoListToPatientList(doctorDto.getPatientDtoList());</span><br><span class=\"line\">            if (list != null) &#123;</span><br><span class=\"line\">                doctor.setPatientList(list);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        doctor.setSpecialty(doctorDto.getSpecialization());</span><br><span class=\"line\">        doctor.setId(doctorDto.getId());</span><br><span class=\"line\">        doctor.setName(doctorDto.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是，由于患者列表是该模型中的子实体，因此患者列表也会进行更新。</p>\n<h3 id=\"数据类型映射\"><a href=\"#数据类型映射\" class=\"headerlink\" title=\"数据类型映射\"></a><strong>数据类型映射</strong></h3><p>MapStruct 支持<code>source</code>和<code>target</code>属性之间的数据类型转换。它还提供了基本类型及其相应的包装类之间的自动转换。</p>\n<p>自动类型转换适用于：</p>\n<ul>\n<li>基本类型及其对应的包装类之间。比如， <code>int</code> 和 <code>Integer</code>， <code>float</code> 和 <code>Float</code>， <code>long</code> 和 <code>Long</code>，<code>boolean</code> 和 <code>Boolean</code> 等。</li>\n<li>任意基本类型与任意包装类之间。如 <code>int</code> 和 <code>long</code>， <code>byte</code> 和 <code>Integer</code> 等。</li>\n<li>所有基本类型及包装类与<code>String</code>之间。如 <code>boolean</code> 和 <code>String</code>， <code>Integer</code> 和 <code>String</code>， <code>float</code> 和 <code>String</code> 等。</li>\n<li>枚举和<code>String</code>之间。</li>\n<li>Java 大数类型(<code>java.math.BigInteger</code>， <code>java.math.BigDecimal</code>) 和 Java 基本类型(包括其包装类)与<code>String</code>之间。</li>\n<li>其它情况详见 **<a href=\"https://link.zhihu.com/?target=https://mapstruct.org/documentation/stable/reference/html/#implicit-type-conversions\">MapStruct 官方文档</a>**。</li>\n</ul>\n<p>因此，在生成映射器代码的过程中，如果源字段和目标字段之间属于上述任何一种情况，则 MapStrcut 会自行处理类型转换。</p>\n<p>我们修改 <code>PatientDto</code> ，新增一个 <code>dateofBirth</code>字段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PatientDto &#123;</span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private LocalDate dateOfBirth;</span><br><span class=\"line\">    // getters and setters or builder</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一方面，加入 <code>Patient</code> 对象中有一个<code>String</code> 类型的 <code>dateOfBirth</code> ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Patient &#123;</span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String dateOfBirth;</span><br><span class=\"line\">    // getters and setters or builder</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在两者之间创建一个映射器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper</span><br><span class=\"line\">public interface PatientMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)</span><br><span class=\"line\">    Patient toModel(PatientDto patientDto);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当对日期进行转换时，我们也可以使用 <code>dateFormat</code> 设置格式声明。生成的实现代码形式大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PatientMapperImpl implements PatientMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Patient toModel(PatientDto patientDto) &#123;</span><br><span class=\"line\">        if (patientDto == null) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PatientBuilder patient = Patient.builder();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (patientDto.getDateOfBirth() != null) &#123;</span><br><span class=\"line\">            patient.dateOfBirth(DateTimeFormatter.ofPattern(&quot;dd/MMM/yyyy&quot;)</span><br><span class=\"line\">                                .format(patientDto.getDateOfBirth()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        patient.id(patientDto.getId());</span><br><span class=\"line\">        patient.name(patientDto.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        return patient.build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这里使用了 <code>dateFormat</code> 声明的日期格式。如果我们没有声明格式的话，MapStruct 会使用 <code>LocalDate</code>的默认格式，大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (patientDto.getDateOfBirth() != null) &#123;</span><br><span class=\"line\">    patient.dateOfBirth(DateTimeFormatter.ISO_LOCAL_DATE</span><br><span class=\"line\">                        .format(patientDto.getDateOfBirth()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h5 id=\"数字格式转换\"><a href=\"#数字格式转换\" class=\"headerlink\" title=\"数字格式转换\"></a><strong>数字格式转换</strong></h5></li>\n</ul>\n<p>上面的例子中可以看到，在进行日期转换的时候，可以通过<code>dateFormat</code>标志指定日期的格式。</p>\n<p>除此之外，对于数字的转换，也可以使用<code>numberFormat</code>指定显示格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 数字格式转换示例</span><br><span class=\"line\">   @Mapping(source = &quot;price&quot;, target = &quot;price&quot;, numberFormat = &quot;$#.00&quot;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"枚举映射\"><a href=\"#枚举映射\" class=\"headerlink\" title=\"枚举映射\"></a><strong>枚举映射</strong></h3><p>枚举映射的工作方式与字段映射相同。MapStruct 会对具有相同名称的枚举进行映射，这一点没有问题。但是，对于具有不同名称的枚举项，我们需要使用<code>@ValueMapping</code>注解。同样，这与普通类型的<code>@Mapping</code>注解也相似。</p>\n<p>我们先创建两个枚举。第一个是 <code>PaymentType</code>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum PaymentType &#123;</span><br><span class=\"line\">    CASH,</span><br><span class=\"line\">    CHEQUE,</span><br><span class=\"line\">    CARD_VISA,</span><br><span class=\"line\">    CARD_MASTER,</span><br><span class=\"line\">    CARD_CREDIT</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如说，这是一个应用内可用的支付方式，现在我们要根据这些选项创建一个更一般、有限的识图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum PaymentTypeView &#123;</span><br><span class=\"line\">    CASH,</span><br><span class=\"line\">    CHEQUE,</span><br><span class=\"line\">    CARD</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们创建这两个<code>enum</code>之间的映射器接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper</span><br><span class=\"line\">public interface PaymentTypeMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    PaymentTypeMapper INSTANCE = Mappers.getMapper(PaymentTypeMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @ValueMappings(&#123;</span><br><span class=\"line\">            @ValueMapping(source = &quot;CARD_VISA&quot;, target = &quot;CARD&quot;),</span><br><span class=\"line\">            @ValueMapping(source = &quot;CARD_MASTER&quot;, target = &quot;CARD&quot;),</span><br><span class=\"line\">            @ValueMapping(source = &quot;CARD_CREDIT&quot;, target = &quot;CARD&quot;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个例子中，我们设置了一般性的<code>CARD</code>值，和更具体的 <code>CARD_VISA</code>, <code>CARD_MASTER</code> 和 <code>CARD_CREDIT</code> 。两个枚举间的枚举项数量不匹配—— <code>PaymentType</code> 有 5 个值，而 <code>PaymentTypeView</code> 只有 3 个。</p>\n<p>为了在这些枚举项之间建立桥梁，我们可以使用<code>@ValueMappings</code>注解，该注解中可以包含多个<code>@ValueMapping</code>注解。这里，我们将<code>source</code>设置为三个具体枚举项之一，并将<code>target</code>设置为<code>CARD</code>。</p>\n<p>MapStruct 自然会处理这些情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PaymentTypeMapperImpl implements PaymentTypeMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType) &#123;</span><br><span class=\"line\">        if (paymentType == null) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PaymentTypeView paymentTypeView;</span><br><span class=\"line\"></span><br><span class=\"line\">        switch (paymentType) &#123;</span><br><span class=\"line\">            case CARD_VISA: paymentTypeView = PaymentTypeView.CARD;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">            case CARD_MASTER: paymentTypeView = PaymentTypeView.CARD;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">            case CARD_CREDIT: paymentTypeView = PaymentTypeView.CARD;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">            case CASH: paymentTypeView = PaymentTypeView.CASH;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">            case CHEQUE: paymentTypeView = PaymentTypeView.CHEQUE;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">            default: throw new IllegalArgumentException( &quot;Unexpected enum constant: &quot; + paymentType );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return paymentTypeView;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>CASH</code>和<code>CHEQUE</code>默认转换为对应值，特殊的 <code>CARD</code> 值通过<code>switch</code>循环处理。</p>\n<p>但是，如果你要将很多值转换为一个更一般的值，这种方式就有些不切实际了。其实我们不必手动分配每一个值，只需要让 MapStruct 将所有剩余的可用枚举项（在目标枚举中找不到相同名称的枚举项），直接转换为对应的另一个枚举项。</p>\n<p>可以通过 <code>MappingConstants</code>实现这一点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ValueMapping(source = MappingConstants.ANY_REMAINING, target = &quot;CARD&quot;)</span><br><span class=\"line\">PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType);</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，完成默认映射之后，所有剩余（未匹配）的枚举项都会映射为<code>CARD</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType) &#123;</span><br><span class=\"line\">    if ( paymentType == null ) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PaymentTypeView paymentTypeView;</span><br><span class=\"line\"></span><br><span class=\"line\">    switch ( paymentType ) &#123;</span><br><span class=\"line\">        case CASH: paymentTypeView = PaymentTypeView.CASH;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">        case CHEQUE: paymentTypeView = PaymentTypeView.CHEQUE;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">        default: paymentTypeView = PaymentTypeView.CARD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return paymentTypeView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有一种选择是使用<code>ANY UNMAPPED</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ValueMapping(source = MappingConstants.ANY_UNMAPPED, target = &quot;CARD&quot;)</span><br><span class=\"line\">PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType);</span><br></pre></td></tr></table></figure>\n\n<p>采用这种方式时，MapStruct 不会像前面那样先处理默认映射，再将剩余的枚举项映射到<code>target</code>值。而是，直接将<em>所有</em>未通过<code>@ValueMapping</code>注解做显式映射的值都转换为<code>target</code>值。</p>\n<h3 id=\"集合映射\"><a href=\"#集合映射\" class=\"headerlink\" title=\"集合映射\"></a><strong>集合映射</strong></h3><p>简单来说，使用 MapStruct 处理集合映射的方式与处理简单类型相同。</p>\n<p>我们创建一个简单的接口或抽象类并声明映射方法。 MapStruct 将根据我们的声明自动生成映射代码。 通常，生成的代码会遍历源集合，将每个元素转换为目标类型，并将每个转换后元素添加到目标集合中。</p>\n<ul>\n<li><h5 id=\"List-映射\"><a href=\"#List-映射\" class=\"headerlink\" title=\"List 映射\"></a><strong>List 映射</strong></h5></li>\n</ul>\n<p>我们先定义一个新的映射方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\">    List&lt;DoctorDto&gt; map(List&lt;Doctor&gt; doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成的代码大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public List&lt;DoctorDto&gt; map(List&lt;Doctor&gt; doctor) &#123;</span><br><span class=\"line\">        if ( doctor == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;DoctorDto&gt; list = new ArrayList&lt;DoctorDto&gt;( doctor.size() );</span><br><span class=\"line\">        for ( Doctor doctor1 : doctor ) &#123;</span><br><span class=\"line\">            list.add( doctorToDoctorDto( doctor1 ) );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected DoctorDto doctorToDoctorDto(Doctor doctor) &#123;</span><br><span class=\"line\">        if ( doctor == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DoctorDto doctorDto = new DoctorDto();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.setId( doctor.getId() );</span><br><span class=\"line\">        doctorDto.setName( doctor.getName() );</span><br><span class=\"line\">        doctorDto.setSpecialization( doctor.getSpecialization() );</span><br><span class=\"line\"></span><br><span class=\"line\">        return doctorDto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，MapStruct 为我们自动生成了从<code>Doctor</code>到<code>DoctorDto</code>的映射方法。</p>\n<p>但是需要注意，如果我们在 DTO 中新增一个字段<code>fullName</code>，生成代码时会出现错误：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">警告: Unmapped target property: &quot;fullName&quot;.</span><br></pre></td></tr></table></figure>\n\n<p>基本上，这意味着 MapStruct 在当前情况下无法为我们自动生成映射方法。因此，我们需要手动定义<code>Doctor</code>和<code>DoctorDto</code>之间的映射方法。具体参考之前的小节。</p>\n<ul>\n<li><h5 id=\"Set-和-Map-映射\"><a href=\"#Set-和-Map-映射\" class=\"headerlink\" title=\"Set 和 Map 映射\"></a><strong>Set 和 Map 映射</strong></h5></li>\n</ul>\n<p>Set 与 Map 型数据的处理方式与 List 相似。按照以下方式修改<code>DoctorMapper</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Set&lt;DoctorDto&gt; setConvert(Set&lt;Doctor&gt; doctor);</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, DoctorDto&gt; mapConvert(Map&lt;String, Doctor&gt; doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成的最终实现代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Set&lt;DoctorDto&gt; setConvert(Set&lt;Doctor&gt; doctor) &#123;</span><br><span class=\"line\">        if ( doctor == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Set&lt;DoctorDto&gt; set = new HashSet&lt;DoctorDto&gt;( Math.max( (int) ( doctor.size() / .75f ) + 1, 16 ) );</span><br><span class=\"line\">        for ( Doctor doctor1 : doctor ) &#123;</span><br><span class=\"line\">            set.add( doctorToDoctorDto( doctor1 ) );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return set;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Map&lt;String, DoctorDto&gt; mapConvert(Map&lt;String, Doctor&gt; doctor) &#123;</span><br><span class=\"line\">        if ( doctor == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;String, DoctorDto&gt; map = new HashMap&lt;String, DoctorDto&gt;( Math.max( (int) ( doctor.size() / .75f ) + 1, 16 ) );</span><br><span class=\"line\"></span><br><span class=\"line\">        for ( java.util.Map.Entry&lt;String, Doctor&gt; entry : doctor.entrySet() ) &#123;</span><br><span class=\"line\">            String key = entry.getKey();</span><br><span class=\"line\">            DoctorDto value = doctorToDoctorDto( entry.getValue() );</span><br><span class=\"line\">            map.put( key, value );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return map;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected DoctorDto doctorToDoctorDto(Doctor doctor) &#123;</span><br><span class=\"line\">        if ( doctor == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DoctorDto doctorDto = new DoctorDto();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.setId( doctor.getId() );</span><br><span class=\"line\">        doctorDto.setName( doctor.getName() );</span><br><span class=\"line\">        doctorDto.setSpecialization( doctor.getSpecialization() );</span><br><span class=\"line\"></span><br><span class=\"line\">        return doctorDto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与 List 映射类似，MapStruct 自动生成了<code>Doctor</code>转换为<code>DoctorDto</code>的映射方法。</p>\n<ul>\n<li><h5 id=\"集合映射策略\"><a href=\"#集合映射策略\" class=\"headerlink\" title=\"集合映射策略\"></a><strong>集合映射策略</strong></h5></li>\n</ul>\n<p>很多场景中，我们需要对具有父子关系的数据类型进行转换。通常来说，会有一个数据类型（父），其字段是另一个数据类型（子）的集合。</p>\n<p>对于这种情况，MapStruct 提供了一种方法来选择如何将子类型设置或添加到父类型中。具体来说，就是<code>@Mapper</code>注解中的<code>collectionMappingStrategy</code>属性，该属性可以取值为<code>ACCESSOR_ONLY</code>， <code>SETTER_PREFERRED</code>， <code>ADDER_PREFERRED</code> 或<code>TARGET_IMMUTABLE</code>。</p>\n<p>这些值分别表示不同的为子类型集合赋值的方式。默认值是<code>ACCESSOR_ONLY</code>，这意味着只能使用访问器来设置子集合。</p>\n<p>当父类型中的<em>Collection</em>字段<code>setter</code>方法不可用，但我们有一个子类型<code>add</code>方法时，这个选项就派上用场了；另一种有用的情况是父类型中的<em>Collection</em>字段是不可变的。</p>\n<p>我们新建一个类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Hospital &#123;</span><br><span class=\"line\">    private List&lt;Doctor&gt; doctors;</span><br><span class=\"line\">    // getters and setters or builder</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时定义一个映射目标 DTO 类，同时定义子类型集合字段的 getter、setter 和 adder：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HospitalDto &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;DoctorDto&gt; doctors;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 子类型集合字段getter</span><br><span class=\"line\">    public List&lt;DoctorDto&gt; getDoctors() &#123;</span><br><span class=\"line\">        return doctors;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  // 子类型集合字段setter</span><br><span class=\"line\">    public void setDoctors(List&lt;DoctorDto&gt; doctors) &#123;</span><br><span class=\"line\">        this.doctors = doctors;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  // 子类型数据adder</span><br><span class=\"line\">    public void addDoctor(DoctorDto doctorDTO) &#123;</span><br><span class=\"line\">        if (doctors == null) &#123;</span><br><span class=\"line\">            doctors = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        doctors.add(doctorDTO);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建对应的映射器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = DoctorMapper.class)</span><br><span class=\"line\">public interface HospitalMapper &#123;</span><br><span class=\"line\">    HospitalMapper INSTANCE = Mappers.getMapper(HospitalMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    HospitalDto toDto(Hospital hospital);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成的最终实现代码为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HospitalMapperImpl implements HospitalMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public HospitalDto toDto(Hospital hospital) &#123;</span><br><span class=\"line\">        if ( hospital == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        HospitalDto hospitalDto = new HospitalDto();</span><br><span class=\"line\"></span><br><span class=\"line\">        hospitalDto.setDoctors( doctorListToDoctorDtoList( hospital.getDoctors() ) );</span><br><span class=\"line\"></span><br><span class=\"line\">        return hospitalDto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在默认情况下采用的策略是<code>ACCESSOR_ONLY</code>，使用 setter 方法<code>setDoctors()</code>向<code>HospitalDto</code>对象中写入列表数据。</p>\n<p>相对的，如果使用 <code>ADDER_PREFERRED</code> 作为映射策略：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(collectionMappingStrategy = CollectionMappingStrategy.ADDER_PREFERRED,</span><br><span class=\"line\">        uses = DoctorMapper.class)</span><br><span class=\"line\">public interface HospitalMapper &#123;</span><br><span class=\"line\">    HospitalMapper INSTANCE = Mappers.getMapper(HospitalMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    HospitalDto toDto(Hospital hospital);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时，会使用 adder 方法逐个将转换后的子类型 DTO 对象加入父类型的集合字段中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CompanyMapperAdderPreferredImpl implements CompanyMapperAdderPreferred &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final EmployeeMapper employeeMapper = Mappers.getMapper( EmployeeMapper.class );</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public CompanyDTO map(Company company) &#123;</span><br><span class=\"line\">        if ( company == null ) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        CompanyDTO companyDTO = new CompanyDTO();</span><br><span class=\"line\"></span><br><span class=\"line\">        if ( company.getEmployees() != null ) &#123;</span><br><span class=\"line\">            for ( Employee employee : company.getEmployees() ) &#123;</span><br><span class=\"line\">                companyDTO.addEmployee( employeeMapper.map( employee ) );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return companyDTO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果目标 DTO 中既没有<code>setter</code>方法也没有<code>adder</code>方法，会先通过<code>getter</code>方法获取子类型集合，再调用集合的对应接口添加子类型对象。</p>\n<p>可以在**<a href=\"https://link.zhihu.com/?target=https://mapstruct.org/documentation/stable/reference/html/#collection-mapping-strategies\">参考文档</a>**中看到不同类型的 DTO 定义（是否包含 setter 方法或 adder 方法），采用不同的映射策略时，所使用的添加子类型到集合中的方式。</p>\n<ul>\n<li><h5 id=\"目标集合实现类型\"><a href=\"#目标集合实现类型\" class=\"headerlink\" title=\"目标集合实现类型\"></a><strong>目标集合实现类型</strong></h5></li>\n</ul>\n<p>MapStruct 支持将集合接口作为映射方法的目标类型。</p>\n<p>在这种情况下，在生成的代码中会使用一些集合接口默认实现。 例如，上面的示例中，<code>List</code>的默认实现是<code>ArrayList</code>。</p>\n<p>常见接口及其对应的默认实现如下：</p>\n<p>无法复制加载中的内容</p>\n<p>你可以在**<a href=\"https://link.zhihu.com/?target=https://mapstruct.org/documentation/stable/reference/html/#implementation-types-for-collection-mappings\">参考文档</a>**中找到 MapStruct 支持的所有接口列表，以及每个接口对应的默认实现类型。</p>\n<h2 id=\"进阶操作\"><a href=\"#进阶操作\" class=\"headerlink\" title=\"进阶操作\"></a><strong>进阶操作</strong></h2><h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a><strong>依赖注入</strong></h3><p>到目前为止，我们一直在通过<code>getMapper()</code>方法访问生成的映射器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果你使用的是 Spring，只需要简单修改映射器配置，就可以像常规依赖项一样注入映射器。</p>\n<p>修改 <code>DoctorMapper</code> 以支持 Spring 框架：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public interface DoctorMapper &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>@Mapper</code>注解中添加<code>（componentModel = &quot;spring&quot;）</code>，是为了告诉 MapStruct，在生成映射器实现类时，我们希望它能支持通过 Spring 的依赖注入来创建。现在，就不需要在接口中添加 <code>INSTANCE</code> 字段了。</p>\n<p>这次生成的 <code>DoctorMapperImpl</code> 会带有 <code>@Component</code> 注解：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class DoctorMapperImpl implements DoctorMapper &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只要被标记为<code>@Component</code>，Spring 就可以把它作为一个 bean 来处理，你就可以在其它类（如控制器）中通过<code>@Autowire</code>注解来使用它：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class DoctorController() &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private DoctorMapper doctorMapper;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你不使用 Spring, MapStruct 也支持**<a href=\"https://link.zhihu.com/?target=https://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html\">Java CDI</a>**：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(componentModel = &quot;cdi&quot;)</span><br><span class=\"line\">public interface DoctorMapper &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加默认值\"><a href=\"#添加默认值\" class=\"headerlink\" title=\"添加默认值\"></a><strong>添加默认值</strong></h3><p><code>@Mapping</code> 注解有两个很实用的标志就是常量 <code>constant</code> 和默认值 <code>defaultValue</code> 。无论<code>source</code>如何取值，都将始终使用常量值； 如果<code>source</code>取值为<code>null</code>，则会使用默认值。</p>\n<p>修改一下 <code>DoctorMapper</code> ，添加一个 <code>constant</code> 和一个 <code>defaultValue</code> ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class&#125;, componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\">    @Mapping(target = &quot;id&quot;, constant = &quot;-1&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;, defaultValue = &quot;Information Not Available&quot;)</span><br><span class=\"line\">    DoctorDto toDto(Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>specialty</code>不可用，我们会替换为<code>&quot;Information Not Available&quot;</code>字符串，此外，我们将<code>id</code>硬编码为<code>-1</code>。</p>\n<p>生成代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private PatientMapper patientMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public DoctorDto toDto(Doctor doctor) &#123;</span><br><span class=\"line\">        if (doctor == null) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DoctorDto doctorDto = new DoctorDto();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (doctor.getSpecialty() != null) &#123;</span><br><span class=\"line\">            doctorDto.setSpecialization(doctor.getSpecialty());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            doctorDto.setSpecialization(&quot;Information Not Available&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        doctorDto.setPatientDtoList(patientListToPatientDtoList(doctor.getPatientList()));</span><br><span class=\"line\">        doctorDto.setName(doctor.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.setId(-1);</span><br><span class=\"line\"></span><br><span class=\"line\">        return doctorDto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，如果 <code>doctor.getSpecialty()</code> 返回值为<code>null</code>，则将<code>specialization</code>设置为我们的默认信息。无论任何情况，都会对 <code>id</code>赋值，因为这是一个<code>constant</code>。</p>\n<h3 id=\"添加表达式\"><a href=\"#添加表达式\" class=\"headerlink\" title=\"添加表达式\"></a><strong>添加表达式</strong></h3><p>MapStruct 甚至允许在<code>@Mapping</code>注解中输入 Java 表达式。你可以设置 <code>defaultExpression</code> （ <code>source</code> 取值为 <code>null</code>时生效），或者一个<code>expression</code>（类似常量，永久生效）。</p>\n<p>在 <code>Doctor</code> 和 <code>DoctorDto</code>两个类中都加了两个新属性，一个是 <code>String</code> 类型的 <code>externalId</code> ，另一个是<code>LocalDateTime</code>类型的 <code>appointment</code> ，两个类大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Doctor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String externalId;</span><br><span class=\"line\">    private String specialty;</span><br><span class=\"line\">    private LocalDateTime availability;</span><br><span class=\"line\">    private List&lt;Patient&gt; patientList;</span><br><span class=\"line\">    // getters and setters or builder</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class DoctorDto &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String externalId;</span><br><span class=\"line\">    private String specialization;</span><br><span class=\"line\">    private LocalDateTime availability;</span><br><span class=\"line\">    private List&lt;PatientDto&gt; patientDtoList;</span><br><span class=\"line\">    // getters and setters or builder</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改 <code>DoctorMapper</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class&#125;, componentModel = &quot;spring&quot;, imports = &#123;LocalDateTime.class, UUID.class&#125;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(target = &quot;externalId&quot;, expression = &quot;java(UUID.randomUUID().toString())&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.availability&quot;, target = &quot;availability&quot;, defaultExpression = &quot;java(LocalDateTime.now())&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)</span><br><span class=\"line\">    DoctorDto toDtoWithExpression(Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这里将 <code>externalId</code>的值设置为 <code>java(UUID.randomUUID().toString())</code> ，如果源对象中没有 <code>availability</code> 属性，则会把目标对象中的 <code>availability</code> 设置为一个新的 <code>LocalDateTime</code>对象。</p>\n<p>由于表达式只是字符串，我们必须在表达式中指定使用的类。但是这里的表达式并不是最终执行的代码，只是一个字母的文本值。因此，我们要在 <code>@Mapper</code> 中添加 <code>imports = &#123;LocalDateTime.class, UUID.class&#125;</code> 。</p>\n<h3 id=\"添加自定义方法\"><a href=\"#添加自定义方法\" class=\"headerlink\" title=\"添加自定义方法\"></a><strong>添加自定义方法</strong></h3><p>到目前为止，我们一直使用的策略是添加一个“占位符”方法，并期望 MapStruct 能为我们实现它。其实我们还可以向接口中添加自定义的<code>default</code>方法，也可以通过<code>default</code>方法直接实现一个映射。然后我们可以通过实例直接调用该方法，没有任何问题。</p>\n<p>为此，我们创建一个 <code>DoctorPatientSummary</code>类，其中包含一个 <code>Doctor</code> 及其 <code>Patient</code>列表的汇总信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DoctorPatientSummary &#123;</span><br><span class=\"line\">    private int doctorId;</span><br><span class=\"line\">    private int patientCount;</span><br><span class=\"line\">    private String doctorName;</span><br><span class=\"line\">    private String specialization;</span><br><span class=\"line\">    private String institute;</span><br><span class=\"line\">    private List&lt;Integer&gt; patientIds;</span><br><span class=\"line\">    // getters and setters or builder</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们在 <code>DoctorMapper</code>中添加一个<code>default</code>方法，该方法会将 <code>Doctor</code> 和 <code>Education</code> 对象转换为一个 <code>DoctorPatientSummary</code>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    default DoctorPatientSummary toDoctorPatientSummary(Doctor doctor, Education education) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return DoctorPatientSummary.builder()</span><br><span class=\"line\">                .doctorId(doctor.getId())</span><br><span class=\"line\">                .doctorName(doctor.getName())</span><br><span class=\"line\">                .patientCount(doctor.getPatientList().size())</span><br><span class=\"line\">        .patientIds(doctor.getPatientList()</span><br><span class=\"line\">                     .stream()</span><br><span class=\"line\">                      .map(Patient::getId)</span><br><span class=\"line\">                     .collect(Collectors.toList()))</span><br><span class=\"line\">              .institute(education.getInstitute())</span><br><span class=\"line\">                .specialization(education.getDegreeName())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里使用了 Builder 模式创建<code>DoctorPatientSummary</code>对象。</p>\n<p>在 MapStruct 生成映射器实现类之后，你就可以使用这个实现方法，就像访问任何其它映射器方法一样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DoctorPatientSummary summary = doctorMapper.toDoctorPatientSummary(dotor, education);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建自定义映射器\"><a href=\"#创建自定义映射器\" class=\"headerlink\" title=\"创建自定义映射器\"></a><strong>创建自定义映射器</strong></h3><p>前面我们一直是通过接口来设计映射器功能，其实我们也可以通过一个带 <code>@Mapper</code> 的 <code>abstract</code> 类来实现一个映射器。MapStruct 也会为这个类创建一个实现，类似于创建一个接口实现。</p>\n<p>我们重写一下前面的示例，这一次，我们将它修改为一个抽象类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper</span><br><span class=\"line\">public abstract class DoctorCustomMapper &#123;</span><br><span class=\"line\">    public DoctorPatientSummary toDoctorPatientSummary(Doctor doctor, Education education) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return DoctorPatientSummary.builder()</span><br><span class=\"line\">                .doctorId(doctor.getId())</span><br><span class=\"line\">                .doctorName(doctor.getName())</span><br><span class=\"line\">                .patientCount(doctor.getPatientList().size())</span><br><span class=\"line\">                .patientIds(doctor.getPatientList()</span><br><span class=\"line\">                        .stream()</span><br><span class=\"line\">                        .map(Patient::getId)</span><br><span class=\"line\">                        .collect(Collectors.toList()))</span><br><span class=\"line\">                .institute(education.getInstitute())</span><br><span class=\"line\">                .specialization(education.getDegreeName())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以用同样的方式使用这个映射器。由于限制较少，使用抽象类可以在创建自定义实现时给我们更多的控制和选择。另一个好处是可以添加<code>@BeforeMapping</code>和<code>@AfterMapping</code>方法。</p>\n<h3 id=\"BeforeMapping-和-AfterMapping\"><a href=\"#BeforeMapping-和-AfterMapping\" class=\"headerlink\" title=\"@BeforeMapping 和 @AfterMapping\"></a><strong>@BeforeMapping 和 @AfterMapping</strong></h3><p>为了进一步控制和定制化，我们可以定义 <code>@BeforeMapping</code> 和 <code>@AfterMapping</code>方法。显然，这两个方法是在每次映射之前和之后执行的。也就是说，在最终的实现代码中，会在两个对象真正映射之前和之后添加并执行这两个方法。</p>\n<p>可以在 <code>DoctorCustomMapper</code>中添加两个方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class&#125;, componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public abstract class DoctorCustomMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @BeforeMapping</span><br><span class=\"line\">    protected void validate(Doctor doctor) &#123;</span><br><span class=\"line\">        if(doctor.getPatientList() == null)&#123;</span><br><span class=\"line\">            doctor.setPatientList(new ArrayList&lt;&gt;());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @AfterMapping</span><br><span class=\"line\">    protected void updateResult(@MappingTarget DoctorDto doctorDto) &#123;</span><br><span class=\"line\">        doctorDto.setName(doctorDto.getName().toUpperCase());</span><br><span class=\"line\">        doctorDto.setDegree(doctorDto.getDegree().toUpperCase());</span><br><span class=\"line\">        doctorDto.setSpecialization(doctorDto.getSpecialization().toUpperCase());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)</span><br><span class=\"line\">    public abstract DoctorDto toDoctorDto(Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基于该抽象类生成一个映射器实现类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class DoctorCustomMapperImpl extends DoctorCustomMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private PatientMapper patientMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public DoctorDto toDoctorDto(Doctor doctor) &#123;</span><br><span class=\"line\">        validate(doctor);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (doctor == null) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DoctorDto doctorDto = new DoctorDto();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.setPatientDtoList(patientListToPatientDtoList(doctor</span><br><span class=\"line\">            .getPatientList()));</span><br><span class=\"line\">        doctorDto.setSpecialization(doctor.getSpecialty());</span><br><span class=\"line\">        doctorDto.setId(doctor.getId());</span><br><span class=\"line\">        doctorDto.setName(doctor.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        updateResult(doctorDto);</span><br><span class=\"line\"></span><br><span class=\"line\">        return doctorDto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到， <code>validate()</code> 方法会在 <code>DoctorDto</code> 对象实例化之前执行，而<code>updateResult()</code>方法会在映射结束之后执行。</p>\n<h3 id=\"映射异常处理\"><a href=\"#映射异常处理\" class=\"headerlink\" title=\"映射异常处理\"></a><strong>映射异常处理</strong></h3><p>异常处理是不可避免的，应用程序随时会产生异常状态。MapStruct 提供了对异常处理的支持，可以简化开发者的工作。</p>\n<p>考虑这样一个场景，我们想在 <code>Doctor</code> 映射为<code>DoctorDto</code>之前校验一下 <code>Doctor</code> 的数据。我们新建一个独立的 <code>Validator</code> 类进行校验：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Validator &#123;</span><br><span class=\"line\">    public int validateId(int id) throws ValidationException &#123;</span><br><span class=\"line\">        if(id == -1)&#123;</span><br><span class=\"line\">            throw new ValidationException(&quot;Invalid value in ID&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们修改一下 <code>DoctorMapper</code> 以使用 <code>Validator</code> 类，无需指定实现。跟之前一样， 在<code>@Mapper</code>使用的类列表中添加该类。我们还需要做的就是告诉 MapStruct 我们的 <code>toDto()</code> 会抛出 <code>throws ValidationException</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class, Validator.class&#125;, componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)</span><br><span class=\"line\">    DoctorDto toDto(Doctor doctor) throws ValidationException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终生成的映射器代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class DoctorMapperImpl implements DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private PatientMapper patientMapper;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private Validator validator;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public DoctorDto toDto(Doctor doctor) throws ValidationException &#123;</span><br><span class=\"line\">        if (doctor == null) &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DoctorDto doctorDto = new DoctorDto();</span><br><span class=\"line\"></span><br><span class=\"line\">        doctorDto.setPatientDtoList(patientListToPatientDtoList(doctor</span><br><span class=\"line\">            .getPatientList()));</span><br><span class=\"line\">        doctorDto.setSpecialization(doctor.getSpecialty());</span><br><span class=\"line\">        doctorDto.setId(validator.validateId(doctor.getId()));</span><br><span class=\"line\">        doctorDto.setName(doctor.getName());</span><br><span class=\"line\">        doctorDto.setExternalId(doctor.getExternalId());</span><br><span class=\"line\">        doctorDto.setAvailability(doctor.getAvailability());</span><br><span class=\"line\"></span><br><span class=\"line\">        return doctorDto;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>MapStruct 自动将<code>doctorDto</code>的<code>id</code>设置为<code>Validator</code>实例的方法返回值。它还在该方法签名中添加了一个 throws 子句。</p>\n<p>注意，如果映射前后的一对属性的类型与<code>Validator</code>中的方法出入参类型一致，那该字段映射时就会调用<code>Validator</code>中的方法，所以该方式请谨慎使用。</p>\n<h3 id=\"映射配置\"><a href=\"#映射配置\" class=\"headerlink\" title=\"映射配置\"></a><strong>映射配置</strong></h3><p>MapStruct 为编写映射器方法提供了一些非常有用的配置。多数情况下，如果我们已经定义了两个类型之间的映射方法，当我们要添加相同类型之间的另一个映射方法时，我们往往会直接复制已有方法的映射配置。</p>\n<p>其实我们不必手动复制这些注解，只需要简单的配置就可以创建一个相同/相似的映射方法。</p>\n<h5 id=\"继承配置\"><a href=\"#继承配置\" class=\"headerlink\" title=\"继承配置\"></a><strong>继承配置</strong></h5><p>我们回顾一下“**<a href=\"https://zhuanlan.zhihu.com/p/368731266/edit#%E6%9B%B4%E6%96%B0%E7%8E%B0%E6%9C%89%E5%AE%9E%E4%BE%8B\">更新现有实例</a>**”，在该场景中，我们创建了一个映射器，根据 DoctorDto 对象的属性更新现有的 Doctor 对象的属性值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class&#125;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)</span><br><span class=\"line\">    void updateModel(DoctorDto doctorDto, @MappingTarget Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设我们还有另一个映射器，将 <code>DoctorDto</code>转换为 <code>Doctor</code> ：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class, Validator.class&#125;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)</span><br><span class=\"line\">    Doctor toModel(DoctorDto doctorDto);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个映射方法使用了相同的注解配置， <code>source</code>和 <code>target</code>都是相同的。其实我们可以使用<code>@InheritConfiguration</code>注释，从而避免这两个映射器方法的重复配置。</p>\n<p>如果对一个方法添加 <code>@InheritConfiguration</code> 注解，MapStruct 会检索其它的已配置方法，寻找可用于当前方法的注解配置。一般来说，这个注解都用于<code>mapping</code>方法后面的<code>update</code>方法，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(uses = &#123;PatientMapper.class, Validator.class&#125;, componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public interface DoctorMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)</span><br><span class=\"line\">    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)</span><br><span class=\"line\">    Doctor toModel(DoctorDto doctorDto);</span><br><span class=\"line\"></span><br><span class=\"line\">    @InheritConfiguration</span><br><span class=\"line\">    void updateModel(DoctorDto doctorDto, @MappingTarget Doctor doctor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"继承逆向配置\"><a href=\"#继承逆向配置\" class=\"headerlink\" title=\"继承逆向配置\"></a><strong>继承逆向配置</strong></h5><p>还有另外一个类似的场景，就是编写映射函数将**<em>Model</em>** 转为 **<em>DTO</em>**，以及将 <strong><em>DTO</em></strong> 转为 **<em>Model</em>**。如下面的代码所示，我们必须在两个函数上添加相同的注释。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public interface PatientMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)</span><br><span class=\"line\">    Patient toModel(PatientDto patientDto);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)</span><br><span class=\"line\">    PatientDto toDto(Patient patient);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两个方法的配置不会是完全相同的，实际上，它们应该是相反的。将 <strong>Model</strong> 转为 **<em>DTO</em>**，以及将 <strong><em>DTO</em></strong> 转为 **<em>Model</em>**——映射前后的字段相同，但是源属性字段与目标属性字段是相反的。</p>\n<p>我们可以在第二个方法上使用<code>@InheritInverseConfiguration</code>注解，避免写两遍映射配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Mapper(componentModel = &quot;spring&quot;)</span><br><span class=\"line\">public interface PatientMapper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)</span><br><span class=\"line\">    Patient toModel(PatientDto patientDto);</span><br><span class=\"line\"></span><br><span class=\"line\">    @InheritInverseConfiguration</span><br><span class=\"line\">    PatientDto toDto(Patient patient);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个 Mapper 生成的代码是相同的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>在本文中，我们探讨了 MapStruct——一个用于创建映射器类的库。从基本映射到自定义方法和自定义映射器，此外， 我们还介绍了 MapStruct 提供的一些高级操作选项，包括依赖注入，数据类型映射、枚举映射和表达式使用。</p>\n<p>MapStruct 提供了一个功能强大的集成插件，可减少开发人员编写模板代码的工作量，使创建映射器的过程变得简单快捷。</p>\n","categories":[{"name":"后端开发","path":"api/categories/后端开发.json"}],"tags":[{"name":"技巧","path":"api/tags/技巧.json"},{"name":"开发工具","path":"api/tags/开发工具.json"}]}