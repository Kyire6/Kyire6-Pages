{"title":"Java8 新特性","slug":"Java8新特性","date":"2021-06-17T08:25:44.000Z","updated":"2021-06-17T08:26:26.000Z","comments":true,"path":"api/articles/Java8新特性.json","excerpt":null,"covers":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Java8 有一个非常显著的特点，就是提供了函数式编程，本文也将介绍 Java8 的几个新特性来实现函数式编程。学会这些 API 能够编写出简单、干净、易读的代码（尤其是对集合的操作）。Java8 新特性包括：</p>\n<ul>\n<li>Lambda 表达式</li>\n<li>Stream API</li>\n<li>接口新特性<ul>\n<li>函数式接口（<code>@FunctionalInterface</code>）</li>\n<li>默认方法（<code>default</code>）</li>\n</ul>\n</li>\n<li>Optional API</li>\n<li>方法引用</li>\n</ul>\n<p>JDK8 新特性</p>\n<p>正在努力更新中…</p>\n<h2 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h2><ul>\n<li>只包含了一个抽象方法的接口，称为函数式接口（可以有多个非抽象方法）。可以使用<code>@FunctionalInterface</code>注解自定义声明</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//JDK 1.8 之前已有的函数式接口:</span></span><br><span class=\"line\">- java.lang.Runnable</span><br><span class=\"line\">- java.util.concurrent.Callable</span><br><span class=\"line\">- java.security.PrivilegedAction</span><br><span class=\"line\">- java.util.Comparator</span><br><span class=\"line\">- java.io.FileFilter</span><br><span class=\"line\">- java.nio.file.PathMatcher</span><br><span class=\"line\">- java.lang.reflect.InvocationHandler</span><br><span class=\"line\">- java.beans.PropertyChangeListener</span><br><span class=\"line\">- java.awt.event.ActionListener</span><br><span class=\"line\">- javax.swing.event.ChangeListener</span><br><span class=\"line\"><span class=\"comment\">//JDK 1.8 新增加的函数接口：</span></span><br><span class=\"line\">- java.util.function</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lambda-表达式\"><a href=\"#Lambda-表达式\" class=\"headerlink\" title=\"Lambda 表达式\"></a>Lambda 表达式</h2><ul>\n<li><code>Lambda</code>表达式的使用依赖于函数式接口</li>\n<li>使用<code>Lambda</code>表达式来表示函数式接口的实现（JAVA 8 之前一般是用匿名类实现的）</li>\n</ul>\n<h3 id=\"语法格式\"><a href=\"#语法格式\" class=\"headerlink\" title=\"语法格式\"></a>语法格式</h3><ul>\n<li><code>-&gt; :Lambda操作符</code></li>\n<li><code>-&gt; 左边(parameters):Lambda形参列表</code>(相当于接口中的抽象方法的形参列表)</li>\n</ul>\n<ol>\n<li>参数类型可以省略，可由编译器推断得出(类型推断)</li>\n<li>如果只有一个参数,<code>()</code>也可以省略</li>\n</ol>\n<ul>\n<li><code>-&gt; 右边:Lambda体</code>(重写的抽象方法的方法体)</li>\n</ul>\n<ol>\n<li>如果只有一条执行语句，<code>&#123;&#125;</code>及<code>return</code>可以省略</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(parameters) -&gt; expression</span><br><span class=\"line\">或</span><br><span class=\"line\">(parameters) -&gt;&#123; statements; &#125;</span><br><span class=\"line\"><span class=\"comment\">// 1. 接收2个int型整数,返回他们的和</span></span><br><span class=\"line\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) -&gt; x + y</span><br><span class=\"line\"><span class=\"comment\">// 2. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)</span></span><br><span class=\"line\">(String s) -&gt; System.out.print(s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    Runnable runnable=<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;*********&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    runnable.run();</span><br><span class=\"line\">    <span class=\"comment\">//Lambda表达式写法</span></span><br><span class=\"line\">    Runnable runnable= () -&gt; System.out.println(<span class=\"string\">&quot;*********&quot;</span>);</span><br><span class=\"line\">    runnable.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h4><table>\n<thead>\n<tr>\n<th>使用案例</th>\n<th>Lambda 的例子</th>\n<th>对应的函数式接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>布尔表达式</td>\n<td><code>(List&lt;String&gt; list) -&gt; list.isEmpty()</code></td>\n<td><code>Predicate&lt;List&lt;String&gt;&gt;</code></td>\n</tr>\n<tr>\n<td>创建对象</td>\n<td><code>() -&gt; new Project()</code></td>\n<td><code>Supplier&lt;Project&gt;</code></td>\n</tr>\n<tr>\n<td>消费一个对象</td>\n<td><code>(Project p) -&gt; System.out.println(p.getStars())</code></td>\n<td><code>Consumer&lt;Project&gt;</code></td>\n</tr>\n<tr>\n<td>从一个对象中选择/提取</td>\n<td><code>(int a, int b) -&gt; a * b</code></td>\n<td><code>IntBinaryOperator</code></td>\n</tr>\n<tr>\n<td>比较两个对象</td>\n<td><code>(Project p1, Project p2) -&gt; p1.getStars().compareTo(p2.getStars())</code></td>\n<td><code>Comparator&lt;Project&gt; 或 BiFunction&lt;Project,</code> <code>Project, Integer&gt; 或 ToIntBiFunction&lt;Project, Project&gt;</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h3><h4 id=\"语法格式-1\"><a href=\"#语法格式-1\" class=\"headerlink\" title=\"语法格式\"></a>语法格式</h4><ul>\n<li>使用操作符<code>::</code>类或对象与方法名分割</li>\n<li>主要有三种使用情况</li>\n</ul>\n<p> 对象<code>::</code>实例方法名</p>\n<p>类<code>::</code>实例方法名</p>\n<p>类<code>::</code>静态方法名</p>\n<h4 id=\"使用案例-1\"><a href=\"#使用案例-1\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LambdaQueryWrapper&lt;SysDictItem&gt; queryWrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">LambdaQueryWrapper</span>&lt;SysDictItem&gt;();</span><br><span class=\"line\"><span class=\"comment\">//相当于SysDictItem.getStatus();</span></span><br><span class=\"line\">queryWrapper.eq(SysDictItem::getStatus, <span class=\"number\">1</span>);</span><br><span class=\"line\">queryWrapper.orderByAsc(SysDictItem::getSortOrder);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Stream-API\"><a href=\"#Stream-API\" class=\"headerlink\" title=\"Stream API\"></a>Stream API</h2><ul>\n<li>使用<code>Stream API</code>对集合数据进行操作</li>\n<li><code>stream</code> 和 <code>collection</code> 集合的区别<ul>\n<li><code>collection</code>是一种静态的内存数据结构，而<code>stream</code>是有关计算的，前者主要面向内存，存储在内存中，后者主要面向<code>cpu</code>，通过<code>cpu</code>计算实现</li>\n</ul>\n</li>\n<li><code>Stream</code>的创建方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.通过集合创建</span></span><br><span class=\"line\"><span class=\"comment\">//default Stream&lt;E&gt; stream();//返回一个顺序流</span></span><br><span class=\"line\"><span class=\"comment\">//default Stream&lt;E&gt; parallelStream();//返回一个并行流</span></span><br><span class=\"line\">List&lt;Person&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Person&gt;();</span><br><span class=\"line\">Stream&lt;Person&gt; stream = list.stream();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.通过Arrays静态方法</span></span><br><span class=\"line\">String[] names = &#123;<span class=\"string\">&quot;chaimm&quot;</span>,<span class=\"string\">&quot;peter&quot;</span>,<span class=\"string\">&quot;john&quot;</span>&#125;;</span><br><span class=\"line\">Stream&lt;String&gt; stream = Arrays.stream(names);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3.通过Stream of</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;chaimm&quot;</span>,<span class=\"string\">&quot;peter&quot;</span>,<span class=\"string\">&quot;john&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4.创建无限流</span></span><br><span class=\"line\"><span class=\"comment\">//迭代 遍历0到9</span></span><br><span class=\"line\">Stream.iterate(<span class=\"number\">0</span>,t-&gt;t+<span class=\"number\">1</span>).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//生成 10个随机数</span></span><br><span class=\"line\">Stream.generate(Math::random).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>中间操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//中间操作</span></span><br><span class=\"line\"><span class=\"comment\">//filer(Predicate p)过滤数据</span></span><br><span class=\"line\">List&lt;Person&gt; result = list.stream()</span><br><span class=\"line\">    .filter(Person::isStudent)</span><br><span class=\"line\">    .collect(toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//limit(n)截断流</span></span><br><span class=\"line\">List&lt;Person&gt; result = list.stream()</span><br><span class=\"line\">    .limit(<span class=\"number\">3</span>)</span><br><span class=\"line\">    .collect(toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//skip(n)跳过元素</span></span><br><span class=\"line\">List&lt;Person&gt; result = list.stream()</span><br><span class=\"line\">    .skip(<span class=\"number\">3</span>)</span><br><span class=\"line\">    .collect(toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//distinct 筛选去重</span></span><br><span class=\"line\">List&lt;Person&gt; result = list.stream()</span><br><span class=\"line\">    .distinct()</span><br><span class=\"line\">    .collect(toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//映射map(Function f)  flatMap(Function f)合并多个流</span></span><br><span class=\"line\">List&lt;String&gt; result = list.stream()</span><br><span class=\"line\">    .map(Person::getName)</span><br><span class=\"line\">    .collect(toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//排序 sorted() 自然排序 sorted(Comparator c)定制顺序</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>终止操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">//终止操作</span></span><br><span class=\"line\"><span class=\"comment\">//匹配与查找</span></span><br><span class=\"line\"><span class=\"comment\">//allMatch(Predicate e)检查是否匹配所有元素 返回boolean</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> list.stream()</span><br><span class=\"line\">    .allMatch(Person::isStudent);</span><br><span class=\"line\"><span class=\"comment\">//anyMatch(Predicate e)检查是否至少匹配一个元素</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> list.stream()</span><br><span class=\"line\">    .anyMatch(Person::isStudent);</span><br><span class=\"line\"><span class=\"comment\">//noneMatch(Predicate e)检查是否没有匹配的元素</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> list.stream()</span><br><span class=\"line\">    .noneMatch(Person::isStudent);</span><br><span class=\"line\"><span class=\"comment\">//findFierst()返回第一个元素</span></span><br><span class=\"line\">Optional&lt;Person&gt; person = list.stream().findFirst();</span><br><span class=\"line\"><span class=\"comment\">//findAny()返回当前流中的任意元素</span></span><br><span class=\"line\">Optional&lt;Person&gt; person = list.stream().findAny();</span><br><span class=\"line\"><span class=\"comment\">//count 返回流中元素的总个数</span></span><br><span class=\"line\"><span class=\"comment\">//max(Comparator c)返回流中最大值</span></span><br><span class=\"line\"><span class=\"comment\">//min(Comparator c)返回流中最小值</span></span><br><span class=\"line\"><span class=\"comment\">//forEach(Consumer c)内部迭代</span></span><br><span class=\"line\"><span class=\"comment\">//归约 reduce(T identity,BinaryOperator)可以将流中元素结合起来得到一个值（求和）</span></span><br><span class=\"line\"><span class=\"comment\">//例：计算所有人的年龄总和</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> list.stream().reduce(<span class=\"number\">0</span>, (person1,person2)-&gt;person1.getAge()+person2.getAge());</span><br><span class=\"line\"><span class=\"comment\">//收集collect(Collector c) 将流中元素收集返回相应类型</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"中间操作和收集操作\"><a href=\"#中间操作和收集操作\" class=\"headerlink\" title=\"中间操作和收集操作\"></a>中间操作和收集操作</h4><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>类型</th>\n<th>返回类型</th>\n<th>使用的类型/函数式接口</th>\n<th>函数描述符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>filter</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><code>T -&gt; boolean</code></td>\n</tr>\n<tr>\n<td><code>distinct</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>skip</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td><code>long</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>map</code></td>\n<td>中间</td>\n<td><code>Stream&lt;R&gt;</code></td>\n<td><code>Function&lt;T, R&gt;</code></td>\n<td><code>T -&gt; R</code></td>\n</tr>\n<tr>\n<td><code>flatMap</code></td>\n<td>中间</td>\n<td><code>Stream&lt;R&gt;</code></td>\n<td><code>Function&lt;T,Stream&lt;R&gt;&gt;</code></td>\n<td><code>T -&gt; Stream&lt;R&gt;</code></td>\n</tr>\n<tr>\n<td><code>limit</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td><code>long</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>sorted</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td><code>Comparator&lt;T&gt;</code></td>\n<td><code>(T, T) -&gt; int</code></td>\n</tr>\n<tr>\n<td><code>anyMatch</code></td>\n<td>终端</td>\n<td><code>boolean</code></td>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><code>T -&gt; boolean</code></td>\n</tr>\n<tr>\n<td><code>noneMatch</code></td>\n<td>终端</td>\n<td><code>boolean</code></td>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><code>T -&gt; boolean</code></td>\n</tr>\n<tr>\n<td><code>allMatch</code></td>\n<td>终端</td>\n<td><code>boolean</code></td>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><code>T -&gt; boolean</code></td>\n</tr>\n<tr>\n<td><code>findAny</code></td>\n<td>终端</td>\n<td><code>Optional&lt;T&gt;</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>findFirst</code></td>\n<td>终端</td>\n<td><code>Optional&lt;T&gt;</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>forEach</code></td>\n<td>终端</td>\n<td><code>void</code></td>\n<td><code>Consumer&lt;T&gt;</code></td>\n<td><code>T -&gt; void</code></td>\n</tr>\n<tr>\n<td><code>collect</code></td>\n<td>终端</td>\n<td><code>R</code></td>\n<td><code>Collector&lt;T, A, R&gt;</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>reduce</code></td>\n<td>终端</td>\n<td><code>Optional&lt;T&gt;</code></td>\n<td><code>BinaryOperator&lt;T&gt;</code></td>\n<td><code>(T, T) -&gt; T</code></td>\n</tr>\n<tr>\n<td><code>count</code></td>\n<td>终端</td>\n<td><code>long</code></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"新的日期和-API\"><a href=\"#新的日期和-API\" class=\"headerlink\" title=\"新的日期和 API\"></a>新的日期和 API</h3><blockquote>\n<p>参考：<a href=\"https://github.com/hellokaton/learn-java8/blob/master/java8-datetime-api/README.md\">hellokaton/learn-java8</a></p>\n</blockquote>\n","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Java8 有一个非常显著的特点，就是提供了函数式编程，本文也将介绍 Java8 的几个新特性来实现函数式编程。学会这些 API 能够编写出简单、干净、易读的代码（尤其是对集合的操作）。Java8 新特性包括：</p>\n<ul>\n<li>Lambda 表达式</li>\n<li>Stream API</li>\n<li>接口新特性<ul>\n<li>函数式接口（<code>@FunctionalInterface</code>）</li>\n<li>默认方法（<code>default</code>）</li>\n</ul>\n</li>\n<li>Optional API</li>\n<li>方法引用</li>\n</ul>\n<p>JDK8 新特性</p>\n<p>正在努力更新中…</p>\n<h2 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h2><ul>\n<li>只包含了一个抽象方法的接口，称为函数式接口（可以有多个非抽象方法）。可以使用<code>@FunctionalInterface</code>注解自定义声明</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//JDK 1.8 之前已有的函数式接口:</span></span><br><span class=\"line\">- java.lang.Runnable</span><br><span class=\"line\">- java.util.concurrent.Callable</span><br><span class=\"line\">- java.security.PrivilegedAction</span><br><span class=\"line\">- java.util.Comparator</span><br><span class=\"line\">- java.io.FileFilter</span><br><span class=\"line\">- java.nio.file.PathMatcher</span><br><span class=\"line\">- java.lang.reflect.InvocationHandler</span><br><span class=\"line\">- java.beans.PropertyChangeListener</span><br><span class=\"line\">- java.awt.event.ActionListener</span><br><span class=\"line\">- javax.swing.event.ChangeListener</span><br><span class=\"line\"><span class=\"comment\">//JDK 1.8 新增加的函数接口：</span></span><br><span class=\"line\">- java.util.function</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lambda-表达式\"><a href=\"#Lambda-表达式\" class=\"headerlink\" title=\"Lambda 表达式\"></a>Lambda 表达式</h2><ul>\n<li><code>Lambda</code>表达式的使用依赖于函数式接口</li>\n<li>使用<code>Lambda</code>表达式来表示函数式接口的实现（JAVA 8 之前一般是用匿名类实现的）</li>\n</ul>\n<h3 id=\"语法格式\"><a href=\"#语法格式\" class=\"headerlink\" title=\"语法格式\"></a>语法格式</h3><ul>\n<li><code>-&gt; :Lambda操作符</code></li>\n<li><code>-&gt; 左边(parameters):Lambda形参列表</code>(相当于接口中的抽象方法的形参列表)</li>\n</ul>\n<ol>\n<li>参数类型可以省略，可由编译器推断得出(类型推断)</li>\n<li>如果只有一个参数,<code>()</code>也可以省略</li>\n</ol>\n<ul>\n<li><code>-&gt; 右边:Lambda体</code>(重写的抽象方法的方法体)</li>\n</ul>\n<ol>\n<li>如果只有一条执行语句，<code>&#123;&#125;</code>及<code>return</code>可以省略</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(parameters) -&gt; expression</span><br><span class=\"line\">或</span><br><span class=\"line\">(parameters) -&gt;&#123; statements; &#125;</span><br><span class=\"line\"><span class=\"comment\">// 1. 接收2个int型整数,返回他们的和</span></span><br><span class=\"line\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) -&gt; x + y</span><br><span class=\"line\"><span class=\"comment\">// 2. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)</span></span><br><span class=\"line\">(String s) -&gt; System.out.print(s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    Runnable runnable=<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;*********&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    runnable.run();</span><br><span class=\"line\">    <span class=\"comment\">//Lambda表达式写法</span></span><br><span class=\"line\">    Runnable runnable= () -&gt; System.out.println(<span class=\"string\">&quot;*********&quot;</span>);</span><br><span class=\"line\">    runnable.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h4><table>\n<thead>\n<tr>\n<th>使用案例</th>\n<th>Lambda 的例子</th>\n<th>对应的函数式接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>布尔表达式</td>\n<td><code>(List&lt;String&gt; list) -&gt; list.isEmpty()</code></td>\n<td><code>Predicate&lt;List&lt;String&gt;&gt;</code></td>\n</tr>\n<tr>\n<td>创建对象</td>\n<td><code>() -&gt; new Project()</code></td>\n<td><code>Supplier&lt;Project&gt;</code></td>\n</tr>\n<tr>\n<td>消费一个对象</td>\n<td><code>(Project p) -&gt; System.out.println(p.getStars())</code></td>\n<td><code>Consumer&lt;Project&gt;</code></td>\n</tr>\n<tr>\n<td>从一个对象中选择/提取</td>\n<td><code>(int a, int b) -&gt; a * b</code></td>\n<td><code>IntBinaryOperator</code></td>\n</tr>\n<tr>\n<td>比较两个对象</td>\n<td><code>(Project p1, Project p2) -&gt; p1.getStars().compareTo(p2.getStars())</code></td>\n<td><code>Comparator&lt;Project&gt; 或 BiFunction&lt;Project,</code> <code>Project, Integer&gt; 或 ToIntBiFunction&lt;Project, Project&gt;</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h3><h4 id=\"语法格式-1\"><a href=\"#语法格式-1\" class=\"headerlink\" title=\"语法格式\"></a>语法格式</h4><ul>\n<li>使用操作符<code>::</code>类或对象与方法名分割</li>\n<li>主要有三种使用情况</li>\n</ul>\n<p> 对象<code>::</code>实例方法名</p>\n<p>类<code>::</code>实例方法名</p>\n<p>类<code>::</code>静态方法名</p>\n<h4 id=\"使用案例-1\"><a href=\"#使用案例-1\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LambdaQueryWrapper&lt;SysDictItem&gt; queryWrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">LambdaQueryWrapper</span>&lt;SysDictItem&gt;();</span><br><span class=\"line\"><span class=\"comment\">//相当于SysDictItem.getStatus();</span></span><br><span class=\"line\">queryWrapper.eq(SysDictItem::getStatus, <span class=\"number\">1</span>);</span><br><span class=\"line\">queryWrapper.orderByAsc(SysDictItem::getSortOrder);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Stream-API\"><a href=\"#Stream-API\" class=\"headerlink\" title=\"Stream API\"></a>Stream API</h2><ul>\n<li>使用<code>Stream API</code>对集合数据进行操作</li>\n<li><code>stream</code> 和 <code>collection</code> 集合的区别<ul>\n<li><code>collection</code>是一种静态的内存数据结构，而<code>stream</code>是有关计算的，前者主要面向内存，存储在内存中，后者主要面向<code>cpu</code>，通过<code>cpu</code>计算实现</li>\n</ul>\n</li>\n<li><code>Stream</code>的创建方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.通过集合创建</span></span><br><span class=\"line\"><span class=\"comment\">//default Stream&lt;E&gt; stream();//返回一个顺序流</span></span><br><span class=\"line\"><span class=\"comment\">//default Stream&lt;E&gt; parallelStream();//返回一个并行流</span></span><br><span class=\"line\">List&lt;Person&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Person&gt;();</span><br><span class=\"line\">Stream&lt;Person&gt; stream = list.stream();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.通过Arrays静态方法</span></span><br><span class=\"line\">String[] names = &#123;<span class=\"string\">&quot;chaimm&quot;</span>,<span class=\"string\">&quot;peter&quot;</span>,<span class=\"string\">&quot;john&quot;</span>&#125;;</span><br><span class=\"line\">Stream&lt;String&gt; stream = Arrays.stream(names);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3.通过Stream of</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;chaimm&quot;</span>,<span class=\"string\">&quot;peter&quot;</span>,<span class=\"string\">&quot;john&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4.创建无限流</span></span><br><span class=\"line\"><span class=\"comment\">//迭代 遍历0到9</span></span><br><span class=\"line\">Stream.iterate(<span class=\"number\">0</span>,t-&gt;t+<span class=\"number\">1</span>).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//生成 10个随机数</span></span><br><span class=\"line\">Stream.generate(Math::random).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>中间操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//中间操作</span></span><br><span class=\"line\"><span class=\"comment\">//filer(Predicate p)过滤数据</span></span><br><span class=\"line\">List&lt;Person&gt; result = list.stream()</span><br><span class=\"line\">    .filter(Person::isStudent)</span><br><span class=\"line\">    .collect(toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//limit(n)截断流</span></span><br><span class=\"line\">List&lt;Person&gt; result = list.stream()</span><br><span class=\"line\">    .limit(<span class=\"number\">3</span>)</span><br><span class=\"line\">    .collect(toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//skip(n)跳过元素</span></span><br><span class=\"line\">List&lt;Person&gt; result = list.stream()</span><br><span class=\"line\">    .skip(<span class=\"number\">3</span>)</span><br><span class=\"line\">    .collect(toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//distinct 筛选去重</span></span><br><span class=\"line\">List&lt;Person&gt; result = list.stream()</span><br><span class=\"line\">    .distinct()</span><br><span class=\"line\">    .collect(toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//映射map(Function f)  flatMap(Function f)合并多个流</span></span><br><span class=\"line\">List&lt;String&gt; result = list.stream()</span><br><span class=\"line\">    .map(Person::getName)</span><br><span class=\"line\">    .collect(toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//排序 sorted() 自然排序 sorted(Comparator c)定制顺序</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>终止操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">//终止操作</span></span><br><span class=\"line\"><span class=\"comment\">//匹配与查找</span></span><br><span class=\"line\"><span class=\"comment\">//allMatch(Predicate e)检查是否匹配所有元素 返回boolean</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> list.stream()</span><br><span class=\"line\">    .allMatch(Person::isStudent);</span><br><span class=\"line\"><span class=\"comment\">//anyMatch(Predicate e)检查是否至少匹配一个元素</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> list.stream()</span><br><span class=\"line\">    .anyMatch(Person::isStudent);</span><br><span class=\"line\"><span class=\"comment\">//noneMatch(Predicate e)检查是否没有匹配的元素</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> list.stream()</span><br><span class=\"line\">    .noneMatch(Person::isStudent);</span><br><span class=\"line\"><span class=\"comment\">//findFierst()返回第一个元素</span></span><br><span class=\"line\">Optional&lt;Person&gt; person = list.stream().findFirst();</span><br><span class=\"line\"><span class=\"comment\">//findAny()返回当前流中的任意元素</span></span><br><span class=\"line\">Optional&lt;Person&gt; person = list.stream().findAny();</span><br><span class=\"line\"><span class=\"comment\">//count 返回流中元素的总个数</span></span><br><span class=\"line\"><span class=\"comment\">//max(Comparator c)返回流中最大值</span></span><br><span class=\"line\"><span class=\"comment\">//min(Comparator c)返回流中最小值</span></span><br><span class=\"line\"><span class=\"comment\">//forEach(Consumer c)内部迭代</span></span><br><span class=\"line\"><span class=\"comment\">//归约 reduce(T identity,BinaryOperator)可以将流中元素结合起来得到一个值（求和）</span></span><br><span class=\"line\"><span class=\"comment\">//例：计算所有人的年龄总和</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> list.stream().reduce(<span class=\"number\">0</span>, (person1,person2)-&gt;person1.getAge()+person2.getAge());</span><br><span class=\"line\"><span class=\"comment\">//收集collect(Collector c) 将流中元素收集返回相应类型</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"中间操作和收集操作\"><a href=\"#中间操作和收集操作\" class=\"headerlink\" title=\"中间操作和收集操作\"></a>中间操作和收集操作</h4><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>类型</th>\n<th>返回类型</th>\n<th>使用的类型/函数式接口</th>\n<th>函数描述符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>filter</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><code>T -&gt; boolean</code></td>\n</tr>\n<tr>\n<td><code>distinct</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>skip</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td><code>long</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>map</code></td>\n<td>中间</td>\n<td><code>Stream&lt;R&gt;</code></td>\n<td><code>Function&lt;T, R&gt;</code></td>\n<td><code>T -&gt; R</code></td>\n</tr>\n<tr>\n<td><code>flatMap</code></td>\n<td>中间</td>\n<td><code>Stream&lt;R&gt;</code></td>\n<td><code>Function&lt;T,Stream&lt;R&gt;&gt;</code></td>\n<td><code>T -&gt; Stream&lt;R&gt;</code></td>\n</tr>\n<tr>\n<td><code>limit</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td><code>long</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>sorted</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td><code>Comparator&lt;T&gt;</code></td>\n<td><code>(T, T) -&gt; int</code></td>\n</tr>\n<tr>\n<td><code>anyMatch</code></td>\n<td>终端</td>\n<td><code>boolean</code></td>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><code>T -&gt; boolean</code></td>\n</tr>\n<tr>\n<td><code>noneMatch</code></td>\n<td>终端</td>\n<td><code>boolean</code></td>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><code>T -&gt; boolean</code></td>\n</tr>\n<tr>\n<td><code>allMatch</code></td>\n<td>终端</td>\n<td><code>boolean</code></td>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><code>T -&gt; boolean</code></td>\n</tr>\n<tr>\n<td><code>findAny</code></td>\n<td>终端</td>\n<td><code>Optional&lt;T&gt;</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>findFirst</code></td>\n<td>终端</td>\n<td><code>Optional&lt;T&gt;</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>forEach</code></td>\n<td>终端</td>\n<td><code>void</code></td>\n<td><code>Consumer&lt;T&gt;</code></td>\n<td><code>T -&gt; void</code></td>\n</tr>\n<tr>\n<td><code>collect</code></td>\n<td>终端</td>\n<td><code>R</code></td>\n<td><code>Collector&lt;T, A, R&gt;</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>reduce</code></td>\n<td>终端</td>\n<td><code>Optional&lt;T&gt;</code></td>\n<td><code>BinaryOperator&lt;T&gt;</code></td>\n<td><code>(T, T) -&gt; T</code></td>\n</tr>\n<tr>\n<td><code>count</code></td>\n<td>终端</td>\n<td><code>long</code></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"新的日期和-API\"><a href=\"#新的日期和-API\" class=\"headerlink\" title=\"新的日期和 API\"></a>新的日期和 API</h3><blockquote>\n<p>参考：<a href=\"https://github.com/hellokaton/learn-java8/blob/master/java8-datetime-api/README.md\">hellokaton/learn-java8</a></p>\n</blockquote>\n","categories":[{"name":"后端开发","path":"api/categories/后端开发.json"}],"tags":[{"name":"技巧","path":"api/tags/技巧.json"},{"name":"笔记","path":"api/tags/笔记.json"},{"name":"Java","path":"api/tags/Java.json"}]}