{"title":"Redis 缓存穿透、缓存击穿、缓存雪崩问题","slug":"Redis缓存穿透、缓存击穿、缓存雪崩问题","date":"2021-06-17T08:25:44.000Z","updated":"2021-06-17T08:26:26.000Z","comments":true,"path":"api/articles/Redis缓存穿透、缓存击穿、缓存雪崩问题.json","excerpt":null,"covers":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在项目中引入一个缓存系统，不得不考虑的问题就是：缓存穿透、缓存击穿和缓存雪崩问题。</p>\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><p>缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>\n<p>在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。</p>\n<p>如发起为 id 为<code>-1</code>的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>\n<p><strong>解决方案：</strong></p>\n<ul>\n<li>接口层增加校验，如用户鉴权校验、id 基础校验（id&lt;=0 直接拦截）</li>\n<li>在数据库和缓存中都取不到的数据，可以将在缓存中存入一个空对象（<strong>key-null</strong>），设置一个短的有效时间。这样可以防止一个用户反复暴力攻击一个 id 请求</li>\n</ul>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><p><strong>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期）</strong>，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p>\n<p><strong>解决方案：</strong></p>\n<ol>\n<li><strong>设置热点数据永不过期</strong></li>\n<li><strong>接口限流与熔断，降级</strong>。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要做好降级准备，当接口中某些服务不可用时，进行熔断，失败快速返回机制</li>\n<li><strong>布隆过滤器</strong>。bloomfilter 就类似于一个 hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个 key 是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于 hash 算法和容器大小，</li>\n<li><strong>加互斥锁</strong></li>\n</ol>\n<h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h2><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至 down 机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>\n<p><strong>解决方案：</strong></p>\n<ol>\n<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>\n<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li>\n<li>设置热点数据永远不过期。</li>\n</ol>\n","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在项目中引入一个缓存系统，不得不考虑的问题就是：缓存穿透、缓存击穿和缓存雪崩问题。</p>\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><p>缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>\n<p>在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。</p>\n<p>如发起为 id 为<code>-1</code>的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>\n<p><strong>解决方案：</strong></p>\n<ul>\n<li>接口层增加校验，如用户鉴权校验、id 基础校验（id&lt;=0 直接拦截）</li>\n<li>在数据库和缓存中都取不到的数据，可以将在缓存中存入一个空对象（<strong>key-null</strong>），设置一个短的有效时间。这样可以防止一个用户反复暴力攻击一个 id 请求</li>\n</ul>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><p><strong>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期）</strong>，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p>\n<p><strong>解决方案：</strong></p>\n<ol>\n<li><strong>设置热点数据永不过期</strong></li>\n<li><strong>接口限流与熔断，降级</strong>。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要做好降级准备，当接口中某些服务不可用时，进行熔断，失败快速返回机制</li>\n<li><strong>布隆过滤器</strong>。bloomfilter 就类似于一个 hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个 key 是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于 hash 算法和容器大小，</li>\n<li><strong>加互斥锁</strong></li>\n</ol>\n<h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h2><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至 down 机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>\n<p><strong>解决方案：</strong></p>\n<ol>\n<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>\n<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li>\n<li>设置热点数据永远不过期。</li>\n</ol>\n","categories":[{"name":"中间件","path":"api/categories/中间件.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"Redis","path":"api/tags/Redis.json"}]}