{"title":"缓存数据库双写一致性问题","slug":"缓存数据双写一致性问题","date":"2021-05-23T08:25:44.000Z","updated":"2021-05-23T08:26:26.000Z","comments":true,"path":"api/articles/缓存数据双写一致性问题.json","excerpt":null,"covers":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在项目中引入缓存系统，我们需要考虑在对旧数据进行更新操作时，我们是先淘汰缓存，再更新数据库；还是先更新数据库，再淘汰缓存。或者是更新数据库，再更新缓存呢？下面是对这三种方案的优缺点的一些总结：</p>\n<h2 id=\"缓存更新策略\"><a href=\"#缓存更新策略\" class=\"headerlink\" title=\"缓存更新策略\"></a>缓存更新策略</h2><ol>\n<li>先更新数据库，再更新缓存</li>\n<li>先更新数据库，再删除缓存</li>\n<li>先删除缓存，再更新数据库</li>\n</ol>\n<h2 id=\"先更新数据库，再更新缓存\"><a href=\"#先更新数据库，再更新缓存\" class=\"headerlink\" title=\"先更新数据库，再更新缓存\"></a>先更新数据库，再更新缓存</h2><blockquote>\n<p>这套方案适用场景比较少，主要从下面几个原因分析：</p>\n</blockquote>\n<h3 id=\"资源浪费\"><a href=\"#资源浪费\" class=\"headerlink\" title=\"资源浪费\"></a>资源浪费</h3><p>在一些大型的信息网站中（博客、贴吧），我们引入缓存主要是对热数据（请求频繁的）进行缓存，而这时候，如果很多用户对于冷数据（长时间没人访问，或者访问量很少）进行更新，然后再去更新缓存，这就造成了缓存资源的大量浪费（因为访问量少，导致这些缓存命中低，浪费缓存资源）。</p>\n<h3 id=\"脏数据\"><a href=\"#脏数据\" class=\"headerlink\" title=\"脏数据\"></a>脏数据</h3><p>这是由于出现了并发操作的原因导致的，如：同时有两个请求 A 和 B 对数据进行了更新操作，由于网络原因，可能存在以下情况：</p>\n<ol>\n<li>请求 A 更新了数据库</li>\n<li>请求 B 更新了数据库</li>\n<li>请求 B 更新了缓存</li>\n<li>请求 A 更新了缓存</li>\n</ol>\n<p>这就出现了 A 数据覆盖了 B 数据的情况，此时就产生了脏数据，如果没有缓存定时过期机制，此时的脏数据需要等待下一次的更新，才会对缓存进行更新，虽然用户看到数据出现问题，会再重新更新一次，但这已经有多了一次不必要的请求了，写请求量大的时候，容易造成众多不必要的更新请求。</p>\n<h3 id=\"请求时间\"><a href=\"#请求时间\" class=\"headerlink\" title=\"请求时间\"></a>请求时间</h3><p>如果缓存不是一种简单的数据缓存，而是需要经过较为复杂的运算，才能得出缓存值，这时候，请求将会在计算缓存值上，耗费一部分时间，而这就导致了请求的响应时间变长，增加系统的负担，降低了系统的处理能力。</p>\n<h3 id=\"频繁写入\"><a href=\"#频繁写入\" class=\"headerlink\" title=\"频繁写入\"></a>频繁写入</h3><p>在写请求很多，而读请求很少的场景下，缓存没起到多大的作用，就给频繁更新了，造成了资源浪费，如：</p>\n<ol>\n<li>对数据 A 进行了一次修改，生成了缓存 A</li>\n<li>此时没有读取数据 A 的请求</li>\n<li>对数据 A 进行了一次修改，更新了缓存 A</li>\n<li>此时没有读取数据 A 的请求</li>\n<li>对数据 A 进行了一次修改</li>\n<li>此时有了读取数据 A 的请求</li>\n</ol>\n<p>这时就会造成缓存的不必要更新操作（没有人读取缓存），用户量大的时候，会造成大量的不必要操作，造成系统资源的浪费</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>一般适用于下列几种场景：</p>\n<ol>\n<li>读请求占据网站的总流量的 99%</li>\n<li>网站数据量不大（几十万的文章数据）</li>\n<li>很少会去更新数据（一般文章写好后，不会去更新）</li>\n</ol>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><ol>\n<li>个人博客</li>\n<li>手册网站（w3cschool、菜鸟教程等）</li>\n</ol>\n<h2 id=\"先更新数据库，再删除缓存\"><a href=\"#先更新数据库，再删除缓存\" class=\"headerlink\" title=\"先更新数据库，再删除缓存\"></a>先更新数据库，再删除缓存</h2><p>这套方案比较多的平台适用，如 FaceBook。但也存在一些问题：</p>\n<h3 id=\"脏数据-1\"><a href=\"#脏数据-1\" class=\"headerlink\" title=\"脏数据\"></a>脏数据</h3><p>造成脏数据的原因主要由并发引起，如：</p>\n<ol>\n<li>用户 A 请求数据 A</li>\n<li>数据 A 缓存失效</li>\n<li>用户 A 从数据库中得到旧数据数据 A</li>\n<li>用户 B 更新了数据 A（新数据）</li>\n<li>用户 B 删除了缓存</li>\n<li>用户 A 将查到旧数据写入了缓存</li>\n</ol>\n<p><strong>此时就产生了脏数据，虽然这种概率非常小，但对于更新不频繁的网站来说，此时的脏数据就是个很严重的错误。</strong></p>\n<h3 id=\"缓存删除失效\"><a href=\"#缓存删除失效\" class=\"headerlink\" title=\"缓存删除失效\"></a>缓存删除失效</h3><ol>\n<li>用户 A 更新了数据 A</li>\n<li>用户 A 删除数据 A 的缓存失败</li>\n<li>用户 B 读到数据 A 缓存的旧数据</li>\n</ol>\n<p>此时就产生了数据不一致的问题。</p>\n<h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><h4 id=\"设置缓存的有效时间（最简单的解决方案）\"><a href=\"#设置缓存的有效时间（最简单的解决方案）\" class=\"headerlink\" title=\"设置缓存的有效时间（最简单的解决方案）\"></a>设置缓存的有效时间（最简单的解决方案）</h4><p><strong>优点：</strong></p>\n<ul>\n<li>简单</li>\n<li>易操作</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>会存在短时间内的旧数据</li>\n<li>如果数据量太多，缓存有效时间短，容易发生一段时间内缓存大量失效，此时的数据库压力突然剧增，引发缓存雪崩现象（缓存有效时间为随机值减少发生缓存雪崩的可能性）</li>\n</ul>\n<h4 id=\"消息队列（增加复杂性，需要引入消息队列系统）\"><a href=\"#消息队列（增加复杂性，需要引入消息队列系统）\" class=\"headerlink\" title=\"消息队列（增加复杂性，需要引入消息队列系统）\"></a>消息队列（增加复杂性，需要引入消息队列系统）</h4><p><strong>步骤：</strong></p>\n<ol>\n<li>更新数据库</li>\n<li>删除缓存失败</li>\n<li>将需要删除的 Key 发送到消息队列</li>\n<li>隔断时间从消息队列中拉取要删除的 key</li>\n<li>继续删除，直至成功为止</li>\n</ol>\n<p><strong>优点：</strong></p>\n<ul>\n<li>不会引发缓存雪崩</li>\n<li>保证了缓存的删除</li>\n<li>不会增加更新的处理时间</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>引入了消息队列系统，增加了系统的复杂性</li>\n</ul>\n<h2 id=\"先删除缓存，在更新数据库\"><a href=\"#先删除缓存，在更新数据库\" class=\"headerlink\" title=\"先删除缓存，在更新数据库\"></a>先删除缓存，在更新数据库</h2><p>这种方案是比较多人使用的，但也会出现脏数据问题</p>\n<h3 id=\"原因：\"><a href=\"#原因：\" class=\"headerlink\" title=\"原因：\"></a><strong>原因：</strong></h3><ol>\n<li>用户 A 删除缓存失败</li>\n<li>用户 A 成功更新了数据</li>\n</ol>\n<p>或者</p>\n<ol>\n<li>用户 A 删除了缓存</li>\n<li>用户 B 读取缓存，缓存不存在</li>\n<li>用户 B 从数据库拿到旧数据</li>\n<li>用户 B 更新了缓存</li>\n<li>用户 A 更新了数据</li>\n</ol>\n<p>以上两种情况都能造成脏数据的产生</p>\n<h3 id=\"解决方案：-1\"><a href=\"#解决方案：-1\" class=\"headerlink\" title=\"解决方案：\"></a><strong>解决方案：</strong></h3><h4 id=\"设置缓存的有效时间（最简单的解决方案）-1\"><a href=\"#设置缓存的有效时间（最简单的解决方案）-1\" class=\"headerlink\" title=\"设置缓存的有效时间（最简单的解决方案）\"></a>设置缓存的有效时间（最简单的解决方案）</h4><p><strong>优点：</strong></p>\n<ul>\n<li>简单</li>\n<li>易操作</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>会存在短时间内的旧数据</li>\n<li>如果数据量太多，缓存有效时间短，容易发生一段时间内缓存大量失效，此时的数据库压力突然剧增，引发缓存雪崩现象（缓存有效时间为随机值减少发生缓存雪崩的可能性）</li>\n</ul>\n<h4 id=\"消息队列（增加复杂性，需要引入消息队列系统）-1\"><a href=\"#消息队列（增加复杂性，需要引入消息队列系统）-1\" class=\"headerlink\" title=\"消息队列（增加复杂性，需要引入消息队列系统）\"></a>消息队列（增加复杂性，需要引入消息队列系统）</h4><p><strong>步骤：</strong></p>\n<ol>\n<li>更新数据库</li>\n<li>删除缓存失败</li>\n<li>将需要删除的 Key 发送到消息队列</li>\n<li>隔断时间从消息队列中拉取要删除的 key</li>\n<li>继续删除，直至成功为止</li>\n</ol>\n<p><strong>优点：</strong></p>\n<ul>\n<li>不会引发缓存雪崩</li>\n<li>保证了缓存的删除</li>\n<li>不会增加更新的处理时间</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>引入了消息队列系统，增加了系统的复杂性</li>\n</ul>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ol>\n<li>以上的几种方案需根据自己的业务来选择</li>\n<li>存在即合理，各有优缺点</li>\n<li>使用设置缓存失效时间时，需注意缓存雪崩问题</li>\n<li>可以使用消息队列来避免脏数据的出现</li>\n</ol>\n","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在项目中引入缓存系统，我们需要考虑在对旧数据进行更新操作时，我们是先淘汰缓存，再更新数据库；还是先更新数据库，再淘汰缓存。或者是更新数据库，再更新缓存呢？下面是对这三种方案的优缺点的一些总结：</p>\n<h2 id=\"缓存更新策略\"><a href=\"#缓存更新策略\" class=\"headerlink\" title=\"缓存更新策略\"></a>缓存更新策略</h2><ol>\n<li>先更新数据库，再更新缓存</li>\n<li>先更新数据库，再删除缓存</li>\n<li>先删除缓存，再更新数据库</li>\n</ol>\n<h2 id=\"先更新数据库，再更新缓存\"><a href=\"#先更新数据库，再更新缓存\" class=\"headerlink\" title=\"先更新数据库，再更新缓存\"></a>先更新数据库，再更新缓存</h2><blockquote>\n<p>这套方案适用场景比较少，主要从下面几个原因分析：</p>\n</blockquote>\n<h3 id=\"资源浪费\"><a href=\"#资源浪费\" class=\"headerlink\" title=\"资源浪费\"></a>资源浪费</h3><p>在一些大型的信息网站中（博客、贴吧），我们引入缓存主要是对热数据（请求频繁的）进行缓存，而这时候，如果很多用户对于冷数据（长时间没人访问，或者访问量很少）进行更新，然后再去更新缓存，这就造成了缓存资源的大量浪费（因为访问量少，导致这些缓存命中低，浪费缓存资源）。</p>\n<h3 id=\"脏数据\"><a href=\"#脏数据\" class=\"headerlink\" title=\"脏数据\"></a>脏数据</h3><p>这是由于出现了并发操作的原因导致的，如：同时有两个请求 A 和 B 对数据进行了更新操作，由于网络原因，可能存在以下情况：</p>\n<ol>\n<li>请求 A 更新了数据库</li>\n<li>请求 B 更新了数据库</li>\n<li>请求 B 更新了缓存</li>\n<li>请求 A 更新了缓存</li>\n</ol>\n<p>这就出现了 A 数据覆盖了 B 数据的情况，此时就产生了脏数据，如果没有缓存定时过期机制，此时的脏数据需要等待下一次的更新，才会对缓存进行更新，虽然用户看到数据出现问题，会再重新更新一次，但这已经有多了一次不必要的请求了，写请求量大的时候，容易造成众多不必要的更新请求。</p>\n<h3 id=\"请求时间\"><a href=\"#请求时间\" class=\"headerlink\" title=\"请求时间\"></a>请求时间</h3><p>如果缓存不是一种简单的数据缓存，而是需要经过较为复杂的运算，才能得出缓存值，这时候，请求将会在计算缓存值上，耗费一部分时间，而这就导致了请求的响应时间变长，增加系统的负担，降低了系统的处理能力。</p>\n<h3 id=\"频繁写入\"><a href=\"#频繁写入\" class=\"headerlink\" title=\"频繁写入\"></a>频繁写入</h3><p>在写请求很多，而读请求很少的场景下，缓存没起到多大的作用，就给频繁更新了，造成了资源浪费，如：</p>\n<ol>\n<li>对数据 A 进行了一次修改，生成了缓存 A</li>\n<li>此时没有读取数据 A 的请求</li>\n<li>对数据 A 进行了一次修改，更新了缓存 A</li>\n<li>此时没有读取数据 A 的请求</li>\n<li>对数据 A 进行了一次修改</li>\n<li>此时有了读取数据 A 的请求</li>\n</ol>\n<p>这时就会造成缓存的不必要更新操作（没有人读取缓存），用户量大的时候，会造成大量的不必要操作，造成系统资源的浪费</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>一般适用于下列几种场景：</p>\n<ol>\n<li>读请求占据网站的总流量的 99%</li>\n<li>网站数据量不大（几十万的文章数据）</li>\n<li>很少会去更新数据（一般文章写好后，不会去更新）</li>\n</ol>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><ol>\n<li>个人博客</li>\n<li>手册网站（w3cschool、菜鸟教程等）</li>\n</ol>\n<h2 id=\"先更新数据库，再删除缓存\"><a href=\"#先更新数据库，再删除缓存\" class=\"headerlink\" title=\"先更新数据库，再删除缓存\"></a>先更新数据库，再删除缓存</h2><p>这套方案比较多的平台适用，如 FaceBook。但也存在一些问题：</p>\n<h3 id=\"脏数据-1\"><a href=\"#脏数据-1\" class=\"headerlink\" title=\"脏数据\"></a>脏数据</h3><p>造成脏数据的原因主要由并发引起，如：</p>\n<ol>\n<li>用户 A 请求数据 A</li>\n<li>数据 A 缓存失效</li>\n<li>用户 A 从数据库中得到旧数据数据 A</li>\n<li>用户 B 更新了数据 A（新数据）</li>\n<li>用户 B 删除了缓存</li>\n<li>用户 A 将查到旧数据写入了缓存</li>\n</ol>\n<p><strong>此时就产生了脏数据，虽然这种概率非常小，但对于更新不频繁的网站来说，此时的脏数据就是个很严重的错误。</strong></p>\n<h3 id=\"缓存删除失效\"><a href=\"#缓存删除失效\" class=\"headerlink\" title=\"缓存删除失效\"></a>缓存删除失效</h3><ol>\n<li>用户 A 更新了数据 A</li>\n<li>用户 A 删除数据 A 的缓存失败</li>\n<li>用户 B 读到数据 A 缓存的旧数据</li>\n</ol>\n<p>此时就产生了数据不一致的问题。</p>\n<h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><h4 id=\"设置缓存的有效时间（最简单的解决方案）\"><a href=\"#设置缓存的有效时间（最简单的解决方案）\" class=\"headerlink\" title=\"设置缓存的有效时间（最简单的解决方案）\"></a>设置缓存的有效时间（最简单的解决方案）</h4><p><strong>优点：</strong></p>\n<ul>\n<li>简单</li>\n<li>易操作</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>会存在短时间内的旧数据</li>\n<li>如果数据量太多，缓存有效时间短，容易发生一段时间内缓存大量失效，此时的数据库压力突然剧增，引发缓存雪崩现象（缓存有效时间为随机值减少发生缓存雪崩的可能性）</li>\n</ul>\n<h4 id=\"消息队列（增加复杂性，需要引入消息队列系统）\"><a href=\"#消息队列（增加复杂性，需要引入消息队列系统）\" class=\"headerlink\" title=\"消息队列（增加复杂性，需要引入消息队列系统）\"></a>消息队列（增加复杂性，需要引入消息队列系统）</h4><p><strong>步骤：</strong></p>\n<ol>\n<li>更新数据库</li>\n<li>删除缓存失败</li>\n<li>将需要删除的 Key 发送到消息队列</li>\n<li>隔断时间从消息队列中拉取要删除的 key</li>\n<li>继续删除，直至成功为止</li>\n</ol>\n<p><strong>优点：</strong></p>\n<ul>\n<li>不会引发缓存雪崩</li>\n<li>保证了缓存的删除</li>\n<li>不会增加更新的处理时间</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>引入了消息队列系统，增加了系统的复杂性</li>\n</ul>\n<h2 id=\"先删除缓存，在更新数据库\"><a href=\"#先删除缓存，在更新数据库\" class=\"headerlink\" title=\"先删除缓存，在更新数据库\"></a>先删除缓存，在更新数据库</h2><p>这种方案是比较多人使用的，但也会出现脏数据问题</p>\n<h3 id=\"原因：\"><a href=\"#原因：\" class=\"headerlink\" title=\"原因：\"></a><strong>原因：</strong></h3><ol>\n<li>用户 A 删除缓存失败</li>\n<li>用户 A 成功更新了数据</li>\n</ol>\n<p>或者</p>\n<ol>\n<li>用户 A 删除了缓存</li>\n<li>用户 B 读取缓存，缓存不存在</li>\n<li>用户 B 从数据库拿到旧数据</li>\n<li>用户 B 更新了缓存</li>\n<li>用户 A 更新了数据</li>\n</ol>\n<p>以上两种情况都能造成脏数据的产生</p>\n<h3 id=\"解决方案：-1\"><a href=\"#解决方案：-1\" class=\"headerlink\" title=\"解决方案：\"></a><strong>解决方案：</strong></h3><h4 id=\"设置缓存的有效时间（最简单的解决方案）-1\"><a href=\"#设置缓存的有效时间（最简单的解决方案）-1\" class=\"headerlink\" title=\"设置缓存的有效时间（最简单的解决方案）\"></a>设置缓存的有效时间（最简单的解决方案）</h4><p><strong>优点：</strong></p>\n<ul>\n<li>简单</li>\n<li>易操作</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>会存在短时间内的旧数据</li>\n<li>如果数据量太多，缓存有效时间短，容易发生一段时间内缓存大量失效，此时的数据库压力突然剧增，引发缓存雪崩现象（缓存有效时间为随机值减少发生缓存雪崩的可能性）</li>\n</ul>\n<h4 id=\"消息队列（增加复杂性，需要引入消息队列系统）-1\"><a href=\"#消息队列（增加复杂性，需要引入消息队列系统）-1\" class=\"headerlink\" title=\"消息队列（增加复杂性，需要引入消息队列系统）\"></a>消息队列（增加复杂性，需要引入消息队列系统）</h4><p><strong>步骤：</strong></p>\n<ol>\n<li>更新数据库</li>\n<li>删除缓存失败</li>\n<li>将需要删除的 Key 发送到消息队列</li>\n<li>隔断时间从消息队列中拉取要删除的 key</li>\n<li>继续删除，直至成功为止</li>\n</ol>\n<p><strong>优点：</strong></p>\n<ul>\n<li>不会引发缓存雪崩</li>\n<li>保证了缓存的删除</li>\n<li>不会增加更新的处理时间</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>引入了消息队列系统，增加了系统的复杂性</li>\n</ul>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ol>\n<li>以上的几种方案需根据自己的业务来选择</li>\n<li>存在即合理，各有优缺点</li>\n<li>使用设置缓存失效时间时，需注意缓存雪崩问题</li>\n<li>可以使用消息队列来避免脏数据的出现</li>\n</ol>\n","categories":[{"name":"随笔小记","path":"api/categories/随笔小记.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"Redis","path":"api/tags/Redis.json"},{"name":"分布式","path":"api/tags/分布式.json"}]}