{"title":"Java 中的集合概述","slug":"Java中的集合","date":"2021-07-02T08:25:44.000Z","updated":"2021-07-02T08:26:26.000Z","comments":true,"path":"api/articles/Java中的集合.json","excerpt":null,"covers":["https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210520211027.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530093805.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530122749.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530124732.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530175812.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530183426.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530211807.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530213300.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530222445.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530225016.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602103919.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602125701.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602131111.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602133220.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602140414.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602142433.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210603085739.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626130625.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626131638.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626133733.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626152155.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626153333.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626161113.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626162155.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210702150910.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210702153102.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210702155305.png"],"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文记录了Java中的集合框架，文章中的内容摘录自<a href=\"https://www.runoob.com/java/java-collections.html\">Java 集合框架 | 菜鸟教程 (runoob.com)</a>、CSDN、博客园等开源网站。</p>\n<h2 id=\"Java-集合体系\"><a href=\"#Java-集合体系\" class=\"headerlink\" title=\"Java 集合体系\"></a>Java 集合体系</h2><p>Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 <a href=\"https://www.runoob.com/java/java-arraylist.html\">ArrayList</a>、<a href=\"https://www.runoob.com/java/java-linkedlist.html\">LinkedList</a>、<a href=\"https://www.runoob.com/java/java-hashset.html\">HashSet</a>、LinkedHashSet、<a href=\"https://www.runoob.com/java/java-hashmap.html\">HashMap</a>、LinkedHashMap 等等。</p>\n<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p>\n<ul>\n<li><strong>接口：</strong>是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li>\n<li><strong>实现（类）：</strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li>\n<li><strong>算法：</strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li>\n</ul>\n<img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210520211027.png\" alt=\"image-20210520211027579\" style=\"zoom: 50%;\" />\n\n<p>上图堪称集合框架的<strong>上帝视角</strong>，整个框架的组成部分：</p>\n<ol>\n<li>集合框架提供了两个遍历接口： <code>Iterator</code> 和 <code>ListIterator</code> ，其中后者是前者的 <code>优化版</code> ，支持在任意一个位置进行<strong>前后双向遍历</strong>。注意图中的 <code>Collection</code> 应当继承的是 <code>Iterable</code> 而不是 <code>Iterator</code> ，后面会解释 <code>Iterable</code> 和 <code>Iterator</code> 的区别</li>\n<li>整个集合框架分为两个门派（类型）：<code>Collection</code> 和 <code>Map</code>，前者是一个容器，存储一系列的<strong>对象</strong>；后者是键值对<code>&lt;key,value&gt;</code>，存储一系列的<strong>键值对</strong></li>\n<li>在集合框架体系下，衍生出四种具体的集合类型：<code>Map</code>、<code>Set</code>、<code>List</code>、<code>Queue</code></li>\n<li><code>Map</code> 存储 <code>&lt;key,value&gt;</code> 键值对，查找元素时通过 <code>key</code> 查找 <code>value</code></li>\n<li><code>Set</code> 内部存储一系列<strong>不可重复</strong>的对象，且是一个<strong>无序</strong>集合，对象排列顺序不一</li>\n<li><code>List</code> 内部存储一系列<strong>可重复</strong>的对象，是一个<strong>有序</strong>集合，对象按插入顺序排列</li>\n<li><code>Queue</code> 是一个队列容器，其特性与 <code>List</code> 相同，但只能从 <code>对头</code> 和 <code>队尾</code> 操作元素</li>\n<li>JDK为集合的各种操作提供了两个工具类 <code>Collections</code> 和 <code>Arrays</code> ，之后会讲解工具类的常用方法</li>\n<li>四种抽象集合类型内部也会衍生出许多具有不同特性的集合类，<strong>不同场景下择优使用，没有最佳的集合</strong></li>\n</ol>\n<h3 id=\"集合与数组的区别\"><a href=\"#集合与数组的区别\" class=\"headerlink\" title=\"集合与数组的区别\"></a>集合与数组的区别</h3><ul>\n<li><strong>长度区别：</strong><ul>\n<li>数组固定</li>\n<li>集合可变</li>\n</ul>\n</li>\n<li><strong>内容区别：</strong><ul>\n<li>数组可以是基本类型，也可以是引用类型</li>\n<li>集合只能是引用类型</li>\n</ul>\n</li>\n<li><strong>元素区别：</strong><ul>\n<li>数组只能存储同一种类型</li>\n<li>集合可以存储不同类型（其实集合一般也是存储同一种类型）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、Iterator-Iterable-ListIterator\"><a href=\"#二、Iterator-Iterable-ListIterator\" class=\"headerlink\" title=\"二、Iterator Iterable ListIterator\"></a>二、Iterator Iterable ListIterator</h3><p><code>Iterator</code> 和 <code>Iterable</code>，在第一次看这两个接口时，真以为是一摸一样的，没发现里面有啥不同，<strong>存在即合理</strong>，它们两个还是有本质区别的。</p>\n<p>首先来看 <code>Iterator</code> 接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Iterator</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">hasNext</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    E <span class=\"title function_\">next</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">remove</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>提供的API接口含义如下：</p>\n<ul>\n<li><code>hasNext()</code> ：判断集合中是否存在下一个对象</li>\n<li><code>next()</code> ：返回集合中的下一个对象，并将访问指针移动一位</li>\n<li><code>remove()</code> ：删除集合中调用 <code>next()</code> 方法返回的对象</li>\n</ul>\n<p>在早期，遍历集合的方式只有一种，通过 <code>Iterator</code> 迭代器操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">list.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">list.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">    System.out.println(next);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(next==<span class=\"number\">2</span>)&#123;iterator.remove();&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再来看 <code>Iterable</code> 接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Iterable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">\tIterator&lt;T&gt; <span class=\"title function_\">iterator</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">// JDK1.8</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(action);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (T t : <span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            action.accept(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 <code>Iterable</code> 接口里面提供了 <code>Iterator</code> 接口，所以实现了 <code>Iterable</code> 接口的集合依旧可以使用 <code>迭代器</code> 遍历和操作集合中的对象；</p>\n<p>而在 <code>JDK1.8</code> 中， <code>Iterable</code> 提供了一个新的方法 <code>forEach()</code> ，它允许使用增强 for 循环遍历对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Integer num : list)&#123;</span><br><span class=\"line\">    System.out.println(num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们通过反编译上面这段代码，发现它只是 Java 中的一个 <code>语法糖</code> ，本质上还是调用 <code>Iterator</code> 去遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Iterator</span> <span class=\"variable\">iter</span> <span class=\"operator\">=</span> list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(iter.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">    System.out.println(num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为什么要设计两个接口 <code>Iterable</code> 和 <code>Iterator</code> ，而不是保留其中一个就可以了。</p>\n<p>简单来说：<code>Iterator</code> 的保留可以让子类去实现自己的迭代器，而 <code>Iterable</code> 接口更加关注与 <code>for-each</code> 的增强语法。</p>\n</blockquote>\n<p><strong>总结：</strong></p>\n<ul>\n<li><code>Iterator</code> 是提供集合操作内部对象的一个迭代器，它可以 <strong>遍历</strong> 、<strong>移除</strong> 对象，且只能够 <strong>单向移动</strong></li>\n<li> <code>Iterable</code> 是对 <code>Iterator</code> 的封装，在<code>JDK 1.8</code> 时，实现了 <code>Iterable</code> 接口的结合可以使用 <strong>增强 for 循环</strong> 遍历集合对象，我们通过 <strong>反编译</strong> 后发现底层还是使用 <code>Iterator</code> 迭代器进行遍历</li>\n</ul>\n<p>等等，这一章还没完，还有一个 <code>ListIterator</code>。它继承 Iterator 接口，在遍历 <code>List</code> 集合时可以从 <strong>任意索引下标</strong> 开始遍历，而且支持 <strong>双向遍历</strong></p>\n<p> ListIterator 存在于 List 集合之中，通过调用方法可以返回 <strong>起始下标</strong> 为 <code>index</code> 的迭代器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">//返回下标为0的迭代器</span></span><br><span class=\"line\">ListIterator&lt;Integer&gt; listIter1 = list.listIterator();</span><br><span class=\"line\"><span class=\"comment\">//返回下标为5的迭代器</span></span><br><span class=\"line\">ListIterator&lt;Integer&gt; listIter2 = list.listIterator(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>ListIterator 中有几个重要方法，大多数方法与 Iterator 中定义的含义相同，但是 Iterator 强大的地方是可以在 <strong>任意一个下标位置</strong> 返回该迭代器，且可以实现 <strong>双向遍历</strong>。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ListIterator</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Iterator</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">hasNext</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    E <span class=\"title function_\">next</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">hasPrevious</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    E <span class=\"title function_\">previous</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">nextIndex</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">previousIndex</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">remove</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 替换当前下标的元素，即访问过的最后一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">set</span><span class=\"params\">(E e)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Map-和-Collection-接口\"><a href=\"#Map-和-Collection-接口\" class=\"headerlink\" title=\"Map 和 Collection 接口\"></a>Map 和 Collection 接口</h2><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530093805.png\" alt=\"image-20210530093758757\"></p>\n<p><code>Map</code> 接口定义了存储的数据结构是 <code>&lt;key,value&gt;</code> 形式，根据 key 映射到 value，一个 key 对应一个 value，所以 <code>key</code> 不可重复，而 <code>value</code> 可重复。</p>\n<p>在 <code>Map</code> 接口下会将存储的方式细分为不同的种类：</p>\n<ul>\n<li><code>SortedMap</code> 接口：该接口映射可以对 <code>&lt;key,value&gt;</code> 按照自己的规则进行 <strong>排序</strong>，具体实现有 TreeMap </li>\n<li><code>AbstractMap</code> 类：它为子类提供好一些 <strong>通用的API实现</strong>，所有的具体 Map 如 <code>HashMap</code> 都会继承它</li>\n</ul>\n<p>而 <code>Collection</code> 接口提供了所有集合的 <strong>通用方法</strong>（注意这里不包括 <code>Map</code>）：</p>\n<ul>\n<li>添加方法：<code>add(E e)</code> / <code>addAll(Collection&lt;? extends E&gt; c)</code></li>\n<li>删除方法：<code>remove(Object o)</code> / <code>removeAll(Collection&lt;?&gt; c)</code></li>\n<li>查找方法：<code>contains(Object o)</code> / <code>containsAll(Collection&lt;?&gt; c)</code></li>\n<li>查询集合自身信息；<code>size()</code> /  <code>isEmpty()</code></li>\n<li>···</li>\n</ul>\n<p>在 <code>Collection</code> 接口下，同样会将集合细分为不同的种类：</p>\n<ul>\n<li><code>Set</code> 接口：一个<strong>不允许存储重复元素</strong>的<strong>无序</strong>集合，具体实现有 <code>HashSet</code> / <code>TreeSet</code> ···</li>\n<li><code>List</code> 接口：一个<strong>可存储重复元素</strong>的<strong>有序</strong>集合，具体实现有 <code>ArrayList</code> / <code>LinkedList</code> ···</li>\n<li><code>Queue</code> 接口：一个<strong>可存储重复元素</strong>的<strong>队列</strong>，具体实现有 <code>PriorityQueue</code> / <code>ArrayDeque</code> ···</li>\n</ul>\n<h2 id=\"Map-集合体系详解\"><a href=\"#Map-集合体系详解\" class=\"headerlink\" title=\"Map 集合体系详解\"></a>Map 集合体系详解</h2><p><code>Map</code> 接口时由 <code>&lt;key,value&gt;</code> 组成的集合，由 <code>key</code> 映射到<strong>唯一</strong>的 <code>value</code>，所以 <code>Map</code> 不能包含重复的 <code>key</code> ，每个键<strong>至多</strong>映射一个值。下图是整个 Map 集合体系的主要组成部分：</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530122749.png\" alt=\"image-20210530122749775\"></p>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p>HashMap 是一个 <strong>最通用的</strong> 利用哈希表存储元素的集合，将元素放入 HashMap 时，将 <code>key</code> 的哈希值转换为数组的 <code>索引</code> 下标 <strong>确定存放位置</strong>，查找时，根据 <code>key</code> 的哈希地址转换成数组的 <code>索引</code> 下标 <strong>确定查找位置</strong>。</p>\n<p>HashMap 底层是用数组 + 链表 + 红黑树这三种数据结构实现，它是 <strong>非线程安全</strong> 的集合。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530124732.png\" alt=\"image-20210530124731984\"></p>\n<p>发送哈希冲突时，HashMap 的解决方法是将相同映射地址的元素连成一条 <code>链表</code>，如果链表的长度大于 <code>8</code> 时，且数组的长度大于 <code>64</code> 则会转换成 <code>红黑树</code> 数据结构。</p>\n<p> 关于 HashMap 的简要总结：</p>\n<ol>\n<li>它是集合中最常用的 <code>Map</code> 集合类型，底层由 <code>数组 + 链表 + 红黑树</code> 组成</li>\n<li>HashMap 不是线程安全的</li>\n<li>插入元素时，通过计算元素的 <code>哈希值</code>，通过 <strong>哈希映射函数</strong> 转换为 <code>数组下标</code>；查找元素时，同样通过哈希映射函数得到数组下标 <code>定位元素的位置</code></li>\n</ol>\n<h3 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h3><p>LinkedHashMap 可以看作是 <code>HashMap</code> 和 <code>LinkedList</code> 的结合：它在 HashMap 的基础上添加了一条双向链表，<code>默认</code> 存储各个元素的插入顺序，但由于这条双向链表，使得 LinkedHashMap 可以实现 <code>LRU</code> 缓存淘汰策略，因为我们可以设置这条双向链表按照 <code>元素的访问次序</code> 进行排序</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530175812.png\" alt=\"image-20210530175812409\"></p>\n<p>LinkedHashMap 是 HashMap 的子类，所以它具备 HashMap 的所有特点，其次，它在 HashMap 的基础上维护了一条 <code>双向链表</code>，该链表存储了 <strong>所有元素</strong>，<code>默认</code> 元素的顺序与插入顺序 <strong>一致</strong>。若 <code>accessOrder</code> 属性为 <code>true</code> ，则遍历顺序按元素的访问次序进行排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 头节点</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class=\"line\"><span class=\"comment\">// 尾节点</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure>\n\n<p>利用 LinkedHashMap 可以实现 <code>LRU</code> 缓存淘汰策略，因为它提供了一个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该方法可以移除 <code>最靠近链表头部</code> 的一个节点，而在 <code>get()</code> 方法中可以看到下面这段代码，起作用是挪动节点的位置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (accessOrder)&#123;</span><br><span class=\"line\">    afterNodeAccess(e);</span><br><span class=\"line\">&#125;      </span><br></pre></td></tr></table></figure>\n\n<p>只要调用了 <code>get()</code> 且 <code>accessOrder = true</code>，则会将该节点更新到链表 <code>尾部</code>，具体的逻辑在 <code>afterNodeAccess()</code> 中，感兴趣可翻看源码，这里不再展开：</p>\n<p>如果现在要实现一个 <code>LRU</code> 缓存策略，则需要做两件事：</p>\n<ul>\n<li>指定 <code>accessOrder = true</code> 可以设定链表按照访问顺序排列，通过提供的构造器可以设定 <code>accessOrder</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashMap</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity,<span class=\"type\">float</span> loadFactor,<span class=\"type\">boolean</span> accessOrder)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(initialCapacity, loadFactor);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.accessOrder = accessOrder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重写 <code>removeEldestEntry()</code> 方法，内部定义逻辑，通常是判断 <code>容量</code> 是否达到上限，若是则执行淘汰。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/qq_41231926/article/details/86173740\">LeetCode146——LRU缓存机制</a></p>\n</blockquote>\n<p>-关于 LinkedHashMap 主要介绍两点：</p>\n<ol>\n<li>它底层维护了一条 <code>双向链表</code>，因为继承了 HashMap，所以它也不是线程安全的</li>\n<li>LinkedHashMap 可实现 <code>LRU</code> 缓存淘汰策略，其原理是通过设置 <code>accessOrder</code> 为 <code>true</code> 并重写 <code>removeEldestEntry</code> 方法定义淘汰元素时需满足的条件</li>\n</ol>\n<h3 id=\"TreeMap\"><a href=\"#TreeMap\" class=\"headerlink\" title=\"TreeMap\"></a>TreeMap</h3><p>TreeMap 的底层实现是红黑树！</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530183426.png\" alt=\"image-20210530183425914\"></p>\n<p>TreeMap 是 <code>SortedMap</code> 的子类，所以它具有 排序 功能。它是基于 红黑树 数据结构实现的，每一个键值对 <code>&lt;key,value&gt;</code> 都是一个节点，默认情况下按照 <code>key</code> 自然排序，另一种是可以通过传入定制的 <code>Comparator</code> 进行自定义规则排序</p>\n<p>图中红黑树的每一个节点都是一个 <code>Entry</code> ，在这里为了图片的简洁性，就不标明 key 和 value 了，注意这些元素都是已经按照 <code>key</code> 排好序了，整个数据结构都是保持着 <code>有序</code> 的状态！</p>\n<p>关于 <code>自然</code> 排序与 <code>定制</code> 排序：</p>\n<ul>\n<li>自然排序：要求 <code>key</code> 必须实现 <code>Comparable</code> 接口。</li>\n</ul>\n<p>由于 <code>Integer</code> 类实现了 Comparable 接口，按照自然排序规则是按照 <code>key</code> 从小到大排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TreeMap&lt;Integer,String&gt; treeMap = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;&gt;();</span><br><span class=\"line\">treeMap.put(<span class=\"number\">2</span>,<span class=\"string\">&quot;TWO&quot;</span>);</span><br><span class=\"line\">treeMap.put(<span class=\"number\">1</span>,<span class=\"string\">&quot;ONE&quot;</span>);</span><br><span class=\"line\">System.out.print(treeMap);</span><br><span class=\"line\"><span class=\"comment\">// &#123;1=ONE,2=TWO&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定制排序：在初始化 TreeMap 时传入新的 <code>Comparator</code>，不要求 <code>key</code> 实现 Comparable 接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TreeMap&lt;Integer,String&gt; treeMap = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;&gt;((o1,o2) -&gt; Integer.compare(o2,o1));</span><br><span class=\"line\">treeMap.put(<span class=\"number\">2</span>,<span class=\"string\">&quot;TWO&quot;</span>);</span><br><span class=\"line\">treeMap.put(<span class=\"number\">1</span>,<span class=\"string\">&quot;ONE&quot;</span>);</span><br><span class=\"line\">treeMap.put(<span class=\"number\">3</span>,<span class=\"string\">&quot;Three&quot;</span>);</span><br><span class=\"line\">treeMap.put(<span class=\"number\">4</span>,<span class=\"string\">&quot;Four&quot;</span>);</span><br><span class=\"line\">System.out.print(treeMap);</span><br><span class=\"line\"><span class=\"comment\">// &#123;4=Four, 3=Three, 2=TWO, 1=ONE&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过传入新的 <code>Comparator</code> 比较器，可以覆盖默认的排序规则，上面的代码按照 <code>key</code> 降序排序，在实际应用中还可以按照其它规则自定义排序。</p>\n<p><code>compare()</code> 方法的返回值有三种，分别是：<code>0</code>，<code>-1</code>，<code>+1</code></p>\n<p>（1）如果返回 <code>0</code> ，代表两个元素相等，不需要调换顺序</p>\n<p>（2）如果返回 <code>+1</code> ，代表前面的元素需要与后面的元素调换位置</p>\n<p>（3）如果返回 <code>-1</code> ，代表前面的元素不需要与后面的元素调换位置</p>\n<p>而何时返回 <code>+1</code> 和 <code>-1</code>，则由我们自己去定义，JDK默认是按照 <strong>自然排序</strong>，而我们可以根据 <code>key</code> 的不同去定义降序还是升序排序。</p>\n<p>关于 TreeMap 主要介绍了两点：</p>\n<ol>\n<li>它底层是由 <code>红黑树</code> 这种数据结构实现的，所以操作的时间复杂度恒为 <code>0(logN)</code></li>\n<li>TreeMap 可以对 <code>key</code> 进行自然排序或者自定义排序，自定义排序时需要传入 <code>Comparator</code>，而自然排序要求 <code>key</code>实现了 <code>Comparable</code> 接口</li>\n<li>TreeMap 不是线程安全的。</li>\n</ol>\n<h3 id=\"WeakHashMap\"><a href=\"#WeakHashMap\" class=\"headerlink\" title=\"WeakHashMap\"></a>WeakHashMap</h3><p>WeakHashMap 日常开发中比较少见，它是基于普通的 <code>Map</code> 实现的，而里面 <code>Entry</code> 中的键在每一次的 <code>垃圾回收</code> 都会被清除掉，所以非常适合用于 <strong>短暂访问</strong>、<strong>仅访问一次</strong> 的元素，缓存在 <code>WeakHashMap</code> 中，并尽早地把它回收掉。</p>\n<p>当 <code>Entry</code> 被 <code>GC</code> 时，WeakHashMap 是如何感知到某个元素被回收的呢？</p>\n<p>在 WeakHashMap 内部维护了一个引用队列 <code>queue</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;Object&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>这个 queue 里包含了所有被 <code>GC</code> 掉的键，当JVM开启 <code>GC</code> 后，如果回收掉 WeakHashMap 中的 key，会将 key 放入 queue 中，在 <code>expungeStaleEntries()</code> 中遍历 queue，把 queue 中的所有 <code>key</code> 拿出来，并在 WeakHashMap 中删除掉，以达到 <strong>同步</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expungeStaleEntries</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"literal\">null</span>; ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 删除 WeakHashMap 中的该键值对</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是 WeakHashMap 底层存储的元素的数据结构是 <code>数组 + 链表</code>，<strong>没有红黑树</strong>哦，可以换一个角度想，如果还有红黑树，那干脆直接继承 HashMap ，然后再扩展不就行了，然而它并没有这样做：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakHashMap</span>&lt;K,V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractMap</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Map</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，WeakHashMap 的数据结构图如下：</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530211807.png\" alt=\"image-20210530211807636\"></p>\n<p>图中被虚线标识的元素将会在下一次访问 WeakHashMap 时删除掉，WeakHashMap 内部会做好一系列的调整工作，所以记住队列的作用就是标志那些已经被 <code>GC</code> 回收掉的元素。</p>\n<p>关于 WeakHashMap 需要注意两点：</p>\n<ol>\n<li>它的键是一种 <code>弱键</code>，放入 WeakHashMap 时，随时会被回收掉，所以不能确保某次访问元素一定存在</li>\n<li>它依赖普通的 <code>Map</code> 进行实现，是一个非线程安全的集合</li>\n<li>WeakHashMap 通常作为 <strong>缓存</strong> 使用，适用存储那些 <code>只需访问一次</code>、或 <code>只需保存短暂时间</code> 的键值对</li>\n</ol>\n<h3 id=\"HashTable\"><a href=\"#HashTable\" class=\"headerlink\" title=\"HashTable\"></a>HashTable</h3><p>HashTable 底层的存储结构是 <code>数组 + 链表</code>，而它是一个 <strong>线程安全</strong> 的集合，但是因为这个线程安全，它就被淘汰掉了。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530213300.png\" alt=\"image-20210530213300809\"></p>\n<blockquote>\n<p>这幅图是否有点眼熟呢哈哈哈，其实本质上就是 WeakHashMap 的底层存储结构。那么为什么 WeakHashMap 不继承 HashTable 呢？HashTable 的 <code>性能</code> 在并发环境下是非常差的，在非并发环境下可以用 <code>HashMap</code> 更优。</p>\n</blockquote>\n<p>HashTable 本质上是 HashMap 的前辈，它被淘汰的原因也主要因为两个字：<strong>性能</strong></p>\n<p>HashTable 是一个 <strong>线程安全</strong> 的Map，它所有的方法都被加上了 <strong>synchronized</strong> 关键字，也是因为这个关键字，它注定成为了时代的弃儿。</p>\n<p>HashTable 底层采用 数组+链表 存储键值对，由于被弃用，后人也没有对它进行任何改进</p>\n<p>HashTable 默认长度为 <code>11</code>，负载因子为 <code>0.75f</code>，即元素个数达到数组长度的 75% 时，会进行一次扩容，每次扩容为原来数组长度的 <code>2</code> 倍</p>\n<p>HashTable 所有的操作都是线程安全的。</p>\n<h2 id=\"Collection-集合体系详解\"><a href=\"#Collection-集合体系详解\" class=\"headerlink\" title=\"Collection 集合体系详解\"></a>Collection 集合体系详解</h2><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530222445.png\" alt=\"image-20210530222444963\"></p>\n<h3 id=\"Set-接口\"><a href=\"#Set-接口\" class=\"headerlink\" title=\"Set 接口\"></a>Set 接口</h3><p><code>Set</code> 接口继承了 <code>Collection</code> 接口，是一个不包括重复元素的集合，更确切地说，Set 中任意两个元素不会出现 <code>o1.equals(o2)</code>，而且 Set <strong>至多</strong> 只能存储一个 <code>NULL</code> 值元素，Set 集合的组成部分可以用下面这张图概括：</p>\n<img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530225016.png\" alt=\"image-20210530225016622\" style=\"zoom: 50%;\" />\n\n<p>在 Set 集合体系中，我们需要关注两点：</p>\n<ul>\n<li>存入 <strong>可变元素</strong> 时，必须非常小心，因为任意时候元素状态的改变都有可能使得 Set 内部出现两个 <strong>相等</strong> 的元素，即 <code>o1.equals(o2) = true</code>，所以一般不要更改存入 Set 中的元素，否则将会破坏了 <code>equals()</code>  的作用！</li>\n<li>Set 的最大作用就是判重，在项目中的最大的作用也是 <strong>判重</strong>！</li>\n</ul>\n<p>接下来我们来分析它的实现类和子类：<code>AbstractSet</code> 和 <code>SortedSet</code></p>\n<h4 id=\"AbstractSet-抽象类\"><a href=\"#AbstractSet-抽象类\" class=\"headerlink\" title=\"AbstractSet 抽象类\"></a>AbstractSet 抽象类</h4><p><code>AbstractSet</code> 是一个实现 Set 的一个抽象类，定义在这里的方法可以将所有具体 Set 集合的 <strong>相同行为</strong> 在这里实现，<strong>避免子类包含大量的重复代码</strong></p>\n<p>所有的 Set 也应该要有相同的 <code>hashCode()</code> 和 <code>equals()</code> 方法，所以使用抽象类把该方法重写后，子类就无需关心这两个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractSet</span>&lt;E&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Set</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断两个 set 是否相等</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"built_in\">this</span>) <span class=\"comment\">// 集合本身</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> Set)) <span class=\"comment\">// 集合不是 set</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        Collection&lt;?&gt; c = (Collection&lt;?&gt;) o; <span class=\"comment\">// 比较两个集合中的元素是否全部相同</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c.size() != size())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> containsAll(c);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassCastException unused)   &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NullPointerException unused) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 计算所有元素的 hashcode 总和</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Iterator&lt;E&gt; i = iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">E</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (obj != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                h += obj.hashCode();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SortedSet-接口\"><a href=\"#SortedSet-接口\" class=\"headerlink\" title=\"SortedSet 接口\"></a>SortedSet 接口</h4><p><code>SortedSet</code> 是一个接口，它在 Set 的基础上扩展了 <strong>排序</strong> 的行为，所以所有实现它的子类都会拥有排序功能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">SortedSet</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Set</span>&lt;E&gt; &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 元素的比较器，决定元素的排列顺序</span></span><br><span class=\"line\">    Comparator&lt;? <span class=\"built_in\">super</span> E&gt; comparator();</span><br><span class=\"line\">\t<span class=\"comment\">// 获取 [from,to] 之间的 set</span></span><br><span class=\"line\">    SortedSet&lt;E&gt; <span class=\"title function_\">subSet</span><span class=\"params\">(E fromElement, E toElement)</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取以 to 开头的 set</span></span><br><span class=\"line\">    SortedSet&lt;E&gt; <span class=\"title function_\">headSet</span><span class=\"params\">(E toElement)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取以 from 结尾的 set</span></span><br><span class=\"line\">    SortedSet&lt;E&gt; <span class=\"title function_\">tailSet</span><span class=\"params\">(E fromElement)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取首个元素</span></span><br><span class=\"line\">    E <span class=\"title function_\">first</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取最后一个元素</span></span><br><span class=\"line\">    E <span class=\"title function_\">last</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h4><p>HashSet 底层是借助 <code>HashMap</code> 实现，我们可以观察它的多个构造方法，本质上都是 new 一个 HashMap</p>\n<blockquote>\n<p>这也是为什么我们先学习 Map 的原因！先学 Map ，再学 Set，有助于理解 Set ！</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HashSet</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractSet</span>&lt;E&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity, <span class=\"type\">float</span> loadFactor)</span> &#123;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以观察 <code>add()</code> 和 <code>remove()</code> 方法是如何将 HashSet 的操作嫁接到 HashMap 上的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">PRESENT</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">remove</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.remove(o)==PRESENT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到 <code>PRESENT</code> 就是一个 <strong>静态常量</strong> ：使用 PRESENT 作为 HashMap 的 value 值，使用 HashSet 的开发者只需要 <strong>关注</strong>  插入的 <code>key</code>，<strong>屏蔽</strong> 了 HashMap 的 <code>value</code></p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602103919.png\" alt=\"image-20210602103912091\"></p>\n<p>上图可以观察到每个 <code>Entry</code> 的 <code>value</code> 都是 PRESENT 空对象，我们就不用理会它了。</p>\n<p>HashSet  在 HashMap 基础上实现，所以很多地方可以联系到 HashMap：</p>\n<ul>\n<li>底层数据结构：HashSet 也是采用 <code>数组 + 链表 + 红黑树</code> 实现</li>\n<li>线程安全性：由于采用 HashMap 实现，而 HashMap 本身线程不安全，在 HashSet 中又没有额外添加同步策略，所以 HashSet 也 <strong>线程不安全</strong></li>\n<li>存入 HashSet 的对象的状态 <strong>最好不要发生变化</strong>，因为有可能改变状态后，在集合内部出现两个元素 <code>o1.equals(o2) == true</code>，破坏了 <code>equals</code> 的含义。</li>\n</ul>\n<h4 id=\"LinkedHashSet\"><a href=\"#LinkedHashSet\" class=\"headerlink\" title=\"LinkedHashSet\"></a>LinkedHashSet</h4><p>LinkedHashSet 的代码很少，不信我给你粘出来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LinkedHashSet</span>&lt;E&gt;</span><br><span class=\"line\">    <span class=\"keyword\">extends</span> <span class=\"title class_\">HashSet</span>&lt;E&gt;</span><br><span class=\"line\">    <span class=\"keyword\">implements</span> <span class=\"title class_\">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> -<span class=\"number\">2851667679971038690L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashSet</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity, <span class=\"type\">float</span> loadFactor)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(initialCapacity, loadFactor, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Link\t<span class=\"title function_\">edHashSet</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(initialCapacity, <span class=\"number\">.75f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(<span class=\"number\">16</span>, <span class=\"number\">.75f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashSet</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(Math.max(<span class=\"number\">2</span>*c.size(), <span class=\"number\">11</span>), <span class=\"number\">.75f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        addAll(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Spliterator&lt;E&gt; <span class=\"title function_\">spliterator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Spliterators.spliterator(<span class=\"built_in\">this</span>, Spliterator.DISTINCT | Spliterator.ORDERED);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码少归少，还是得分析一下，<code>LinkedHashSet</code> 继承了 <code>HashSet</code>，我们跟随到父类 HashSet 的构造方法看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashSet(<span class=\"type\">int</span> initialCapacity, <span class=\"type\">float</span> loadFactor, <span class=\"type\">boolean</span> dummy) &#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现父类中 map 的实现采用 <code>LinkedHashMap</code> ，这里注意不是 <code>HashMap</code> ，而 LinkedHashMap 底层又采用 HashMap + 双向链表 实现的，所以本质上 LinkedHashSet 还是使用 HashMap 实现的。</p>\n<blockquote>\n<p>LinkedHashSet -&gt; LinkedHashMap -&gt; HashMap + 双向链表</p>\n</blockquote>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602125701.png\" alt=\"image-20210602125701765\"></p>\n<p>而 LinkedHashMap 是采用 <code>HashMap</code> + <code>双向链表</code> 实现的，这条双向链表中保存了元素的插入顺序。所以 LinkedHashSet 可以按照元素的插入顺序遍历元素，如果你熟悉 <code>LinkedHashMap</code> ，那么 LinkedHashSet 也就不在话下了。</p>\n<p>关于 LinkedHashSet 需要注意的几个地方：</p>\n<ul>\n<li>它继承于 <code>HashSet</code>，而 HashSet 默认是采用 HashMap 存储数据的，但是 LinkedHashSet 调用父类的构造方法初始化 map 时是 LinkedHashMap 而不是 HashMap </li>\n<li>由于 LinkedHashMap 不是线程安全的，且在 LinkedHashSet 中没有添加额外的同步策略，所以 LinkedHashSet 集合<strong>也不是线程安全</strong> 的</li>\n</ul>\n<h4 id=\"TreeSet\"><a href=\"#TreeSet\" class=\"headerlink\" title=\"TreeSet\"></a>TreeSet</h4><p>TreeSet 是基于 TreeMap 的实现，所以存储的元素是有序的，底层的数据结构是 <code>数组 + 红黑树</code>。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602131111.png\" alt=\"image-20210602131111383\"></p>\n<p>而元素的排列顺序有 <code>2</code> 种，和 TreeMap 相同：自然排序和定制排序，常用的构造方法在下面已经展现出来了，TreeSet 默认使用自然排序，如果需要使用定制排序，需要传入 <code>Comparator</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">TreeSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;E,Object&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">TreeSet</span><span class=\"params\">(Comparator&lt;? <span class=\"built_in\">super</span> E&gt; comparator)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;&gt;(comparator));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于 TreeSet ，有几个值得注意的点：</p>\n<ul>\n<li><p>TreeSet 的所有操作都会转换为对 TreeMap 的操作，TreeMap 采用 <strong>红黑树</strong> 实现，任意操作的 <strong>时间复杂度</strong> 为 <code>0(logN)</code></p>\n</li>\n<li><p>TreeSet 是一个 <strong>线程不安全</strong> 的集合</p>\n</li>\n<li><p>TreeSet 常用于对 <strong>不重复</strong> 的元素 <strong>定制排序</strong>，如玩家战斗力排行榜</p>\n</li>\n</ul>\n<blockquote>\n<p>注意：TreeSet 判断元素是否重复的方法是判断 <strong>compareTo()</strong> 方法是否返回0，而不是调用 <strong>hashCode()</strong> 和 <strong>equals()</strong> 方法，如果返回 0 则认为集合内已存在相同的元素，不会再加入到集合当中。</p>\n</blockquote>\n<h3 id=\"List-接口\"><a href=\"#List-接口\" class=\"headerlink\" title=\"List 接口\"></a>List 接口</h3><p>List 接口和 Set 接口齐头并进，是我们日常开发过程中接触很多的一种集合类型了。整个 List 集合的组成部分如下图：</p>\n<img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602133220.png\" alt=\"image-20210602133220362\" style=\"zoom:50%;\" />\n\n<p><code>List</code> 接口直接继承于 Collection 接口，它定义为可以存储 <strong>重复</strong> 元素的集合，并且元素按照插入顺序 <strong>有序排列</strong>，且可以通过 <strong>索引</strong>访问指定位置的元素。常见的实现有：ArrayList、linkedList、Vector 和 Stack</p>\n<h4 id=\"AbstractList-和-AbstractSequentialList\"><a href=\"#AbstractList-和-AbstractSequentialList\" class=\"headerlink\" title=\"AbstractList 和 AbstractSequentialList\"></a>AbstractList 和 AbstractSequentialList</h4><p>AbstractList 抽象类实现了 List 接口，其内部实现了所有的 List 都需具备的功能，子类可以专注于实现自己具体的操作逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找元素 o 第一次出现的位置</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">indexOf</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">    ListIterator&lt;E&gt; it = listIterator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext())</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (it.next()==<span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> it.previousIndex();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext())</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(it.next()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> it.previousIndex();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找元素 o 最后一次出现的位置</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lastIndexOf</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">     ListIterator&lt;E&gt; it = listIterator(size());</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (o==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">while</span> (it.hasPrevious())</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (it.previous()==<span class=\"literal\">null</span>)</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> it.nextIndex();</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">while</span> (it.hasPrevious())</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (o.equals(it.previous()))</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> it.nextIndex();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>AbstractSequentialList 抽象类继承了 AbstractList ，在原基础上限制了访问元素的顺序 <strong>只能够按照顺序访问</strong>，而 <strong>不支持随机访问</strong>，如果需要满足随机访问的特性，则继承 AbstractList。子类 LinkedList 使用链表实现，所以仅能支持 <strong>顺序访问</strong>，故继承了 <code>AbstractSequentialList</code> 而不是 AbstractList。</p>\n<h4 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h4><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602140414.png\" alt=\"image-20210602140414443\"></p>\n<p><code>Vector</code> 在现在已经是一种过时的集合了，包括继承它的 <code>Stack</code> 集合也是如此，它们被淘汰的原因都是因为 <strong>性能</strong> 低下。</p>\n<blockquote>\n<p>JDK 1.0 时代，ArrayList 还没诞生，大家都是使用 Vector 集合，但由于 Vector 的 <strong>每个操作</strong> 都被 <strong>synchronized</strong> 关键字修饰，即使在线程安全的情况下， 仍然 <strong>进行着无意义的加锁/释放锁</strong>，造成额外的性能开销，做了无用功。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在 JDK 1.2 时，Collection 家族出现了，它提供了大量 <strong>高性能、适用于不同场合</strong> 的集合，而 Vector 也是其中一员，但由于 Vector 在每个方法上都加了锁，并且需要兼容许多的老项目，很难在这基础上优化 <code>Vector</code> 了，所以渐渐地也就被历史淘汰了。</p>\n<p>现在，在 <strong>线程安全</strong> 的情况下，不要选用 Vector 集合，取而代之的是 <strong>ArrayList</strong> 集合；在并发环境下，出现了 <code>CopyOnWriteArrayList</code>，Vector 被完全弃用了。</p>\n<h4 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h4><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602142433.png\" alt=\"image-20210602142433141\"></p>\n<p><code>Stack</code> 是一种 <code>后入先出（LIFO）</code> 型的集合容器，如图所示，<code>大雄</code> 是最后一个进入容器的，top 指针指向大雄，那么弹出元素时，大雄也是第一个被弹出去的。</p>\n<p>Stack 继承了 Vector 类，提供了栈顶的压入元素操作（push）和弹出元素（pop），以及查看栈顶元素（peek）等等，但由于继承于 Vector，Stack 也渐渐被淘汰了。</p>\n<p>取而代之的是后起之秀 <code>Deque</code> 接口，其实现有 <code>ArrayDeque</code>，该数据结构更加完善，可靠性更好，依靠队列也可以实现 <code>LIFO</code> 的栈操作，所以优先选择 ArrayDeque 实现栈。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deque&lt;Integer&gt; stact = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>ArrayDeque 的数据结构是：<code>数组</code> ，并提供 <strong>头尾指针下标</strong> 对数组元素进行操作。本文也会在接下来的内容中讲到，请接着往下看！</p>\n<h4 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h4><p>ArrayList 以 <strong>数组</strong> 作为存储结构，它是 <strong>线程不安全</strong> 的集合；具有 <strong>查询快、在数组中或头部增删慢</strong> 的特点，所以它除了线程不安全这一点，其余可以替代 <code>Vector</code> ，而且线程安全的 ArrayList 可以使用 <code>CopyOnWriteArrayList</code> 代替 Vector。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210603085739.png\" alt=\"image-20210603085732114\"></p>\n<p>关于 ArrayList 有几个重要的点需要注意：</p>\n<ul>\n<li>具有 <strong>随机访问</strong> 特点，<strong>访问元素的效率</strong> 较高，ArrayList 在 <strong>频繁插入、删除</strong> 集合元素的场景下效率较 <code>低</code></li>\n<li>底层数据结构：ArrayList 底层是使用数组作为存储结构，具有 <strong>查找快、增删慢</strong> 的特点</li>\n<li>线程安全性：ArrayList 是 <strong>线程不安全</strong> 的集合</li>\n<li>ArrayList <strong>首次扩容</strong> 后的长度为 <code>10</code>，调用 <code>add()</code> 时需要将计算容器 的最小容量。可以看到如果数组 <code>elementData</code> 为空数组，会将最小容量设置为 <code>10</code>，之后会将数组长度完成首次扩容到 10。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new ArrayList 时的默认空数组</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 默认容量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 计算该容器满足的最小容量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>集合从 <strong>第二次扩容</strong> 开始，数组长度将扩容为原来的 <code>1.5</code> 倍，即：<code>newLength = oldLength * 1.5</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h4><p>LinkedList 底层采用 <code>双向链表</code> 数据接口存储元素，由于链表的内存地址 <code>非连续</code>，所以它不具备随机访问的特点，但由于它利用指针连接各个元素，所以插入、删除元素只需要 <code>操作指针</code>，不需要 <code>移动元素</code>，故具有 <strong>增删快、查询慢</strong> 的特点。它也是一个非线程安全的集合。</p>\n<img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626130625.png\" alt=\"image-20210626130618786\"  />\n\n<p>由于以双向链表作为数据结构，它是 <strong>线程不安全</strong> 的集合；存储的每个节点称为一个 <code>Node</code> ，下图可以看到 Node 中保存了 <code>next</code> 和 <code>prev</code> 指针，<code>item</code> 是该节点的值。在插入和删除时，时间复杂度都保持为 <code>0(1)</code></p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626131638.png\" alt=\"image-20210626131638144\"></p>\n<p>关于 LinkedList，除了它是以链表实现的集合外，还有一些特殊的地方需要注意：</p>\n<ul>\n<li><p>优势：LinkedList 底层没有 <code>扩容机制</code>，使用 <code>双向链表</code> 存储元素，所以插入和删除元素效率较高，适用于频繁操作元素的场景</p>\n</li>\n<li><p>劣势：LinkedList 不具备 <code>随机访问</code> 的特点，查找某个元素只能从 <code>head</code> 或 <code>tail</code> 指针一个一个比较，所以 <strong>查找中间元素是效率很低</strong></p>\n</li>\n<li><p>查找优化：LinkedList 查找某个下标 <code>index</code> 的元素时做了优化，若 <code>index &lt; (size / 2)</code>，则从 <code>head</code> 往后查找，否则从 <code>tail</code> 开始往前查找，代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node&lt;E&gt; <span class=\"title function_\">node</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123; <span class=\"comment\">// 查找的下标处于链表的前半部分则从头开始找</span></span><br><span class=\"line\">        Node&lt;E&gt; x = first;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">// 查找的下标处于链表的后半部分则从尾开始找</span></span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>双端队列：使用双链表实现，并且实现了 <code>Deque</code> 接口，使得 LinkedList 可以用作 <strong>双端队列</strong> 。下图可以看到 Node 是集合中的元素，提供了前驱指针和后继指针，还提供了一系列操作 <code>头结点</code> 和 <code>尾结点</code> 的方法，具有双端队列的特性。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626133733.png\" alt=\"image-20210626133733427\">    </p>\n</li>\n</ul>\n<h3 id=\"Queue-接口\"><a href=\"#Queue-接口\" class=\"headerlink\" title=\"Queue 接口\"></a>Queue 接口</h3><p><code>Queue</code> 队列，在 JDK 中两种不同类型的集合实现： <strong>单向队列</strong>（AbstractQueue）和 <strong>双端队列</strong>（Deque）</p>\n<img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626152155.png\" alt=\"image-20210626152154946\" style=\"zoom:80%;\" />    \n\n<p>Queue 中提供了两套增加、删除元素的 API，当插入或删除元素失败时，会有两种不同的失败处理策略。</p>\n<table>\n<thead>\n<tr>\n<th>方法及失败策略</th>\n<th>插入方法</th>\n<th>删除方法</th>\n<th>查找方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>抛出异常</td>\n<td>add()</td>\n<td>remove()</td>\n<td>get()</td>\n</tr>\n<tr>\n<td>返回失败默认值</td>\n<td>offer()</td>\n<td>poll()</td>\n<td>peek()</td>\n</tr>\n</tbody></table>\n<p>选区哪种方法的决定因素：插入和删除元素失败时，希望 <code>抛出异常</code> 还是返回 <code>布尔值</code> </p>\n<p><code>add()</code> 和 <code>offer()</code> 对比：</p>\n<p>在队列长度大小确定的场景下，队列放满元素后，添加下一个元素时，add() 会抛出 <code>IllegalStateException</code> 异常，而 <code>offer()</code> 会返回 <code>false</code>。</p>\n<p>但是他们两个方法在插入 <strong>某些不合法的元素</strong> 时会抛出三个相同的异常：</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626153333.png\" alt=\"image-20210626153333747\">    </p>\n<p><code>remove()</code> 和 <code>poll()</code> 对比：</p>\n<p>在 <strong>队列为空</strong> 的场景下：<code>remove()</code> 会抛出 <code>NoSuchElmentException</code> 异常，而 <code>poll()</code> 则返回 <code>null</code>。</p>\n<p><code>get()</code> 和 <code>peek()</code> 对比：</p>\n<p>在队列为空的情况，<code>get()</code> 会抛出 <code>NoSuchElementException</code> 异常，而 <code>peek()</code> 则返回 <code>null</code>。</p>\n<h3 id=\"Deque-接口\"><a href=\"#Deque-接口\" class=\"headerlink\" title=\"Deque 接口\"></a>Deque 接口</h3><p><code>Deque</code> 接口的实现非常好理解：从 <strong>单向</strong> 队列演变为 <strong>双向</strong> 队列，内部额外提供 <strong>双向队列的操作方法</strong> 即可：</p>\n<img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626161113.png\" alt=\"image-20210626161106057\" style=\"zoom:80%;\" />    \n\n<p>Deque 接口额外提供了 <strong>针对队列的头结点和尾结点</strong> 操作的方法，而 <strong>插入、删除方法同样也提供了两套不同的失败策略</strong>。</p>\n<p>除了 <code>add()</code> 和 <code>offer()</code> ，<code>remove()</code> 和 <code>poll()</code> 以外，还有 <code>get()</code> 和 <code>peek()</code> 出现了不同的策略</p>\n<h4 id=\"AbstractQueue-抽象类\"><a href=\"#AbstractQueue-抽象类\" class=\"headerlink\" title=\"AbstractQueue 抽象类\"></a>AbstractQueue 抽象类</h4><p>AbstractQueue 类中提供了各个 API 的基本实现，主要针对各个不同的处理策略给出基本的方法实现，定义在这里的作用让 <code>子类</code> 根据其 <code>方法规范</code> （操作失败时抛出异常还是返回默认值）实现具体的业务逻辑。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626162155.png\" alt=\"image-20210626162155775\">    </p>\n<h4 id=\"LinkedList-1\"><a href=\"#LinkedList-1\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h4><p>LinkedList 在上面已经详细解释了，它实现了 <code>Deque</code> 接口，提供了针对头结点和尾结点的操作，并且每个结点都有 <strong>前驱</strong> 和 <strong>后继</strong> 指针，具备双向队列的所有特性。</p>\n<h4 id=\"ArrayDeque\"><a href=\"#ArrayDeque\" class=\"headerlink\" title=\"ArrayDeque\"></a>ArrayDeque</h4><p>使用 <strong>数组</strong> 实现的双端队列，它是 <strong>无界</strong> 的双端队列，最小的容量是 <code>8</code> （JDK1.8）。在 JDK11 之后看到它默认容量已经是 <code>16</code> 了。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210702150910.png\" alt=\"image-20210702150909935\"></p>\n<p><code>ArrayDeque</code> 在日常使用得不多，值得注意的是它与 <code>LinkedList</code> 的对比：<code>LinkedList</code> 采用链表实现双端队列，而 <code>ArrayDeque</code> 使用 <strong>数组</strong> 实现双端队列。</p>\n<blockquote>\n<p>在文档中作者写到：ArrayDeque 作为栈时比 Stack 性能好，作为队列时比  LinkedList 性能好</p>\n</blockquote>\n<p>由于双端队列 <strong>只能在头部和尾部</strong> 操作元素，所以删除元素和插入元素的时间复杂度大部分都稳定在 <code>0(1)</code>，除非在扩容时会涉及到元素的批量复制操作。但是在大多数情况下，使用它应该指定一个大概的数组长度，避免频繁的扩容。</p>\n<h4 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h4><p>PriorityQueue 基于 <strong>优先级堆实现</strong> 的优先级队列，而堆是采用 <strong>数组</strong> 实现的：</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210702153102.png\" alt=\"image-20210702153102716\"></p>\n<p>文档中的描述告诉我们：该数组中的元素通过传入 <code>Comparator</code> 进行定制排序，如果不传入 <code>Comparator</code> 时，则按照元素本身 <code>自然排序</code>，但要求元素实现了 <code>Comparable</code> 接口，所以 PriorityQueue  <strong>不允许存储 NULL 元素</strong>。</p>\n<p>PriorityQueue 应用场景：元素本身具有优先级，需要按照 <strong>优先级处理元素</strong> </p>\n<p>PriorityQueue 总结：</p>\n<ul>\n<li>PriorityQueue 是基于 <strong>优先级堆</strong> 实现的优先级队列，而堆是用 <strong>数组</strong> 维护的</li>\n<li>PriorityQueue 适用于 <strong>元素按优先级处理</strong> 的业务场景，例如用户在请求人工客服需要排队时，根据用户的 <strong>VIP等级</strong> 进行 <code>插队</code> 处理，等级越高，越先安排客服。</li>\n</ul>\n<p>各集合总结：（以 JDK1.8 为例）</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210702155305.png\" alt=\"image-20210702155305221\"></p>\n","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文记录了Java中的集合框架，文章中的内容摘录自<a href=\"https://www.runoob.com/java/java-collections.html\">Java 集合框架 | 菜鸟教程 (runoob.com)</a>、CSDN、博客园等开源网站。</p>\n<h2 id=\"Java-集合体系\"><a href=\"#Java-集合体系\" class=\"headerlink\" title=\"Java 集合体系\"></a>Java 集合体系</h2><p>Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 <a href=\"https://www.runoob.com/java/java-arraylist.html\">ArrayList</a>、<a href=\"https://www.runoob.com/java/java-linkedlist.html\">LinkedList</a>、<a href=\"https://www.runoob.com/java/java-hashset.html\">HashSet</a>、LinkedHashSet、<a href=\"https://www.runoob.com/java/java-hashmap.html\">HashMap</a>、LinkedHashMap 等等。</p>\n<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p>\n<ul>\n<li><strong>接口：</strong>是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li>\n<li><strong>实现（类）：</strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li>\n<li><strong>算法：</strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li>\n</ul>\n<img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210520211027.png\" alt=\"image-20210520211027579\" style=\"zoom: 50%;\" />\n\n<p>上图堪称集合框架的<strong>上帝视角</strong>，整个框架的组成部分：</p>\n<ol>\n<li>集合框架提供了两个遍历接口： <code>Iterator</code> 和 <code>ListIterator</code> ，其中后者是前者的 <code>优化版</code> ，支持在任意一个位置进行<strong>前后双向遍历</strong>。注意图中的 <code>Collection</code> 应当继承的是 <code>Iterable</code> 而不是 <code>Iterator</code> ，后面会解释 <code>Iterable</code> 和 <code>Iterator</code> 的区别</li>\n<li>整个集合框架分为两个门派（类型）：<code>Collection</code> 和 <code>Map</code>，前者是一个容器，存储一系列的<strong>对象</strong>；后者是键值对<code>&lt;key,value&gt;</code>，存储一系列的<strong>键值对</strong></li>\n<li>在集合框架体系下，衍生出四种具体的集合类型：<code>Map</code>、<code>Set</code>、<code>List</code>、<code>Queue</code></li>\n<li><code>Map</code> 存储 <code>&lt;key,value&gt;</code> 键值对，查找元素时通过 <code>key</code> 查找 <code>value</code></li>\n<li><code>Set</code> 内部存储一系列<strong>不可重复</strong>的对象，且是一个<strong>无序</strong>集合，对象排列顺序不一</li>\n<li><code>List</code> 内部存储一系列<strong>可重复</strong>的对象，是一个<strong>有序</strong>集合，对象按插入顺序排列</li>\n<li><code>Queue</code> 是一个队列容器，其特性与 <code>List</code> 相同，但只能从 <code>对头</code> 和 <code>队尾</code> 操作元素</li>\n<li>JDK为集合的各种操作提供了两个工具类 <code>Collections</code> 和 <code>Arrays</code> ，之后会讲解工具类的常用方法</li>\n<li>四种抽象集合类型内部也会衍生出许多具有不同特性的集合类，<strong>不同场景下择优使用，没有最佳的集合</strong></li>\n</ol>\n<h3 id=\"集合与数组的区别\"><a href=\"#集合与数组的区别\" class=\"headerlink\" title=\"集合与数组的区别\"></a>集合与数组的区别</h3><ul>\n<li><strong>长度区别：</strong><ul>\n<li>数组固定</li>\n<li>集合可变</li>\n</ul>\n</li>\n<li><strong>内容区别：</strong><ul>\n<li>数组可以是基本类型，也可以是引用类型</li>\n<li>集合只能是引用类型</li>\n</ul>\n</li>\n<li><strong>元素区别：</strong><ul>\n<li>数组只能存储同一种类型</li>\n<li>集合可以存储不同类型（其实集合一般也是存储同一种类型）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、Iterator-Iterable-ListIterator\"><a href=\"#二、Iterator-Iterable-ListIterator\" class=\"headerlink\" title=\"二、Iterator Iterable ListIterator\"></a>二、Iterator Iterable ListIterator</h3><p><code>Iterator</code> 和 <code>Iterable</code>，在第一次看这两个接口时，真以为是一摸一样的，没发现里面有啥不同，<strong>存在即合理</strong>，它们两个还是有本质区别的。</p>\n<p>首先来看 <code>Iterator</code> 接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Iterator</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">hasNext</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    E <span class=\"title function_\">next</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">remove</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>提供的API接口含义如下：</p>\n<ul>\n<li><code>hasNext()</code> ：判断集合中是否存在下一个对象</li>\n<li><code>next()</code> ：返回集合中的下一个对象，并将访问指针移动一位</li>\n<li><code>remove()</code> ：删除集合中调用 <code>next()</code> 方法返回的对象</li>\n</ul>\n<p>在早期，遍历集合的方式只有一种，通过 <code>Iterator</code> 迭代器操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">list.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">list.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">    System.out.println(next);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(next==<span class=\"number\">2</span>)&#123;iterator.remove();&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再来看 <code>Iterable</code> 接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Iterable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">\tIterator&lt;T&gt; <span class=\"title function_\">iterator</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">// JDK1.8</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(action);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (T t : <span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            action.accept(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 <code>Iterable</code> 接口里面提供了 <code>Iterator</code> 接口，所以实现了 <code>Iterable</code> 接口的集合依旧可以使用 <code>迭代器</code> 遍历和操作集合中的对象；</p>\n<p>而在 <code>JDK1.8</code> 中， <code>Iterable</code> 提供了一个新的方法 <code>forEach()</code> ，它允许使用增强 for 循环遍历对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Integer num : list)&#123;</span><br><span class=\"line\">    System.out.println(num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们通过反编译上面这段代码，发现它只是 Java 中的一个 <code>语法糖</code> ，本质上还是调用 <code>Iterator</code> 去遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Iterator</span> <span class=\"variable\">iter</span> <span class=\"operator\">=</span> list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(iter.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">    System.out.println(num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为什么要设计两个接口 <code>Iterable</code> 和 <code>Iterator</code> ，而不是保留其中一个就可以了。</p>\n<p>简单来说：<code>Iterator</code> 的保留可以让子类去实现自己的迭代器，而 <code>Iterable</code> 接口更加关注与 <code>for-each</code> 的增强语法。</p>\n</blockquote>\n<p><strong>总结：</strong></p>\n<ul>\n<li><code>Iterator</code> 是提供集合操作内部对象的一个迭代器，它可以 <strong>遍历</strong> 、<strong>移除</strong> 对象，且只能够 <strong>单向移动</strong></li>\n<li> <code>Iterable</code> 是对 <code>Iterator</code> 的封装，在<code>JDK 1.8</code> 时，实现了 <code>Iterable</code> 接口的结合可以使用 <strong>增强 for 循环</strong> 遍历集合对象，我们通过 <strong>反编译</strong> 后发现底层还是使用 <code>Iterator</code> 迭代器进行遍历</li>\n</ul>\n<p>等等，这一章还没完，还有一个 <code>ListIterator</code>。它继承 Iterator 接口，在遍历 <code>List</code> 集合时可以从 <strong>任意索引下标</strong> 开始遍历，而且支持 <strong>双向遍历</strong></p>\n<p> ListIterator 存在于 List 集合之中，通过调用方法可以返回 <strong>起始下标</strong> 为 <code>index</code> 的迭代器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">//返回下标为0的迭代器</span></span><br><span class=\"line\">ListIterator&lt;Integer&gt; listIter1 = list.listIterator();</span><br><span class=\"line\"><span class=\"comment\">//返回下标为5的迭代器</span></span><br><span class=\"line\">ListIterator&lt;Integer&gt; listIter2 = list.listIterator(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>ListIterator 中有几个重要方法，大多数方法与 Iterator 中定义的含义相同，但是 Iterator 强大的地方是可以在 <strong>任意一个下标位置</strong> 返回该迭代器，且可以实现 <strong>双向遍历</strong>。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ListIterator</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Iterator</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">hasNext</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    E <span class=\"title function_\">next</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">hasPrevious</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    E <span class=\"title function_\">previous</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">nextIndex</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">previousIndex</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">remove</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 替换当前下标的元素，即访问过的最后一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">set</span><span class=\"params\">(E e)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Map-和-Collection-接口\"><a href=\"#Map-和-Collection-接口\" class=\"headerlink\" title=\"Map 和 Collection 接口\"></a>Map 和 Collection 接口</h2><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530093805.png\" alt=\"image-20210530093758757\"></p>\n<p><code>Map</code> 接口定义了存储的数据结构是 <code>&lt;key,value&gt;</code> 形式，根据 key 映射到 value，一个 key 对应一个 value，所以 <code>key</code> 不可重复，而 <code>value</code> 可重复。</p>\n<p>在 <code>Map</code> 接口下会将存储的方式细分为不同的种类：</p>\n<ul>\n<li><code>SortedMap</code> 接口：该接口映射可以对 <code>&lt;key,value&gt;</code> 按照自己的规则进行 <strong>排序</strong>，具体实现有 TreeMap </li>\n<li><code>AbstractMap</code> 类：它为子类提供好一些 <strong>通用的API实现</strong>，所有的具体 Map 如 <code>HashMap</code> 都会继承它</li>\n</ul>\n<p>而 <code>Collection</code> 接口提供了所有集合的 <strong>通用方法</strong>（注意这里不包括 <code>Map</code>）：</p>\n<ul>\n<li>添加方法：<code>add(E e)</code> / <code>addAll(Collection&lt;? extends E&gt; c)</code></li>\n<li>删除方法：<code>remove(Object o)</code> / <code>removeAll(Collection&lt;?&gt; c)</code></li>\n<li>查找方法：<code>contains(Object o)</code> / <code>containsAll(Collection&lt;?&gt; c)</code></li>\n<li>查询集合自身信息；<code>size()</code> /  <code>isEmpty()</code></li>\n<li>···</li>\n</ul>\n<p>在 <code>Collection</code> 接口下，同样会将集合细分为不同的种类：</p>\n<ul>\n<li><code>Set</code> 接口：一个<strong>不允许存储重复元素</strong>的<strong>无序</strong>集合，具体实现有 <code>HashSet</code> / <code>TreeSet</code> ···</li>\n<li><code>List</code> 接口：一个<strong>可存储重复元素</strong>的<strong>有序</strong>集合，具体实现有 <code>ArrayList</code> / <code>LinkedList</code> ···</li>\n<li><code>Queue</code> 接口：一个<strong>可存储重复元素</strong>的<strong>队列</strong>，具体实现有 <code>PriorityQueue</code> / <code>ArrayDeque</code> ···</li>\n</ul>\n<h2 id=\"Map-集合体系详解\"><a href=\"#Map-集合体系详解\" class=\"headerlink\" title=\"Map 集合体系详解\"></a>Map 集合体系详解</h2><p><code>Map</code> 接口时由 <code>&lt;key,value&gt;</code> 组成的集合，由 <code>key</code> 映射到<strong>唯一</strong>的 <code>value</code>，所以 <code>Map</code> 不能包含重复的 <code>key</code> ，每个键<strong>至多</strong>映射一个值。下图是整个 Map 集合体系的主要组成部分：</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530122749.png\" alt=\"image-20210530122749775\"></p>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p>HashMap 是一个 <strong>最通用的</strong> 利用哈希表存储元素的集合，将元素放入 HashMap 时，将 <code>key</code> 的哈希值转换为数组的 <code>索引</code> 下标 <strong>确定存放位置</strong>，查找时，根据 <code>key</code> 的哈希地址转换成数组的 <code>索引</code> 下标 <strong>确定查找位置</strong>。</p>\n<p>HashMap 底层是用数组 + 链表 + 红黑树这三种数据结构实现，它是 <strong>非线程安全</strong> 的集合。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530124732.png\" alt=\"image-20210530124731984\"></p>\n<p>发送哈希冲突时，HashMap 的解决方法是将相同映射地址的元素连成一条 <code>链表</code>，如果链表的长度大于 <code>8</code> 时，且数组的长度大于 <code>64</code> 则会转换成 <code>红黑树</code> 数据结构。</p>\n<p> 关于 HashMap 的简要总结：</p>\n<ol>\n<li>它是集合中最常用的 <code>Map</code> 集合类型，底层由 <code>数组 + 链表 + 红黑树</code> 组成</li>\n<li>HashMap 不是线程安全的</li>\n<li>插入元素时，通过计算元素的 <code>哈希值</code>，通过 <strong>哈希映射函数</strong> 转换为 <code>数组下标</code>；查找元素时，同样通过哈希映射函数得到数组下标 <code>定位元素的位置</code></li>\n</ol>\n<h3 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h3><p>LinkedHashMap 可以看作是 <code>HashMap</code> 和 <code>LinkedList</code> 的结合：它在 HashMap 的基础上添加了一条双向链表，<code>默认</code> 存储各个元素的插入顺序，但由于这条双向链表，使得 LinkedHashMap 可以实现 <code>LRU</code> 缓存淘汰策略，因为我们可以设置这条双向链表按照 <code>元素的访问次序</code> 进行排序</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530175812.png\" alt=\"image-20210530175812409\"></p>\n<p>LinkedHashMap 是 HashMap 的子类，所以它具备 HashMap 的所有特点，其次，它在 HashMap 的基础上维护了一条 <code>双向链表</code>，该链表存储了 <strong>所有元素</strong>，<code>默认</code> 元素的顺序与插入顺序 <strong>一致</strong>。若 <code>accessOrder</code> 属性为 <code>true</code> ，则遍历顺序按元素的访问次序进行排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 头节点</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class=\"line\"><span class=\"comment\">// 尾节点</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure>\n\n<p>利用 LinkedHashMap 可以实现 <code>LRU</code> 缓存淘汰策略，因为它提供了一个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该方法可以移除 <code>最靠近链表头部</code> 的一个节点，而在 <code>get()</code> 方法中可以看到下面这段代码，起作用是挪动节点的位置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (accessOrder)&#123;</span><br><span class=\"line\">    afterNodeAccess(e);</span><br><span class=\"line\">&#125;      </span><br></pre></td></tr></table></figure>\n\n<p>只要调用了 <code>get()</code> 且 <code>accessOrder = true</code>，则会将该节点更新到链表 <code>尾部</code>，具体的逻辑在 <code>afterNodeAccess()</code> 中，感兴趣可翻看源码，这里不再展开：</p>\n<p>如果现在要实现一个 <code>LRU</code> 缓存策略，则需要做两件事：</p>\n<ul>\n<li>指定 <code>accessOrder = true</code> 可以设定链表按照访问顺序排列，通过提供的构造器可以设定 <code>accessOrder</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashMap</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity,<span class=\"type\">float</span> loadFactor,<span class=\"type\">boolean</span> accessOrder)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(initialCapacity, loadFactor);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.accessOrder = accessOrder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重写 <code>removeEldestEntry()</code> 方法，内部定义逻辑，通常是判断 <code>容量</code> 是否达到上限，若是则执行淘汰。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/qq_41231926/article/details/86173740\">LeetCode146——LRU缓存机制</a></p>\n</blockquote>\n<p>-关于 LinkedHashMap 主要介绍两点：</p>\n<ol>\n<li>它底层维护了一条 <code>双向链表</code>，因为继承了 HashMap，所以它也不是线程安全的</li>\n<li>LinkedHashMap 可实现 <code>LRU</code> 缓存淘汰策略，其原理是通过设置 <code>accessOrder</code> 为 <code>true</code> 并重写 <code>removeEldestEntry</code> 方法定义淘汰元素时需满足的条件</li>\n</ol>\n<h3 id=\"TreeMap\"><a href=\"#TreeMap\" class=\"headerlink\" title=\"TreeMap\"></a>TreeMap</h3><p>TreeMap 的底层实现是红黑树！</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530183426.png\" alt=\"image-20210530183425914\"></p>\n<p>TreeMap 是 <code>SortedMap</code> 的子类，所以它具有 排序 功能。它是基于 红黑树 数据结构实现的，每一个键值对 <code>&lt;key,value&gt;</code> 都是一个节点，默认情况下按照 <code>key</code> 自然排序，另一种是可以通过传入定制的 <code>Comparator</code> 进行自定义规则排序</p>\n<p>图中红黑树的每一个节点都是一个 <code>Entry</code> ，在这里为了图片的简洁性，就不标明 key 和 value 了，注意这些元素都是已经按照 <code>key</code> 排好序了，整个数据结构都是保持着 <code>有序</code> 的状态！</p>\n<p>关于 <code>自然</code> 排序与 <code>定制</code> 排序：</p>\n<ul>\n<li>自然排序：要求 <code>key</code> 必须实现 <code>Comparable</code> 接口。</li>\n</ul>\n<p>由于 <code>Integer</code> 类实现了 Comparable 接口，按照自然排序规则是按照 <code>key</code> 从小到大排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TreeMap&lt;Integer,String&gt; treeMap = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;&gt;();</span><br><span class=\"line\">treeMap.put(<span class=\"number\">2</span>,<span class=\"string\">&quot;TWO&quot;</span>);</span><br><span class=\"line\">treeMap.put(<span class=\"number\">1</span>,<span class=\"string\">&quot;ONE&quot;</span>);</span><br><span class=\"line\">System.out.print(treeMap);</span><br><span class=\"line\"><span class=\"comment\">// &#123;1=ONE,2=TWO&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定制排序：在初始化 TreeMap 时传入新的 <code>Comparator</code>，不要求 <code>key</code> 实现 Comparable 接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TreeMap&lt;Integer,String&gt; treeMap = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;&gt;((o1,o2) -&gt; Integer.compare(o2,o1));</span><br><span class=\"line\">treeMap.put(<span class=\"number\">2</span>,<span class=\"string\">&quot;TWO&quot;</span>);</span><br><span class=\"line\">treeMap.put(<span class=\"number\">1</span>,<span class=\"string\">&quot;ONE&quot;</span>);</span><br><span class=\"line\">treeMap.put(<span class=\"number\">3</span>,<span class=\"string\">&quot;Three&quot;</span>);</span><br><span class=\"line\">treeMap.put(<span class=\"number\">4</span>,<span class=\"string\">&quot;Four&quot;</span>);</span><br><span class=\"line\">System.out.print(treeMap);</span><br><span class=\"line\"><span class=\"comment\">// &#123;4=Four, 3=Three, 2=TWO, 1=ONE&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过传入新的 <code>Comparator</code> 比较器，可以覆盖默认的排序规则，上面的代码按照 <code>key</code> 降序排序，在实际应用中还可以按照其它规则自定义排序。</p>\n<p><code>compare()</code> 方法的返回值有三种，分别是：<code>0</code>，<code>-1</code>，<code>+1</code></p>\n<p>（1）如果返回 <code>0</code> ，代表两个元素相等，不需要调换顺序</p>\n<p>（2）如果返回 <code>+1</code> ，代表前面的元素需要与后面的元素调换位置</p>\n<p>（3）如果返回 <code>-1</code> ，代表前面的元素不需要与后面的元素调换位置</p>\n<p>而何时返回 <code>+1</code> 和 <code>-1</code>，则由我们自己去定义，JDK默认是按照 <strong>自然排序</strong>，而我们可以根据 <code>key</code> 的不同去定义降序还是升序排序。</p>\n<p>关于 TreeMap 主要介绍了两点：</p>\n<ol>\n<li>它底层是由 <code>红黑树</code> 这种数据结构实现的，所以操作的时间复杂度恒为 <code>0(logN)</code></li>\n<li>TreeMap 可以对 <code>key</code> 进行自然排序或者自定义排序，自定义排序时需要传入 <code>Comparator</code>，而自然排序要求 <code>key</code>实现了 <code>Comparable</code> 接口</li>\n<li>TreeMap 不是线程安全的。</li>\n</ol>\n<h3 id=\"WeakHashMap\"><a href=\"#WeakHashMap\" class=\"headerlink\" title=\"WeakHashMap\"></a>WeakHashMap</h3><p>WeakHashMap 日常开发中比较少见，它是基于普通的 <code>Map</code> 实现的，而里面 <code>Entry</code> 中的键在每一次的 <code>垃圾回收</code> 都会被清除掉，所以非常适合用于 <strong>短暂访问</strong>、<strong>仅访问一次</strong> 的元素，缓存在 <code>WeakHashMap</code> 中，并尽早地把它回收掉。</p>\n<p>当 <code>Entry</code> 被 <code>GC</code> 时，WeakHashMap 是如何感知到某个元素被回收的呢？</p>\n<p>在 WeakHashMap 内部维护了一个引用队列 <code>queue</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;Object&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>这个 queue 里包含了所有被 <code>GC</code> 掉的键，当JVM开启 <code>GC</code> 后，如果回收掉 WeakHashMap 中的 key，会将 key 放入 queue 中，在 <code>expungeStaleEntries()</code> 中遍历 queue，把 queue 中的所有 <code>key</code> 拿出来，并在 WeakHashMap 中删除掉，以达到 <strong>同步</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expungeStaleEntries</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"literal\">null</span>; ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 删除 WeakHashMap 中的该键值对</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是 WeakHashMap 底层存储的元素的数据结构是 <code>数组 + 链表</code>，<strong>没有红黑树</strong>哦，可以换一个角度想，如果还有红黑树，那干脆直接继承 HashMap ，然后再扩展不就行了，然而它并没有这样做：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakHashMap</span>&lt;K,V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractMap</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Map</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，WeakHashMap 的数据结构图如下：</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530211807.png\" alt=\"image-20210530211807636\"></p>\n<p>图中被虚线标识的元素将会在下一次访问 WeakHashMap 时删除掉，WeakHashMap 内部会做好一系列的调整工作，所以记住队列的作用就是标志那些已经被 <code>GC</code> 回收掉的元素。</p>\n<p>关于 WeakHashMap 需要注意两点：</p>\n<ol>\n<li>它的键是一种 <code>弱键</code>，放入 WeakHashMap 时，随时会被回收掉，所以不能确保某次访问元素一定存在</li>\n<li>它依赖普通的 <code>Map</code> 进行实现，是一个非线程安全的集合</li>\n<li>WeakHashMap 通常作为 <strong>缓存</strong> 使用，适用存储那些 <code>只需访问一次</code>、或 <code>只需保存短暂时间</code> 的键值对</li>\n</ol>\n<h3 id=\"HashTable\"><a href=\"#HashTable\" class=\"headerlink\" title=\"HashTable\"></a>HashTable</h3><p>HashTable 底层的存储结构是 <code>数组 + 链表</code>，而它是一个 <strong>线程安全</strong> 的集合，但是因为这个线程安全，它就被淘汰掉了。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530213300.png\" alt=\"image-20210530213300809\"></p>\n<blockquote>\n<p>这幅图是否有点眼熟呢哈哈哈，其实本质上就是 WeakHashMap 的底层存储结构。那么为什么 WeakHashMap 不继承 HashTable 呢？HashTable 的 <code>性能</code> 在并发环境下是非常差的，在非并发环境下可以用 <code>HashMap</code> 更优。</p>\n</blockquote>\n<p>HashTable 本质上是 HashMap 的前辈，它被淘汰的原因也主要因为两个字：<strong>性能</strong></p>\n<p>HashTable 是一个 <strong>线程安全</strong> 的Map，它所有的方法都被加上了 <strong>synchronized</strong> 关键字，也是因为这个关键字，它注定成为了时代的弃儿。</p>\n<p>HashTable 底层采用 数组+链表 存储键值对，由于被弃用，后人也没有对它进行任何改进</p>\n<p>HashTable 默认长度为 <code>11</code>，负载因子为 <code>0.75f</code>，即元素个数达到数组长度的 75% 时，会进行一次扩容，每次扩容为原来数组长度的 <code>2</code> 倍</p>\n<p>HashTable 所有的操作都是线程安全的。</p>\n<h2 id=\"Collection-集合体系详解\"><a href=\"#Collection-集合体系详解\" class=\"headerlink\" title=\"Collection 集合体系详解\"></a>Collection 集合体系详解</h2><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530222445.png\" alt=\"image-20210530222444963\"></p>\n<h3 id=\"Set-接口\"><a href=\"#Set-接口\" class=\"headerlink\" title=\"Set 接口\"></a>Set 接口</h3><p><code>Set</code> 接口继承了 <code>Collection</code> 接口，是一个不包括重复元素的集合，更确切地说，Set 中任意两个元素不会出现 <code>o1.equals(o2)</code>，而且 Set <strong>至多</strong> 只能存储一个 <code>NULL</code> 值元素，Set 集合的组成部分可以用下面这张图概括：</p>\n<img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210530225016.png\" alt=\"image-20210530225016622\" style=\"zoom: 50%;\" />\n\n<p>在 Set 集合体系中，我们需要关注两点：</p>\n<ul>\n<li>存入 <strong>可变元素</strong> 时，必须非常小心，因为任意时候元素状态的改变都有可能使得 Set 内部出现两个 <strong>相等</strong> 的元素，即 <code>o1.equals(o2) = true</code>，所以一般不要更改存入 Set 中的元素，否则将会破坏了 <code>equals()</code>  的作用！</li>\n<li>Set 的最大作用就是判重，在项目中的最大的作用也是 <strong>判重</strong>！</li>\n</ul>\n<p>接下来我们来分析它的实现类和子类：<code>AbstractSet</code> 和 <code>SortedSet</code></p>\n<h4 id=\"AbstractSet-抽象类\"><a href=\"#AbstractSet-抽象类\" class=\"headerlink\" title=\"AbstractSet 抽象类\"></a>AbstractSet 抽象类</h4><p><code>AbstractSet</code> 是一个实现 Set 的一个抽象类，定义在这里的方法可以将所有具体 Set 集合的 <strong>相同行为</strong> 在这里实现，<strong>避免子类包含大量的重复代码</strong></p>\n<p>所有的 Set 也应该要有相同的 <code>hashCode()</code> 和 <code>equals()</code> 方法，所以使用抽象类把该方法重写后，子类就无需关心这两个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractSet</span>&lt;E&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Set</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断两个 set 是否相等</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"built_in\">this</span>) <span class=\"comment\">// 集合本身</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> Set)) <span class=\"comment\">// 集合不是 set</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        Collection&lt;?&gt; c = (Collection&lt;?&gt;) o; <span class=\"comment\">// 比较两个集合中的元素是否全部相同</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c.size() != size())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> containsAll(c);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassCastException unused)   &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NullPointerException unused) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 计算所有元素的 hashcode 总和</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Iterator&lt;E&gt; i = iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">E</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (obj != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                h += obj.hashCode();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SortedSet-接口\"><a href=\"#SortedSet-接口\" class=\"headerlink\" title=\"SortedSet 接口\"></a>SortedSet 接口</h4><p><code>SortedSet</code> 是一个接口，它在 Set 的基础上扩展了 <strong>排序</strong> 的行为，所以所有实现它的子类都会拥有排序功能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">SortedSet</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Set</span>&lt;E&gt; &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 元素的比较器，决定元素的排列顺序</span></span><br><span class=\"line\">    Comparator&lt;? <span class=\"built_in\">super</span> E&gt; comparator();</span><br><span class=\"line\">\t<span class=\"comment\">// 获取 [from,to] 之间的 set</span></span><br><span class=\"line\">    SortedSet&lt;E&gt; <span class=\"title function_\">subSet</span><span class=\"params\">(E fromElement, E toElement)</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取以 to 开头的 set</span></span><br><span class=\"line\">    SortedSet&lt;E&gt; <span class=\"title function_\">headSet</span><span class=\"params\">(E toElement)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取以 from 结尾的 set</span></span><br><span class=\"line\">    SortedSet&lt;E&gt; <span class=\"title function_\">tailSet</span><span class=\"params\">(E fromElement)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取首个元素</span></span><br><span class=\"line\">    E <span class=\"title function_\">first</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取最后一个元素</span></span><br><span class=\"line\">    E <span class=\"title function_\">last</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h4><p>HashSet 底层是借助 <code>HashMap</code> 实现，我们可以观察它的多个构造方法，本质上都是 new 一个 HashMap</p>\n<blockquote>\n<p>这也是为什么我们先学习 Map 的原因！先学 Map ，再学 Set，有助于理解 Set ！</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HashSet</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractSet</span>&lt;E&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity, <span class=\"type\">float</span> loadFactor)</span> &#123;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以观察 <code>add()</code> 和 <code>remove()</code> 方法是如何将 HashSet 的操作嫁接到 HashMap 上的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">PRESENT</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">remove</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.remove(o)==PRESENT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到 <code>PRESENT</code> 就是一个 <strong>静态常量</strong> ：使用 PRESENT 作为 HashMap 的 value 值，使用 HashSet 的开发者只需要 <strong>关注</strong>  插入的 <code>key</code>，<strong>屏蔽</strong> 了 HashMap 的 <code>value</code></p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602103919.png\" alt=\"image-20210602103912091\"></p>\n<p>上图可以观察到每个 <code>Entry</code> 的 <code>value</code> 都是 PRESENT 空对象，我们就不用理会它了。</p>\n<p>HashSet  在 HashMap 基础上实现，所以很多地方可以联系到 HashMap：</p>\n<ul>\n<li>底层数据结构：HashSet 也是采用 <code>数组 + 链表 + 红黑树</code> 实现</li>\n<li>线程安全性：由于采用 HashMap 实现，而 HashMap 本身线程不安全，在 HashSet 中又没有额外添加同步策略，所以 HashSet 也 <strong>线程不安全</strong></li>\n<li>存入 HashSet 的对象的状态 <strong>最好不要发生变化</strong>，因为有可能改变状态后，在集合内部出现两个元素 <code>o1.equals(o2) == true</code>，破坏了 <code>equals</code> 的含义。</li>\n</ul>\n<h4 id=\"LinkedHashSet\"><a href=\"#LinkedHashSet\" class=\"headerlink\" title=\"LinkedHashSet\"></a>LinkedHashSet</h4><p>LinkedHashSet 的代码很少，不信我给你粘出来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LinkedHashSet</span>&lt;E&gt;</span><br><span class=\"line\">    <span class=\"keyword\">extends</span> <span class=\"title class_\">HashSet</span>&lt;E&gt;</span><br><span class=\"line\">    <span class=\"keyword\">implements</span> <span class=\"title class_\">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> -<span class=\"number\">2851667679971038690L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashSet</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity, <span class=\"type\">float</span> loadFactor)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(initialCapacity, loadFactor, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Link\t<span class=\"title function_\">edHashSet</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(initialCapacity, <span class=\"number\">.75f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(<span class=\"number\">16</span>, <span class=\"number\">.75f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashSet</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(Math.max(<span class=\"number\">2</span>*c.size(), <span class=\"number\">11</span>), <span class=\"number\">.75f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        addAll(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Spliterator&lt;E&gt; <span class=\"title function_\">spliterator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Spliterators.spliterator(<span class=\"built_in\">this</span>, Spliterator.DISTINCT | Spliterator.ORDERED);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码少归少，还是得分析一下，<code>LinkedHashSet</code> 继承了 <code>HashSet</code>，我们跟随到父类 HashSet 的构造方法看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashSet(<span class=\"type\">int</span> initialCapacity, <span class=\"type\">float</span> loadFactor, <span class=\"type\">boolean</span> dummy) &#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现父类中 map 的实现采用 <code>LinkedHashMap</code> ，这里注意不是 <code>HashMap</code> ，而 LinkedHashMap 底层又采用 HashMap + 双向链表 实现的，所以本质上 LinkedHashSet 还是使用 HashMap 实现的。</p>\n<blockquote>\n<p>LinkedHashSet -&gt; LinkedHashMap -&gt; HashMap + 双向链表</p>\n</blockquote>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602125701.png\" alt=\"image-20210602125701765\"></p>\n<p>而 LinkedHashMap 是采用 <code>HashMap</code> + <code>双向链表</code> 实现的，这条双向链表中保存了元素的插入顺序。所以 LinkedHashSet 可以按照元素的插入顺序遍历元素，如果你熟悉 <code>LinkedHashMap</code> ，那么 LinkedHashSet 也就不在话下了。</p>\n<p>关于 LinkedHashSet 需要注意的几个地方：</p>\n<ul>\n<li>它继承于 <code>HashSet</code>，而 HashSet 默认是采用 HashMap 存储数据的，但是 LinkedHashSet 调用父类的构造方法初始化 map 时是 LinkedHashMap 而不是 HashMap </li>\n<li>由于 LinkedHashMap 不是线程安全的，且在 LinkedHashSet 中没有添加额外的同步策略，所以 LinkedHashSet 集合<strong>也不是线程安全</strong> 的</li>\n</ul>\n<h4 id=\"TreeSet\"><a href=\"#TreeSet\" class=\"headerlink\" title=\"TreeSet\"></a>TreeSet</h4><p>TreeSet 是基于 TreeMap 的实现，所以存储的元素是有序的，底层的数据结构是 <code>数组 + 红黑树</code>。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602131111.png\" alt=\"image-20210602131111383\"></p>\n<p>而元素的排列顺序有 <code>2</code> 种，和 TreeMap 相同：自然排序和定制排序，常用的构造方法在下面已经展现出来了，TreeSet 默认使用自然排序，如果需要使用定制排序，需要传入 <code>Comparator</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">TreeSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;E,Object&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">TreeSet</span><span class=\"params\">(Comparator&lt;? <span class=\"built_in\">super</span> E&gt; comparator)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;&gt;(comparator));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于 TreeSet ，有几个值得注意的点：</p>\n<ul>\n<li><p>TreeSet 的所有操作都会转换为对 TreeMap 的操作，TreeMap 采用 <strong>红黑树</strong> 实现，任意操作的 <strong>时间复杂度</strong> 为 <code>0(logN)</code></p>\n</li>\n<li><p>TreeSet 是一个 <strong>线程不安全</strong> 的集合</p>\n</li>\n<li><p>TreeSet 常用于对 <strong>不重复</strong> 的元素 <strong>定制排序</strong>，如玩家战斗力排行榜</p>\n</li>\n</ul>\n<blockquote>\n<p>注意：TreeSet 判断元素是否重复的方法是判断 <strong>compareTo()</strong> 方法是否返回0，而不是调用 <strong>hashCode()</strong> 和 <strong>equals()</strong> 方法，如果返回 0 则认为集合内已存在相同的元素，不会再加入到集合当中。</p>\n</blockquote>\n<h3 id=\"List-接口\"><a href=\"#List-接口\" class=\"headerlink\" title=\"List 接口\"></a>List 接口</h3><p>List 接口和 Set 接口齐头并进，是我们日常开发过程中接触很多的一种集合类型了。整个 List 集合的组成部分如下图：</p>\n<img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602133220.png\" alt=\"image-20210602133220362\" style=\"zoom:50%;\" />\n\n<p><code>List</code> 接口直接继承于 Collection 接口，它定义为可以存储 <strong>重复</strong> 元素的集合，并且元素按照插入顺序 <strong>有序排列</strong>，且可以通过 <strong>索引</strong>访问指定位置的元素。常见的实现有：ArrayList、linkedList、Vector 和 Stack</p>\n<h4 id=\"AbstractList-和-AbstractSequentialList\"><a href=\"#AbstractList-和-AbstractSequentialList\" class=\"headerlink\" title=\"AbstractList 和 AbstractSequentialList\"></a>AbstractList 和 AbstractSequentialList</h4><p>AbstractList 抽象类实现了 List 接口，其内部实现了所有的 List 都需具备的功能，子类可以专注于实现自己具体的操作逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找元素 o 第一次出现的位置</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">indexOf</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">    ListIterator&lt;E&gt; it = listIterator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext())</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (it.next()==<span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> it.previousIndex();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext())</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(it.next()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> it.previousIndex();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找元素 o 最后一次出现的位置</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lastIndexOf</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">     ListIterator&lt;E&gt; it = listIterator(size());</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (o==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">while</span> (it.hasPrevious())</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (it.previous()==<span class=\"literal\">null</span>)</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> it.nextIndex();</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">while</span> (it.hasPrevious())</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (o.equals(it.previous()))</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> it.nextIndex();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>AbstractSequentialList 抽象类继承了 AbstractList ，在原基础上限制了访问元素的顺序 <strong>只能够按照顺序访问</strong>，而 <strong>不支持随机访问</strong>，如果需要满足随机访问的特性，则继承 AbstractList。子类 LinkedList 使用链表实现，所以仅能支持 <strong>顺序访问</strong>，故继承了 <code>AbstractSequentialList</code> 而不是 AbstractList。</p>\n<h4 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h4><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602140414.png\" alt=\"image-20210602140414443\"></p>\n<p><code>Vector</code> 在现在已经是一种过时的集合了，包括继承它的 <code>Stack</code> 集合也是如此，它们被淘汰的原因都是因为 <strong>性能</strong> 低下。</p>\n<blockquote>\n<p>JDK 1.0 时代，ArrayList 还没诞生，大家都是使用 Vector 集合，但由于 Vector 的 <strong>每个操作</strong> 都被 <strong>synchronized</strong> 关键字修饰，即使在线程安全的情况下， 仍然 <strong>进行着无意义的加锁/释放锁</strong>，造成额外的性能开销，做了无用功。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在 JDK 1.2 时，Collection 家族出现了，它提供了大量 <strong>高性能、适用于不同场合</strong> 的集合，而 Vector 也是其中一员，但由于 Vector 在每个方法上都加了锁，并且需要兼容许多的老项目，很难在这基础上优化 <code>Vector</code> 了，所以渐渐地也就被历史淘汰了。</p>\n<p>现在，在 <strong>线程安全</strong> 的情况下，不要选用 Vector 集合，取而代之的是 <strong>ArrayList</strong> 集合；在并发环境下，出现了 <code>CopyOnWriteArrayList</code>，Vector 被完全弃用了。</p>\n<h4 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h4><p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210602142433.png\" alt=\"image-20210602142433141\"></p>\n<p><code>Stack</code> 是一种 <code>后入先出（LIFO）</code> 型的集合容器，如图所示，<code>大雄</code> 是最后一个进入容器的，top 指针指向大雄，那么弹出元素时，大雄也是第一个被弹出去的。</p>\n<p>Stack 继承了 Vector 类，提供了栈顶的压入元素操作（push）和弹出元素（pop），以及查看栈顶元素（peek）等等，但由于继承于 Vector，Stack 也渐渐被淘汰了。</p>\n<p>取而代之的是后起之秀 <code>Deque</code> 接口，其实现有 <code>ArrayDeque</code>，该数据结构更加完善，可靠性更好，依靠队列也可以实现 <code>LIFO</code> 的栈操作，所以优先选择 ArrayDeque 实现栈。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deque&lt;Integer&gt; stact = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>ArrayDeque 的数据结构是：<code>数组</code> ，并提供 <strong>头尾指针下标</strong> 对数组元素进行操作。本文也会在接下来的内容中讲到，请接着往下看！</p>\n<h4 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h4><p>ArrayList 以 <strong>数组</strong> 作为存储结构，它是 <strong>线程不安全</strong> 的集合；具有 <strong>查询快、在数组中或头部增删慢</strong> 的特点，所以它除了线程不安全这一点，其余可以替代 <code>Vector</code> ，而且线程安全的 ArrayList 可以使用 <code>CopyOnWriteArrayList</code> 代替 Vector。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210603085739.png\" alt=\"image-20210603085732114\"></p>\n<p>关于 ArrayList 有几个重要的点需要注意：</p>\n<ul>\n<li>具有 <strong>随机访问</strong> 特点，<strong>访问元素的效率</strong> 较高，ArrayList 在 <strong>频繁插入、删除</strong> 集合元素的场景下效率较 <code>低</code></li>\n<li>底层数据结构：ArrayList 底层是使用数组作为存储结构，具有 <strong>查找快、增删慢</strong> 的特点</li>\n<li>线程安全性：ArrayList 是 <strong>线程不安全</strong> 的集合</li>\n<li>ArrayList <strong>首次扩容</strong> 后的长度为 <code>10</code>，调用 <code>add()</code> 时需要将计算容器 的最小容量。可以看到如果数组 <code>elementData</code> 为空数组，会将最小容量设置为 <code>10</code>，之后会将数组长度完成首次扩容到 10。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new ArrayList 时的默认空数组</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 默认容量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 计算该容器满足的最小容量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>集合从 <strong>第二次扩容</strong> 开始，数组长度将扩容为原来的 <code>1.5</code> 倍，即：<code>newLength = oldLength * 1.5</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h4><p>LinkedList 底层采用 <code>双向链表</code> 数据接口存储元素，由于链表的内存地址 <code>非连续</code>，所以它不具备随机访问的特点，但由于它利用指针连接各个元素，所以插入、删除元素只需要 <code>操作指针</code>，不需要 <code>移动元素</code>，故具有 <strong>增删快、查询慢</strong> 的特点。它也是一个非线程安全的集合。</p>\n<img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626130625.png\" alt=\"image-20210626130618786\"  />\n\n<p>由于以双向链表作为数据结构，它是 <strong>线程不安全</strong> 的集合；存储的每个节点称为一个 <code>Node</code> ，下图可以看到 Node 中保存了 <code>next</code> 和 <code>prev</code> 指针，<code>item</code> 是该节点的值。在插入和删除时，时间复杂度都保持为 <code>0(1)</code></p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626131638.png\" alt=\"image-20210626131638144\"></p>\n<p>关于 LinkedList，除了它是以链表实现的集合外，还有一些特殊的地方需要注意：</p>\n<ul>\n<li><p>优势：LinkedList 底层没有 <code>扩容机制</code>，使用 <code>双向链表</code> 存储元素，所以插入和删除元素效率较高，适用于频繁操作元素的场景</p>\n</li>\n<li><p>劣势：LinkedList 不具备 <code>随机访问</code> 的特点，查找某个元素只能从 <code>head</code> 或 <code>tail</code> 指针一个一个比较，所以 <strong>查找中间元素是效率很低</strong></p>\n</li>\n<li><p>查找优化：LinkedList 查找某个下标 <code>index</code> 的元素时做了优化，若 <code>index &lt; (size / 2)</code>，则从 <code>head</code> 往后查找，否则从 <code>tail</code> 开始往前查找，代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node&lt;E&gt; <span class=\"title function_\">node</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123; <span class=\"comment\">// 查找的下标处于链表的前半部分则从头开始找</span></span><br><span class=\"line\">        Node&lt;E&gt; x = first;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">// 查找的下标处于链表的后半部分则从尾开始找</span></span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>双端队列：使用双链表实现，并且实现了 <code>Deque</code> 接口，使得 LinkedList 可以用作 <strong>双端队列</strong> 。下图可以看到 Node 是集合中的元素，提供了前驱指针和后继指针，还提供了一系列操作 <code>头结点</code> 和 <code>尾结点</code> 的方法，具有双端队列的特性。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626133733.png\" alt=\"image-20210626133733427\">    </p>\n</li>\n</ul>\n<h3 id=\"Queue-接口\"><a href=\"#Queue-接口\" class=\"headerlink\" title=\"Queue 接口\"></a>Queue 接口</h3><p><code>Queue</code> 队列，在 JDK 中两种不同类型的集合实现： <strong>单向队列</strong>（AbstractQueue）和 <strong>双端队列</strong>（Deque）</p>\n<img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626152155.png\" alt=\"image-20210626152154946\" style=\"zoom:80%;\" />    \n\n<p>Queue 中提供了两套增加、删除元素的 API，当插入或删除元素失败时，会有两种不同的失败处理策略。</p>\n<table>\n<thead>\n<tr>\n<th>方法及失败策略</th>\n<th>插入方法</th>\n<th>删除方法</th>\n<th>查找方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>抛出异常</td>\n<td>add()</td>\n<td>remove()</td>\n<td>get()</td>\n</tr>\n<tr>\n<td>返回失败默认值</td>\n<td>offer()</td>\n<td>poll()</td>\n<td>peek()</td>\n</tr>\n</tbody></table>\n<p>选区哪种方法的决定因素：插入和删除元素失败时，希望 <code>抛出异常</code> 还是返回 <code>布尔值</code> </p>\n<p><code>add()</code> 和 <code>offer()</code> 对比：</p>\n<p>在队列长度大小确定的场景下，队列放满元素后，添加下一个元素时，add() 会抛出 <code>IllegalStateException</code> 异常，而 <code>offer()</code> 会返回 <code>false</code>。</p>\n<p>但是他们两个方法在插入 <strong>某些不合法的元素</strong> 时会抛出三个相同的异常：</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626153333.png\" alt=\"image-20210626153333747\">    </p>\n<p><code>remove()</code> 和 <code>poll()</code> 对比：</p>\n<p>在 <strong>队列为空</strong> 的场景下：<code>remove()</code> 会抛出 <code>NoSuchElmentException</code> 异常，而 <code>poll()</code> 则返回 <code>null</code>。</p>\n<p><code>get()</code> 和 <code>peek()</code> 对比：</p>\n<p>在队列为空的情况，<code>get()</code> 会抛出 <code>NoSuchElementException</code> 异常，而 <code>peek()</code> 则返回 <code>null</code>。</p>\n<h3 id=\"Deque-接口\"><a href=\"#Deque-接口\" class=\"headerlink\" title=\"Deque 接口\"></a>Deque 接口</h3><p><code>Deque</code> 接口的实现非常好理解：从 <strong>单向</strong> 队列演变为 <strong>双向</strong> 队列，内部额外提供 <strong>双向队列的操作方法</strong> 即可：</p>\n<img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626161113.png\" alt=\"image-20210626161106057\" style=\"zoom:80%;\" />    \n\n<p>Deque 接口额外提供了 <strong>针对队列的头结点和尾结点</strong> 操作的方法，而 <strong>插入、删除方法同样也提供了两套不同的失败策略</strong>。</p>\n<p>除了 <code>add()</code> 和 <code>offer()</code> ，<code>remove()</code> 和 <code>poll()</code> 以外，还有 <code>get()</code> 和 <code>peek()</code> 出现了不同的策略</p>\n<h4 id=\"AbstractQueue-抽象类\"><a href=\"#AbstractQueue-抽象类\" class=\"headerlink\" title=\"AbstractQueue 抽象类\"></a>AbstractQueue 抽象类</h4><p>AbstractQueue 类中提供了各个 API 的基本实现，主要针对各个不同的处理策略给出基本的方法实现，定义在这里的作用让 <code>子类</code> 根据其 <code>方法规范</code> （操作失败时抛出异常还是返回默认值）实现具体的业务逻辑。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210626162155.png\" alt=\"image-20210626162155775\">    </p>\n<h4 id=\"LinkedList-1\"><a href=\"#LinkedList-1\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h4><p>LinkedList 在上面已经详细解释了，它实现了 <code>Deque</code> 接口，提供了针对头结点和尾结点的操作，并且每个结点都有 <strong>前驱</strong> 和 <strong>后继</strong> 指针，具备双向队列的所有特性。</p>\n<h4 id=\"ArrayDeque\"><a href=\"#ArrayDeque\" class=\"headerlink\" title=\"ArrayDeque\"></a>ArrayDeque</h4><p>使用 <strong>数组</strong> 实现的双端队列，它是 <strong>无界</strong> 的双端队列，最小的容量是 <code>8</code> （JDK1.8）。在 JDK11 之后看到它默认容量已经是 <code>16</code> 了。</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210702150910.png\" alt=\"image-20210702150909935\"></p>\n<p><code>ArrayDeque</code> 在日常使用得不多，值得注意的是它与 <code>LinkedList</code> 的对比：<code>LinkedList</code> 采用链表实现双端队列，而 <code>ArrayDeque</code> 使用 <strong>数组</strong> 实现双端队列。</p>\n<blockquote>\n<p>在文档中作者写到：ArrayDeque 作为栈时比 Stack 性能好，作为队列时比  LinkedList 性能好</p>\n</blockquote>\n<p>由于双端队列 <strong>只能在头部和尾部</strong> 操作元素，所以删除元素和插入元素的时间复杂度大部分都稳定在 <code>0(1)</code>，除非在扩容时会涉及到元素的批量复制操作。但是在大多数情况下，使用它应该指定一个大概的数组长度，避免频繁的扩容。</p>\n<h4 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h4><p>PriorityQueue 基于 <strong>优先级堆实现</strong> 的优先级队列，而堆是采用 <strong>数组</strong> 实现的：</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210702153102.png\" alt=\"image-20210702153102716\"></p>\n<p>文档中的描述告诉我们：该数组中的元素通过传入 <code>Comparator</code> 进行定制排序，如果不传入 <code>Comparator</code> 时，则按照元素本身 <code>自然排序</code>，但要求元素实现了 <code>Comparable</code> 接口，所以 PriorityQueue  <strong>不允许存储 NULL 元素</strong>。</p>\n<p>PriorityQueue 应用场景：元素本身具有优先级，需要按照 <strong>优先级处理元素</strong> </p>\n<p>PriorityQueue 总结：</p>\n<ul>\n<li>PriorityQueue 是基于 <strong>优先级堆</strong> 实现的优先级队列，而堆是用 <strong>数组</strong> 维护的</li>\n<li>PriorityQueue 适用于 <strong>元素按优先级处理</strong> 的业务场景，例如用户在请求人工客服需要排队时，根据用户的 <strong>VIP等级</strong> 进行 <code>插队</code> 处理，等级越高，越先安排客服。</li>\n</ul>\n<p>各集合总结：（以 JDK1.8 为例）</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20210702155305.png\" alt=\"image-20210702155305221\"></p>\n","categories":[{"name":"后端开发","path":"api/categories/后端开发.json"}],"tags":[{"name":"技巧","path":"api/tags/技巧.json"},{"name":"笔记","path":"api/tags/笔记.json"}]}