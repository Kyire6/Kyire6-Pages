{"title":"Java 常见面试题","slug":"Java常见面试题","date":"2022-10-31T01:48:22.000Z","updated":"2022-11-21T01:34:38.000Z","comments":true,"path":"api/articles/Java常见面试题.json","excerpt":null,"covers":["https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103173519.png","https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221122165417.png"],"content":"<blockquote>\n<p>面试题节选自：<a href=\"https://javaguide.cn/\">Java 面试指南 | JavaGuide</a>、<a href=\"https://r2coding.com/#/\">Road 2 Coding | 编程自学之路</a></p>\n<p>每天一记，始终如一…</p>\n</blockquote>\n<h2 id=\"基础概念与常识\"><a href=\"#基础概念与常识\" class=\"headerlink\" title=\"基础概念与常识\"></a>基础概念与常识</h2><h3 id=\"Java-语言有哪些特点\"><a href=\"#Java-语言有哪些特点\" class=\"headerlink\" title=\"Java 语言有哪些特点?\"></a>Java 语言有哪些特点?</h3><ol>\n<li>简单易学；</li>\n<li>面向对象（封装，继承，多态）；</li>\n<li>平台无关性（Java 虚拟机实现平台无关性）；</li>\n<li>支持多线程</li>\n<li>可靠性；</li>\n<li>安全性；</li>\n<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>\n<li>编译与解释并存；</li>\n</ol>\n<blockquote>\n<p><code>一次编写，随处运行</code> 是 Java 经典的跨平台口号。</p>\n<p>但是目前市面上虚拟化技术已经非常成熟，通过 Docker 容器化技术就很容易实现跨平台。</p>\n<p>Java 最大的优势应该是强大的生态！</p>\n</blockquote>\n<h3 id=\"JVM-vs-JDK-vs-JRE\"><a href=\"#JVM-vs-JDK-vs-JRE\" class=\"headerlink\" title=\"JVM vs JDK vs JRE\"></a>JVM vs JDK vs JRE</h3><h4 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h4><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>\n<p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p>\n<p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比：<a href=\"https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines\">Comparison of Java virtual machinesopen in new window</a> ，感兴趣的可以去看看。并且，你可以在 <a href=\"https://docs.oracle.com/javase/specs/index.html\">Java SE Specificationsopen in new window</a> 上找到各个版本的 JDK 对应的 JVM 规范。</p>\n<h4 id=\"JDK-和-JRE\"><a href=\"#JDK-和-JRE\" class=\"headerlink\" title=\"JDK 和 JRE\"></a>JDK 和 JRE</h4><p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>\n<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>\n<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>\n<h3 id=\"什么是字节码？采用字节码的好处是什么？\"><a href=\"#什么是字节码？采用字节码的好处是什么？\" class=\"headerlink\" title=\"什么是字节码？采用字节码的好处是什么？\"></a>什么是字节码？采用字节码的好处是什么？</h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>\n<p><strong>Java 程序从源代码到运行的过程如下所示：</strong></p>\n<p><code>.java -&gt; javac 编译 -&gt; .class -&gt; 解释器&amp;JIT -&gt; 机器可理解的代码 -&gt; 机器运行</code></p>\n<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>\n<blockquote>\n<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。</p>\n</blockquote>\n<h3 id=\"AIT-和-AOT-的区别？为什么不全部使用-AOT-呢？\"><a href=\"#AIT-和-AOT-的区别？为什么不全部使用-AOT-呢？\" class=\"headerlink\" title=\"AIT 和 AOT 的区别？为什么不全部使用 AOT 呢？\"></a>AIT 和 AOT 的区别？为什么不全部使用 AOT 呢？</h3><ul>\n<li><p><strong>JIT（Just-in-Time，即时编译）</strong></p>\n</li>\n<li><p><strong>AOT（Ahead-of-Time，预编译）</strong></p>\n</li>\n</ul>\n<p>AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？</p>\n<p>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>\n<h3 id=\"为什么说-Java-语言“编译与解释并存”？\"><a href=\"#为什么说-Java-语言“编译与解释并存”？\" class=\"headerlink\" title=\"为什么说 Java 语言“编译与解释并存”？\"></a>为什么说 Java 语言“编译与解释并存”？</h3><ul>\n<li><strong>编译型：</strong><a href=\"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80\">编译型语言</a>会通过<a href=\"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8\">编译器</a>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译型语言有 C、C++、Go、Rust 等等。</li>\n<li><strong>解释型：</strong><a href=\"https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80\">解释型语言</a>会通过<a href=\"https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8\">解释器</a>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释型语言有 Python、JavaScript、PHP 等等。</li>\n</ul>\n<blockquote>\n<p><strong>维基百科中介绍：</strong></p>\n<p>为了改善编译语言的效率而发展出的<a href=\"https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF\">即时编译</a>技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成<a href=\"https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81\">字节码</a>。到执行期时，再将字节码直译，之后执行。<a href=\"https://zh.wikipedia.org/wiki/Java\">Java</a>与<a href=\"https://zh.wikipedia.org/wiki/LLVM\">LLVM</a>是这种技术的代表产物。</p>\n<p><strong>相关阅读：</strong><a href=\"https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html\">基本功 | Java 即时编译器原理解析及实践</a></p>\n</blockquote>\n<p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p>\n<p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h3 id=\"标识符和关键字的区别是什么？\"><a href=\"#标识符和关键字的区别是什么？\" class=\"headerlink\" title=\"标识符和关键字的区别是什么？\"></a>标识符和关键字的区别是什么？</h3><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</p>\n<p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 <strong>关键字</strong> 。简单来说，<strong>关键字是被赋予特殊含义的标识</strong>符 。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个“名字”就叫标识符。但是我们店的名字不能叫“警察局”，因为“警察局”这个名字已经被赋予了特殊的含义，而“警察局”就是我们日常生活中的关键字。</p>\n<h3 id=\"Java-语言关键字有哪些？true、false-和-null-是关键字吗？\"><a href=\"#Java-语言关键字有哪些？true、false-和-null-是关键字吗？\" class=\"headerlink\" title=\"Java 语言关键字有哪些？true、false 和 null 是关键字吗？\"></a>Java 语言关键字有哪些？true、false 和 null 是关键字吗？</h3><blockquote>\n<p>官方文档：<a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html\">Java 语言关键字 | (oracle.com)</a></p>\n</blockquote>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103173519.png\" alt=\"image-20221103173508830\"></p>\n<blockquote>\n<p>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</p>\n<p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p>\n<ul>\n<li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li>\n<li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li>\n<li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li>\n</ul>\n</blockquote>\n<p><strong>虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用</strong></p>\n<h3 id=\"continue、break-和-return-的区别是什么？\"><a href=\"#continue、break-和-return-的区别是什么？\" class=\"headerlink\" title=\"continue、break 和 return 的区别是什么？\"></a>continue、break 和 return 的区别是什么？</h3><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后，提前终止循环，这就需要用到下面几个关键词：</p>\n<ol>\n<li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li>\n<li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li>\n</ol>\n<p><code>return</code> 用于跳出所在的方法，结束该方法的运行。return 一般有两种用法：</p>\n<ol>\n<li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>\n<li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li>\n</ol>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><h4 id=\"成员变量与局部变量的区别？\"><a href=\"#成员变量与局部变量的区别？\" class=\"headerlink\" title=\"成员变量与局部变量的区别？\"></a>成员变量与局部变量的区别？</h4><ul>\n<li><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>、<code>private</code>、<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li>\n<li><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量存在于栈内存。</li>\n<li><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>\n<li><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外：被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>\n</ul>\n<h4 id=\"静态变量有什么作用？\"><a href=\"#静态变量有什么作用？\" class=\"headerlink\" title=\"静态变量有什么作用？\"></a>静态变量有什么作用？</h4><p>静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，他们都共享同一份静态变量。</p>\n<p>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p>\n<h4 id=\"字符型常量和字符串常量的区别？\"><a href=\"#字符型常量和字符串常量的区别？\" class=\"headerlink\" title=\"字符型常量和字符串常量的区别？\"></a>字符型常量和字符串常量的区别？</h4><ol>\n<li><p><strong>形式</strong>：字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p>\n</li>\n<li><p><strong>含义</strong>：字符常量相当于一个整型值(ASCII 值)，可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放的位置)。</p>\n</li>\n<li><p><strong>占内存大小</strong>：字符常量只占 2 个字节；字符串常量占若干个字节。</p>\n</li>\n</ol>\n<p><strong>(注意：<code>char</code> 在 Java 中占两个字节)</strong></p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><h4 id=\"静态方法为什么不能调用非静态成员？\"><a href=\"#静态方法为什么不能调用非静态成员？\" class=\"headerlink\" title=\"静态方法为什么不能调用非静态成员？\"></a>静态方法为什么不能调用非静态成员？</h4><ol>\n<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>\n<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>\n</ol>\n<h4 id=\"静态方法和实例方法有何不同？\"><a href=\"#静态方法和实例方法有何不同？\" class=\"headerlink\" title=\"静态方法和实例方法有何不同？\"></a>静态方法和实例方法有何不同？</h4><p><strong>1、调用方式</strong></p>\n<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。</p>\n<p><strong>2、访问类成员是否存在限制</strong></p>\n<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>\n<h4 id=\"重载和重写有什么区别？\"><a href=\"#重载和重写有什么区别？\" class=\"headerlink\" title=\"重载和重写有什么区别？\"></a>重载和重写有什么区别？</h4><blockquote>\n<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>\n<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>\n</blockquote>\n<p><strong>重载</strong></p>\n<p>发生在同一个类中（或者父类与之类之间），方法名必须相同，参数类型不同、个数不同，顺序不同，方法返回值和访问修饰符可以不同。</p>\n<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>\n<p><strong>重写</strong></p>\n<p>重写发生在运行期，是子类对付类的允许访问的方法的实现过程进行重新编写。</p>\n<ol>\n<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>\n<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>\n<li>构造方法无法被重写</li>\n</ol>\n<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">区别点</th>\n<th align=\"left\">重载方法</th>\n<th align=\"left\">重写方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">发生范围</td>\n<td align=\"left\">同一个类</td>\n<td align=\"left\">子类</td>\n</tr>\n<tr>\n<td align=\"left\">参数列表</td>\n<td align=\"left\">必须修改</td>\n<td align=\"left\">一定不能修改</td>\n</tr>\n<tr>\n<td align=\"left\">返回类型</td>\n<td align=\"left\">可修改</td>\n<td align=\"left\">子类方法返回值类型应比父类方法返回值类型更小或相等</td>\n</tr>\n<tr>\n<td align=\"left\">异常</td>\n<td align=\"left\">可修改</td>\n<td align=\"left\">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>\n</tr>\n<tr>\n<td align=\"left\">访问修饰符</td>\n<td align=\"left\">可修改</td>\n<td align=\"left\">一定不能做更严格的限制（可以降低限制）</td>\n</tr>\n<tr>\n<td align=\"left\">发生阶段</td>\n<td align=\"left\">编译期</td>\n<td align=\"left\">运行期</td>\n</tr>\n</tbody></table>\n<p><strong>方法的重写要遵循“两同两小一大”</strong></p>\n<ul>\n<li>”两同“即方法名相同、形参列表相同；</li>\n<li>”两小“指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类型应比父类方法抛出的异常类型更小或相等；</li>\n<li>”一大“指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>\n</ul>\n<blockquote>\n<p>关于 <strong>重写的返回值类型</strong> 这里需要额外说明一下：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>\n</blockquote>\n<h4 id=\"什么是可变长参数？\"><a href=\"#什么是可变长参数？\" class=\"headerlink\" title=\"什么是可变长参数？\"></a>什么是可变长参数？</h4><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个方法就可以接受 0 个或者多个参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method1</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">(String arg1,String... args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p>\n<p>会优先匹配固定参数的方法，因为固定参数的方法匹配度更高！</p>\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><h3 id=\"Java-中的几种基本数据类型了解吗？\"><a href=\"#Java-中的几种基本数据类型了解吗？\" class=\"headerlink\" title=\"Java 中的几种基本数据类型了解吗？\"></a>Java 中的几种基本数据类型了解吗？</h3><p>Java 中有 8 种基本数据类型，分别为：</p>\n<ul>\n<li>6 种数字类型：<ul>\n<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>\n<li>2 种浮点型：<code>float</code>、<code>double</code></li>\n</ul>\n</li>\n<li>1 种字符类型：<code>char</code></li>\n<li>1 种布尔型：<code>boolean</code></li>\n</ul>\n<p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">基本类型</th>\n<th align=\"left\">位数</th>\n<th align=\"left\">字节</th>\n<th align=\"left\">默认值</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>byte</code></td>\n<td align=\"left\">8</td>\n<td align=\"left\">1</td>\n<td align=\"left\">0</td>\n<td>-128 ~ 127</td>\n</tr>\n<tr>\n<td align=\"left\"><code>short</code></td>\n<td align=\"left\">16</td>\n<td align=\"left\">2</td>\n<td align=\"left\">0</td>\n<td>-32768 ~ 32767</td>\n</tr>\n<tr>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">32</td>\n<td align=\"left\">4</td>\n<td align=\"left\">0</td>\n<td>-2147483648 ~ 2147483647</td>\n</tr>\n<tr>\n<td align=\"left\"><code>long</code></td>\n<td align=\"left\">64</td>\n<td align=\"left\">8</td>\n<td align=\"left\">0L</td>\n<td>-9223372036854775808 ~ 9223372036854775807</td>\n</tr>\n<tr>\n<td align=\"left\"><code>char</code></td>\n<td align=\"left\">16</td>\n<td align=\"left\">2</td>\n<td align=\"left\">‘u0000’</td>\n<td>0 ~ 65535</td>\n</tr>\n<tr>\n<td align=\"left\"><code>float</code></td>\n<td align=\"left\">32</td>\n<td align=\"left\">4</td>\n<td align=\"left\">0f</td>\n<td>1.4E-45 ~ 3.4028235E38</td>\n</tr>\n<tr>\n<td align=\"left\"><code>double</code></td>\n<td align=\"left\">64</td>\n<td align=\"left\">8</td>\n<td align=\"left\">0d</td>\n<td>4.9E-324 ~ 1.7976931348623157E308</td>\n</tr>\n<tr>\n<td align=\"left\"><code>boolean</code></td>\n<td align=\"left\">1</td>\n<td align=\"left\"></td>\n<td align=\"left\">false</td>\n<td>true、false</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>\n<p>另外，Java 的每种基本数据类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Jav··a 编程思想》2.2 节有提到）。</p>\n</blockquote>\n<p><strong>注意</strong>：</p>\n<ol>\n<li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析；</li>\n<li><code>char a = &#39;h&#39;</code> 字符：单引号，<code>String a = &quot;hello&quot;</code> 字符串：双引号。</li>\n</ol>\n<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code>。</p>\n<h3 id=\"基本类型和包装类型的区别？\"><a href=\"#基本类型和包装类型的区别？\" class=\"headerlink\" title=\"基本类型和包装类型的区别？\"></a>基本类型和包装类型的区别？</h3><ul>\n<li>成员变量包装类型不赋值就是 <code>null</code>，而基本类型有默认值且不是 <code>null</code>；</li>\n<li>包装类型可用于泛型，而基本类型不可以；</li>\n<li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，而基本数据类型的成员变量（未被 <code>static</code> 修饰）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有的对象实例都存在于堆中；</li>\n<li>相比于对象类型，基本数据类型占用的空间非常小。</li>\n</ul>\n<p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行 <code>逃逸分析</code>，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。</p>\n<blockquote>\n<p><a href=\"https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html\">基本功 | Java即时编译器原理解析及实践 - 逃逸分析</a></p>\n</blockquote>\n<p><strong>注意：基本数据类型存放在栈中是一个常见的误区！</strong>基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该给要使用基本数据类型对应的包装类型），就存放在堆中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BasicTypeVar</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"包装类型的缓存机制了解吗？\"><a href=\"#包装类型的缓存机制了解吗？\" class=\"headerlink\" title=\"包装类型的缓存机制了解吗？\"></a>包装类型的缓存机制了解吗？</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>\n<p><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128,127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>Ture</code> or <code>False</code>。</p>\n<p><strong><code>Integer</code> 缓存源码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IntegerCache</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">low</span> <span class=\"operator\">=</span> -<span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> high;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// high value may be configured by property</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> <span class=\"number\">127</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong><code>Character</code> 缓存源码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Character <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">char</span> c)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c &lt;= <span class=\"number\">127</span>) &#123; <span class=\"comment\">// must cache</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> CharacterCache.cache[(<span class=\"type\">int</span>)c];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CharacterCache</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">CharacterCache</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Character cache[] = <span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>[<span class=\"number\">127</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; cache.length; i++)</span><br><span class=\"line\">            cache[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>((<span class=\"type\">char</span>)i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>Boolean</code> 缓存源码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">TRUE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">FALSE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Boolean <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">boolean</span> b)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (b ? TRUE : FALSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果超过对应范围仍然回去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>\n<p>两种浮点数类型的包装类 <code>Fload</code>、<code>Double</code> 并没有实现缓存机制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> <span class=\"number\">33</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> <span class=\"number\">33</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Float</span> <span class=\"variable\">i11</span> <span class=\"operator\">=</span> <span class=\"number\">333f</span>;</span><br><span class=\"line\"><span class=\"type\">Float</span> <span class=\"variable\">i22</span> <span class=\"operator\">=</span> <span class=\"number\">333f</span>;</span><br><span class=\"line\">System.out.println(i11 == i22);<span class=\"comment\">// 输出 false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Double</span> <span class=\"variable\">i3</span> <span class=\"operator\">=</span> <span class=\"number\">1.2</span>;</span><br><span class=\"line\"><span class=\"type\">Double</span> <span class=\"variable\">i4</span> <span class=\"operator\">=</span> <span class=\"number\">1.2</span>;</span><br><span class=\"line\">System.out.println(i3 == i4);<span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n\n<p>下面我们来看一下问题：下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> <span class=\"number\">40</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">40</span>);</span><br><span class=\"line\">System.out.println(i1 == i2);</span><br></pre></td></tr></table></figure>\n\n<p><code>Integer i1 = 40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1 = Integer.valueOf(40)</code>。因此，<code>i1</code> 直接使用的是缓存中的对象。而 <code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>\n<p>因此，答案是 <code>false</code>。</p>\n<p><strong>记住：所有整型包装类对象之间值的比较，全部使用 <code>equals</code> 方法比较。</strong></p>\n<h3 id=\"自动装箱与拆箱了解吗？原理是什么？\"><a href=\"#自动装箱与拆箱了解吗？原理是什么？\" class=\"headerlink\" title=\"自动装箱与拆箱了解吗？原理是什么？\"></a>自动装箱与拆箱了解吗？原理是什么？</h3><p><strong>什么是自动拆装箱？</strong></p>\n<ul>\n<li><strong>装箱：</strong>将基本类型用它们对应的引用类型包装起来；</li>\n<li><strong>拆箱：</strong>将包装类型转换为基本数据类型</li>\n</ul>\n<p>举例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>; <span class=\"comment\">// 装箱</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> i; <span class=\"comment\">// 拆箱</span></span><br></pre></td></tr></table></figure>\n\n<p>上面这两行代码对应的字节码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L1</span><br><span class=\"line\"></span><br><span class=\"line\"> LINENUMBER <span class=\"number\">8</span> L1</span><br><span class=\"line\"></span><br><span class=\"line\"> ALOAD <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"> BIPUSH <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class=\"line\"></span><br><span class=\"line\"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class=\"line\"></span><br><span class=\"line\">L2</span><br><span class=\"line\"></span><br><span class=\"line\"> LINENUMBER <span class=\"number\">9</span> L2</span><br><span class=\"line\"></span><br><span class=\"line\"> ALOAD <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"> ALOAD <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class=\"line\"></span><br><span class=\"line\"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class=\"line\"></span><br><span class=\"line\"> PUTFIELD AutoBoxTest.n : I</span><br><span class=\"line\"></span><br><span class=\"line\"> RETURN</span><br></pre></td></tr></table></figure>\n\n<p>从字节码中，我们发现装箱其实就是调用了包装类的 <code>valueOf</code> 方法，拆箱其实就是调用了 <code>xxxValue()</code> 方法。</p>\n<p>因此：</p>\n<ul>\n<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>\n<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>；</li>\n</ul>\n<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>\n<h3 id=\"为什么浮点数运算的时候会有精度丢失的风险？\"><a href=\"#为什么浮点数运算的时候会有精度丢失的风险？\" class=\"headerlink\" title=\"为什么浮点数运算的时候会有精度丢失的风险？\"></a>为什么浮点数运算的时候会有精度丢失的风险？</h3><p>浮点数运算精度丢失代码演示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">2.0f</span> - <span class=\"number\">1.9f</span>;</span><br><span class=\"line\"><span class=\"type\">float</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">1.8f</span> - <span class=\"number\">1.7f</span>;</span><br><span class=\"line\">System.out.println(a); <span class=\"comment\">// 0.100000024</span></span><br><span class=\"line\">System.out.println(b);<span class=\"comment\">// 0.099999905</span></span><br><span class=\"line\">System.out.println(a == b); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>为什么会出现这个问题呢？</p>\n<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储再计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>\n<p>就比如说十进制下的 0.2 就没办法精确转换为二进制小数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class=\"line\"><span class=\"comment\">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class=\"line\"><span class=\"number\">0.2</span> * <span class=\"number\">2</span> = <span class=\"number\">0.4</span> -&gt; <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0.4</span> * <span class=\"number\">2</span> = <span class=\"number\">0.8</span> -&gt; <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0.8</span> * <span class=\"number\">2</span> = <span class=\"number\">1.6</span> -&gt; <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0.6</span> * <span class=\"number\">2</span> = <span class=\"number\">1.2</span> -&gt; <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0.2</span> * <span class=\"number\">2</span> = <span class=\"number\">0.4</span> -&gt; <span class=\"number\">0</span>（发生循环）</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>关于浮点数的更多内容，建议看一下<a href=\"http://kaito-kidd.com/2018/08/08/computer-system-float-point/\">计算机系统基础（四）浮点数</a>这篇文章。</p>\n<h3 id=\"如何解决浮点数运算的精度丢失问题？\"><a href=\"#如何解决浮点数运算的精度丢失问题？\" class=\"headerlink\" title=\"如何解决浮点数运算的精度丢失问题？\"></a>如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部门需要将浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;1.0&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;0.9&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;0.8&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> a.subtract(b);</span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> b.subtract(c);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(x); <span class=\"comment\">/* 0.1 */</span></span><br><span class=\"line\">System.out.println(y); <span class=\"comment\">/* 0.1 */</span></span><br><span class=\"line\">System.out.println(Objects.equals(x, y)); <span class=\"comment\">/* true */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"超过-long-整型的数据应该如何表示？\"><a href=\"#超过-long-整型的数据应该如何表示？\" class=\"headerlink\" title=\"超过 long 整型的数据应该如何表示？\"></a>超过 long 整型的数据应该如何表示？</h3><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p>\n<p>在 Java 中，64 位 long 整型是最大的整数类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> Long.MAX_VALUE;</span><br><span class=\"line\">System.out.println(l + <span class=\"number\">1</span>); <span class=\"comment\">// -9223372036854775808</span></span><br><span class=\"line\">System.out.println(l + <span class=\"number\">1</span> == Long.MIN_VALUE); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整型数据。</p>\n<p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p>\n<h2 id=\"面向对象基础\"><a href=\"#面向对象基础\" class=\"headerlink\" title=\"面向对象基础\"></a>面向对象基础</h2><h3 id=\"面向对象和面向过程的区别？\"><a href=\"#面向对象和面向过程的区别？\" class=\"headerlink\" title=\"面向对象和面向过程的区别？\"></a>面向对象和面向过程的区别？</h3><p>两者的主要区别在于解决问题的方式不同：</p>\n<ul>\n<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题；</li>\n<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题；</li>\n</ul>\n<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>\n<h3 id=\"面向对象的三大特征\"><a href=\"#面向对象的三大特征\" class=\"headerlink\" title=\"面向对象的三大特征\"></a>面向对象的三大特征</h3><h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供外界访问的方法，那么这个类也没有什么意义了。</p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码地重用，程序的可维护性，节省大量创建新类的时间，提高我们的开发效率。</p>\n<p><strong>关于继承如下 3 点请记住：</strong></p>\n<ol>\n<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，<strong>只是拥有</strong></li>\n<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展</li>\n<li>子类可以用自己的方式实现父类的方法（以后介绍）  </li>\n</ol>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类打得引用指向子类的实例。</p>\n<p><strong>多态的特点：</strong></p>\n<ul>\n<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>\n<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>\n<li>多态不能调用“只在子类存在但在父类不存在”的方法</li>\n<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>\n</ul>\n<h3 id=\"接口和抽象类有什么共同点和区别？\"><a href=\"#接口和抽象类有什么共同点和区别？\" class=\"headerlink\" title=\"接口和抽象类有什么共同点和区别？\"></a>接口和抽象类有什么共同点和区别？</h3><p><strong>共同点：</strong></p>\n<ul>\n<li>都不能被实例化</li>\n<li>都可以包含抽象方法</li>\n<li>都可以有默认实现方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）</li>\n</ul>\n<p><strong>区别：</strong></p>\n<ul>\n<li>接口主要用于对类的行为进行约束，你是实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系</li>\n<li>一个类只能继承一个类，但是可以实现多个接口</li>\n<li>接口中成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认是 <code>default</code>，可在子类中被重新定义，也可被重新赋值</li>\n</ul>\n<h3 id=\"深拷贝和浅拷贝区别了解吗？什么是引用拷贝？\"><a href=\"#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？\" class=\"headerlink\" title=\"深拷贝和浅拷贝区别了解吗？什么是引用拷贝？\"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p>结论：</p>\n<ul>\n<li><p><strong>浅拷贝：</strong>浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是拷贝对象和原对象共用同一个内部对象</p>\n</li>\n<li><p><strong>浅拷贝：</strong>深拷贝会完全复制整个对象，包括这个对象所包含的内部对象</p>\n</li>\n</ul>\n<p>案例：</p>\n<p><strong>浅拷贝</strong></p>\n<p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p>\n<p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Address</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Cloneable</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Address <span class=\"title function_\">clone</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Address) <span class=\"built_in\">super</span>.clone();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AssertionError</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Cloneable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Address address;</span><br><span class=\"line\">    <span class=\"comment\">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Person <span class=\"title function_\">clone</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> (Person) <span class=\"built_in\">super</span>.clone();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> person;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AssertionError</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">person1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Address</span>(<span class=\"string\">&quot;武汉&quot;</span>));</span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">person1Copy</span> <span class=\"operator\">=</span> person1.clone();</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>\n\n<p>从输出结构就可以看出，<code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>\n<p><strong>深拷贝</strong></p>\n<p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Person <span class=\"title function_\">clone</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> (Person) <span class=\"built_in\">super</span>.clone();</span><br><span class=\"line\">        person.setAddress(person.getAddress().clone());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> person;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AssertionError</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">person1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Address</span>(<span class=\"string\">&quot;武汉&quot;</span>));</span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">person1Copy</span> <span class=\"operator\">=</span> person1.clone();</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>\n\n<p>从输出结果就可以看出，虽然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>\n<p><strong>那什么是引用拷贝呢？</strong>简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>\n<p>下图可以描述浅拷贝、深拷贝、引用拷贝：</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221122165417.png\" alt=\"浅拷贝、深拷贝、引用拷贝示意图\"></p>\n<h2 id=\"Java-常见类\"><a href=\"#Java-常见类\" class=\"headerlink\" title=\"Java 常见类\"></a>Java 常见类</h2><h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><h4 id=\"Object-类的常见方法有哪些？\"><a href=\"#Object-类的常见方法有哪些？\" class=\"headerlink\" title=\"Object 类的常见方法有哪些？\"></a>Object 类的常见方法有哪些？</h4><p>Object 类是一个特殊的类，是所有类的父类。主要提供有以下 11 个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> Class&lt;?&gt; getClass();</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">native</span> Object <span class=\"title function_\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notify</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notifyAll</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">long</span> timeout)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">long</span> timeout, <span class=\"type\">int</span> nanos)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"和-equals-的区别？\"><a href=\"#和-equals-的区别？\" class=\"headerlink\" title=\"== 和 equals() 的区别？\"></a>== 和 equals() 的区别？</h4><p><code>==</code> 对于基本类型来和引用类型的作用效果是不同的：</p>\n<ul>\n<li>对于基本数据类型来说，<code>==</code> 比较的是值</li>\n<li>对于引用类型来说，<code>==</code> 比较的是对象的内存地址</li>\n</ul>\n<blockquote>\n<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>\n</blockquote>\n<p><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code> 方法存在于 <code>Object</code> 类中，而 <code>Object</code> 类是所有类的直接或间接父类，因此所有的类都有 <code>equals()</code> 方法。 </p>\n<p><code>Object</code> 类 <code>equals()</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> (<span class=\"built_in\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>equals()</code> 方法存在两种使用情况：</p>\n<ul>\n<li><strong>类没有重写 <code>equals()</code> 方法</strong>：通过 <code>equals()</code> 方法比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code> 类 <code>equals()</code> 方法。</li>\n<li><strong>类重写了 <code>equals()</code> 方法</strong>：一般我们都重写 <code>equals()</code> 方法来比较两个对象中属性是否相等；若它们的属性相等，则返回 <code>true</code>（即认为这两个对象相等）。</li>\n</ul>\n<p><code>String</code> 类 <code>equals()</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object anObject)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">anotherString</span> <span class=\"operator\">=</span> (String)anObject;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> value.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> v1[] = value;</span><br><span class=\"line\">            <span class=\"type\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"hashCode-有什么用？\"><a href=\"#hashCode-有什么用？\" class=\"headerlink\" title=\"hashCode() 有什么用？\"></a>hashCode() 有什么用？</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数）</p>\n","more":"<blockquote>\n<p>面试题节选自：<a href=\"https://javaguide.cn/\">Java 面试指南 | JavaGuide</a>、<a href=\"https://r2coding.com/#/\">Road 2 Coding | 编程自学之路</a></p>\n<p>每天一记，始终如一…</p>\n</blockquote>\n<h2 id=\"基础概念与常识\"><a href=\"#基础概念与常识\" class=\"headerlink\" title=\"基础概念与常识\"></a>基础概念与常识</h2><h3 id=\"Java-语言有哪些特点\"><a href=\"#Java-语言有哪些特点\" class=\"headerlink\" title=\"Java 语言有哪些特点?\"></a>Java 语言有哪些特点?</h3><ol>\n<li>简单易学；</li>\n<li>面向对象（封装，继承，多态）；</li>\n<li>平台无关性（Java 虚拟机实现平台无关性）；</li>\n<li>支持多线程</li>\n<li>可靠性；</li>\n<li>安全性；</li>\n<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>\n<li>编译与解释并存；</li>\n</ol>\n<blockquote>\n<p><code>一次编写，随处运行</code> 是 Java 经典的跨平台口号。</p>\n<p>但是目前市面上虚拟化技术已经非常成熟，通过 Docker 容器化技术就很容易实现跨平台。</p>\n<p>Java 最大的优势应该是强大的生态！</p>\n</blockquote>\n<h3 id=\"JVM-vs-JDK-vs-JRE\"><a href=\"#JVM-vs-JDK-vs-JRE\" class=\"headerlink\" title=\"JVM vs JDK vs JRE\"></a>JVM vs JDK vs JRE</h3><h4 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h4><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>\n<p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p>\n<p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比：<a href=\"https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines\">Comparison of Java virtual machinesopen in new window</a> ，感兴趣的可以去看看。并且，你可以在 <a href=\"https://docs.oracle.com/javase/specs/index.html\">Java SE Specificationsopen in new window</a> 上找到各个版本的 JDK 对应的 JVM 规范。</p>\n<h4 id=\"JDK-和-JRE\"><a href=\"#JDK-和-JRE\" class=\"headerlink\" title=\"JDK 和 JRE\"></a>JDK 和 JRE</h4><p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>\n<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>\n<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>\n<h3 id=\"什么是字节码？采用字节码的好处是什么？\"><a href=\"#什么是字节码？采用字节码的好处是什么？\" class=\"headerlink\" title=\"什么是字节码？采用字节码的好处是什么？\"></a>什么是字节码？采用字节码的好处是什么？</h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>\n<p><strong>Java 程序从源代码到运行的过程如下所示：</strong></p>\n<p><code>.java -&gt; javac 编译 -&gt; .class -&gt; 解释器&amp;JIT -&gt; 机器可理解的代码 -&gt; 机器运行</code></p>\n<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>\n<blockquote>\n<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。</p>\n</blockquote>\n<h3 id=\"AIT-和-AOT-的区别？为什么不全部使用-AOT-呢？\"><a href=\"#AIT-和-AOT-的区别？为什么不全部使用-AOT-呢？\" class=\"headerlink\" title=\"AIT 和 AOT 的区别？为什么不全部使用 AOT 呢？\"></a>AIT 和 AOT 的区别？为什么不全部使用 AOT 呢？</h3><ul>\n<li><p><strong>JIT（Just-in-Time，即时编译）</strong></p>\n</li>\n<li><p><strong>AOT（Ahead-of-Time，预编译）</strong></p>\n</li>\n</ul>\n<p>AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？</p>\n<p>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>\n<h3 id=\"为什么说-Java-语言“编译与解释并存”？\"><a href=\"#为什么说-Java-语言“编译与解释并存”？\" class=\"headerlink\" title=\"为什么说 Java 语言“编译与解释并存”？\"></a>为什么说 Java 语言“编译与解释并存”？</h3><ul>\n<li><strong>编译型：</strong><a href=\"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80\">编译型语言</a>会通过<a href=\"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8\">编译器</a>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译型语言有 C、C++、Go、Rust 等等。</li>\n<li><strong>解释型：</strong><a href=\"https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80\">解释型语言</a>会通过<a href=\"https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8\">解释器</a>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释型语言有 Python、JavaScript、PHP 等等。</li>\n</ul>\n<blockquote>\n<p><strong>维基百科中介绍：</strong></p>\n<p>为了改善编译语言的效率而发展出的<a href=\"https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF\">即时编译</a>技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成<a href=\"https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81\">字节码</a>。到执行期时，再将字节码直译，之后执行。<a href=\"https://zh.wikipedia.org/wiki/Java\">Java</a>与<a href=\"https://zh.wikipedia.org/wiki/LLVM\">LLVM</a>是这种技术的代表产物。</p>\n<p><strong>相关阅读：</strong><a href=\"https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html\">基本功 | Java 即时编译器原理解析及实践</a></p>\n</blockquote>\n<p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p>\n<p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h3 id=\"标识符和关键字的区别是什么？\"><a href=\"#标识符和关键字的区别是什么？\" class=\"headerlink\" title=\"标识符和关键字的区别是什么？\"></a>标识符和关键字的区别是什么？</h3><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</p>\n<p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 <strong>关键字</strong> 。简单来说，<strong>关键字是被赋予特殊含义的标识</strong>符 。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个“名字”就叫标识符。但是我们店的名字不能叫“警察局”，因为“警察局”这个名字已经被赋予了特殊的含义，而“警察局”就是我们日常生活中的关键字。</p>\n<h3 id=\"Java-语言关键字有哪些？true、false-和-null-是关键字吗？\"><a href=\"#Java-语言关键字有哪些？true、false-和-null-是关键字吗？\" class=\"headerlink\" title=\"Java 语言关键字有哪些？true、false 和 null 是关键字吗？\"></a>Java 语言关键字有哪些？true、false 和 null 是关键字吗？</h3><blockquote>\n<p>官方文档：<a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html\">Java 语言关键字 | (oracle.com)</a></p>\n</blockquote>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221103173519.png\" alt=\"image-20221103173508830\"></p>\n<blockquote>\n<p>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</p>\n<p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p>\n<ul>\n<li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li>\n<li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li>\n<li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li>\n</ul>\n</blockquote>\n<p><strong>虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用</strong></p>\n<h3 id=\"continue、break-和-return-的区别是什么？\"><a href=\"#continue、break-和-return-的区别是什么？\" class=\"headerlink\" title=\"continue、break 和 return 的区别是什么？\"></a>continue、break 和 return 的区别是什么？</h3><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后，提前终止循环，这就需要用到下面几个关键词：</p>\n<ol>\n<li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li>\n<li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li>\n</ol>\n<p><code>return</code> 用于跳出所在的方法，结束该方法的运行。return 一般有两种用法：</p>\n<ol>\n<li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>\n<li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li>\n</ol>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><h4 id=\"成员变量与局部变量的区别？\"><a href=\"#成员变量与局部变量的区别？\" class=\"headerlink\" title=\"成员变量与局部变量的区别？\"></a>成员变量与局部变量的区别？</h4><ul>\n<li><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>、<code>private</code>、<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li>\n<li><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量存在于栈内存。</li>\n<li><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>\n<li><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外：被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>\n</ul>\n<h4 id=\"静态变量有什么作用？\"><a href=\"#静态变量有什么作用？\" class=\"headerlink\" title=\"静态变量有什么作用？\"></a>静态变量有什么作用？</h4><p>静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，他们都共享同一份静态变量。</p>\n<p>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p>\n<h4 id=\"字符型常量和字符串常量的区别？\"><a href=\"#字符型常量和字符串常量的区别？\" class=\"headerlink\" title=\"字符型常量和字符串常量的区别？\"></a>字符型常量和字符串常量的区别？</h4><ol>\n<li><p><strong>形式</strong>：字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p>\n</li>\n<li><p><strong>含义</strong>：字符常量相当于一个整型值(ASCII 值)，可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放的位置)。</p>\n</li>\n<li><p><strong>占内存大小</strong>：字符常量只占 2 个字节；字符串常量占若干个字节。</p>\n</li>\n</ol>\n<p><strong>(注意：<code>char</code> 在 Java 中占两个字节)</strong></p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><h4 id=\"静态方法为什么不能调用非静态成员？\"><a href=\"#静态方法为什么不能调用非静态成员？\" class=\"headerlink\" title=\"静态方法为什么不能调用非静态成员？\"></a>静态方法为什么不能调用非静态成员？</h4><ol>\n<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>\n<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>\n</ol>\n<h4 id=\"静态方法和实例方法有何不同？\"><a href=\"#静态方法和实例方法有何不同？\" class=\"headerlink\" title=\"静态方法和实例方法有何不同？\"></a>静态方法和实例方法有何不同？</h4><p><strong>1、调用方式</strong></p>\n<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。</p>\n<p><strong>2、访问类成员是否存在限制</strong></p>\n<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>\n<h4 id=\"重载和重写有什么区别？\"><a href=\"#重载和重写有什么区别？\" class=\"headerlink\" title=\"重载和重写有什么区别？\"></a>重载和重写有什么区别？</h4><blockquote>\n<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>\n<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>\n</blockquote>\n<p><strong>重载</strong></p>\n<p>发生在同一个类中（或者父类与之类之间），方法名必须相同，参数类型不同、个数不同，顺序不同，方法返回值和访问修饰符可以不同。</p>\n<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>\n<p><strong>重写</strong></p>\n<p>重写发生在运行期，是子类对付类的允许访问的方法的实现过程进行重新编写。</p>\n<ol>\n<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>\n<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>\n<li>构造方法无法被重写</li>\n</ol>\n<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">区别点</th>\n<th align=\"left\">重载方法</th>\n<th align=\"left\">重写方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">发生范围</td>\n<td align=\"left\">同一个类</td>\n<td align=\"left\">子类</td>\n</tr>\n<tr>\n<td align=\"left\">参数列表</td>\n<td align=\"left\">必须修改</td>\n<td align=\"left\">一定不能修改</td>\n</tr>\n<tr>\n<td align=\"left\">返回类型</td>\n<td align=\"left\">可修改</td>\n<td align=\"left\">子类方法返回值类型应比父类方法返回值类型更小或相等</td>\n</tr>\n<tr>\n<td align=\"left\">异常</td>\n<td align=\"left\">可修改</td>\n<td align=\"left\">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>\n</tr>\n<tr>\n<td align=\"left\">访问修饰符</td>\n<td align=\"left\">可修改</td>\n<td align=\"left\">一定不能做更严格的限制（可以降低限制）</td>\n</tr>\n<tr>\n<td align=\"left\">发生阶段</td>\n<td align=\"left\">编译期</td>\n<td align=\"left\">运行期</td>\n</tr>\n</tbody></table>\n<p><strong>方法的重写要遵循“两同两小一大”</strong></p>\n<ul>\n<li>”两同“即方法名相同、形参列表相同；</li>\n<li>”两小“指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类型应比父类方法抛出的异常类型更小或相等；</li>\n<li>”一大“指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>\n</ul>\n<blockquote>\n<p>关于 <strong>重写的返回值类型</strong> 这里需要额外说明一下：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>\n</blockquote>\n<h4 id=\"什么是可变长参数？\"><a href=\"#什么是可变长参数？\" class=\"headerlink\" title=\"什么是可变长参数？\"></a>什么是可变长参数？</h4><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个方法就可以接受 0 个或者多个参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method1</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">(String arg1,String... args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p>\n<p>会优先匹配固定参数的方法，因为固定参数的方法匹配度更高！</p>\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><h3 id=\"Java-中的几种基本数据类型了解吗？\"><a href=\"#Java-中的几种基本数据类型了解吗？\" class=\"headerlink\" title=\"Java 中的几种基本数据类型了解吗？\"></a>Java 中的几种基本数据类型了解吗？</h3><p>Java 中有 8 种基本数据类型，分别为：</p>\n<ul>\n<li>6 种数字类型：<ul>\n<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>\n<li>2 种浮点型：<code>float</code>、<code>double</code></li>\n</ul>\n</li>\n<li>1 种字符类型：<code>char</code></li>\n<li>1 种布尔型：<code>boolean</code></li>\n</ul>\n<p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">基本类型</th>\n<th align=\"left\">位数</th>\n<th align=\"left\">字节</th>\n<th align=\"left\">默认值</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>byte</code></td>\n<td align=\"left\">8</td>\n<td align=\"left\">1</td>\n<td align=\"left\">0</td>\n<td>-128 ~ 127</td>\n</tr>\n<tr>\n<td align=\"left\"><code>short</code></td>\n<td align=\"left\">16</td>\n<td align=\"left\">2</td>\n<td align=\"left\">0</td>\n<td>-32768 ~ 32767</td>\n</tr>\n<tr>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">32</td>\n<td align=\"left\">4</td>\n<td align=\"left\">0</td>\n<td>-2147483648 ~ 2147483647</td>\n</tr>\n<tr>\n<td align=\"left\"><code>long</code></td>\n<td align=\"left\">64</td>\n<td align=\"left\">8</td>\n<td align=\"left\">0L</td>\n<td>-9223372036854775808 ~ 9223372036854775807</td>\n</tr>\n<tr>\n<td align=\"left\"><code>char</code></td>\n<td align=\"left\">16</td>\n<td align=\"left\">2</td>\n<td align=\"left\">‘u0000’</td>\n<td>0 ~ 65535</td>\n</tr>\n<tr>\n<td align=\"left\"><code>float</code></td>\n<td align=\"left\">32</td>\n<td align=\"left\">4</td>\n<td align=\"left\">0f</td>\n<td>1.4E-45 ~ 3.4028235E38</td>\n</tr>\n<tr>\n<td align=\"left\"><code>double</code></td>\n<td align=\"left\">64</td>\n<td align=\"left\">8</td>\n<td align=\"left\">0d</td>\n<td>4.9E-324 ~ 1.7976931348623157E308</td>\n</tr>\n<tr>\n<td align=\"left\"><code>boolean</code></td>\n<td align=\"left\">1</td>\n<td align=\"left\"></td>\n<td align=\"left\">false</td>\n<td>true、false</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>\n<p>另外，Java 的每种基本数据类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Jav··a 编程思想》2.2 节有提到）。</p>\n</blockquote>\n<p><strong>注意</strong>：</p>\n<ol>\n<li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析；</li>\n<li><code>char a = &#39;h&#39;</code> 字符：单引号，<code>String a = &quot;hello&quot;</code> 字符串：双引号。</li>\n</ol>\n<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code>。</p>\n<h3 id=\"基本类型和包装类型的区别？\"><a href=\"#基本类型和包装类型的区别？\" class=\"headerlink\" title=\"基本类型和包装类型的区别？\"></a>基本类型和包装类型的区别？</h3><ul>\n<li>成员变量包装类型不赋值就是 <code>null</code>，而基本类型有默认值且不是 <code>null</code>；</li>\n<li>包装类型可用于泛型，而基本类型不可以；</li>\n<li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，而基本数据类型的成员变量（未被 <code>static</code> 修饰）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有的对象实例都存在于堆中；</li>\n<li>相比于对象类型，基本数据类型占用的空间非常小。</li>\n</ul>\n<p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行 <code>逃逸分析</code>，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。</p>\n<blockquote>\n<p><a href=\"https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html\">基本功 | Java即时编译器原理解析及实践 - 逃逸分析</a></p>\n</blockquote>\n<p><strong>注意：基本数据类型存放在栈中是一个常见的误区！</strong>基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该给要使用基本数据类型对应的包装类型），就存放在堆中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BasicTypeVar</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"包装类型的缓存机制了解吗？\"><a href=\"#包装类型的缓存机制了解吗？\" class=\"headerlink\" title=\"包装类型的缓存机制了解吗？\"></a>包装类型的缓存机制了解吗？</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>\n<p><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128,127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>Ture</code> or <code>False</code>。</p>\n<p><strong><code>Integer</code> 缓存源码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IntegerCache</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">low</span> <span class=\"operator\">=</span> -<span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> high;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// high value may be configured by property</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> <span class=\"number\">127</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong><code>Character</code> 缓存源码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Character <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">char</span> c)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c &lt;= <span class=\"number\">127</span>) &#123; <span class=\"comment\">// must cache</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> CharacterCache.cache[(<span class=\"type\">int</span>)c];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CharacterCache</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">CharacterCache</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Character cache[] = <span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>[<span class=\"number\">127</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; cache.length; i++)</span><br><span class=\"line\">            cache[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>((<span class=\"type\">char</span>)i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>Boolean</code> 缓存源码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">TRUE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Boolean</span> <span class=\"variable\">FALSE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Boolean <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">boolean</span> b)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (b ? TRUE : FALSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果超过对应范围仍然回去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>\n<p>两种浮点数类型的包装类 <code>Fload</code>、<code>Double</code> 并没有实现缓存机制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> <span class=\"number\">33</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> <span class=\"number\">33</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Float</span> <span class=\"variable\">i11</span> <span class=\"operator\">=</span> <span class=\"number\">333f</span>;</span><br><span class=\"line\"><span class=\"type\">Float</span> <span class=\"variable\">i22</span> <span class=\"operator\">=</span> <span class=\"number\">333f</span>;</span><br><span class=\"line\">System.out.println(i11 == i22);<span class=\"comment\">// 输出 false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Double</span> <span class=\"variable\">i3</span> <span class=\"operator\">=</span> <span class=\"number\">1.2</span>;</span><br><span class=\"line\"><span class=\"type\">Double</span> <span class=\"variable\">i4</span> <span class=\"operator\">=</span> <span class=\"number\">1.2</span>;</span><br><span class=\"line\">System.out.println(i3 == i4);<span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n\n<p>下面我们来看一下问题：下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> <span class=\"number\">40</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">40</span>);</span><br><span class=\"line\">System.out.println(i1 == i2);</span><br></pre></td></tr></table></figure>\n\n<p><code>Integer i1 = 40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1 = Integer.valueOf(40)</code>。因此，<code>i1</code> 直接使用的是缓存中的对象。而 <code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>\n<p>因此，答案是 <code>false</code>。</p>\n<p><strong>记住：所有整型包装类对象之间值的比较，全部使用 <code>equals</code> 方法比较。</strong></p>\n<h3 id=\"自动装箱与拆箱了解吗？原理是什么？\"><a href=\"#自动装箱与拆箱了解吗？原理是什么？\" class=\"headerlink\" title=\"自动装箱与拆箱了解吗？原理是什么？\"></a>自动装箱与拆箱了解吗？原理是什么？</h3><p><strong>什么是自动拆装箱？</strong></p>\n<ul>\n<li><strong>装箱：</strong>将基本类型用它们对应的引用类型包装起来；</li>\n<li><strong>拆箱：</strong>将包装类型转换为基本数据类型</li>\n</ul>\n<p>举例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>; <span class=\"comment\">// 装箱</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> i; <span class=\"comment\">// 拆箱</span></span><br></pre></td></tr></table></figure>\n\n<p>上面这两行代码对应的字节码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L1</span><br><span class=\"line\"></span><br><span class=\"line\"> LINENUMBER <span class=\"number\">8</span> L1</span><br><span class=\"line\"></span><br><span class=\"line\"> ALOAD <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"> BIPUSH <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class=\"line\"></span><br><span class=\"line\"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class=\"line\"></span><br><span class=\"line\">L2</span><br><span class=\"line\"></span><br><span class=\"line\"> LINENUMBER <span class=\"number\">9</span> L2</span><br><span class=\"line\"></span><br><span class=\"line\"> ALOAD <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"> ALOAD <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class=\"line\"></span><br><span class=\"line\"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class=\"line\"></span><br><span class=\"line\"> PUTFIELD AutoBoxTest.n : I</span><br><span class=\"line\"></span><br><span class=\"line\"> RETURN</span><br></pre></td></tr></table></figure>\n\n<p>从字节码中，我们发现装箱其实就是调用了包装类的 <code>valueOf</code> 方法，拆箱其实就是调用了 <code>xxxValue()</code> 方法。</p>\n<p>因此：</p>\n<ul>\n<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>\n<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>；</li>\n</ul>\n<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>\n<h3 id=\"为什么浮点数运算的时候会有精度丢失的风险？\"><a href=\"#为什么浮点数运算的时候会有精度丢失的风险？\" class=\"headerlink\" title=\"为什么浮点数运算的时候会有精度丢失的风险？\"></a>为什么浮点数运算的时候会有精度丢失的风险？</h3><p>浮点数运算精度丢失代码演示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">2.0f</span> - <span class=\"number\">1.9f</span>;</span><br><span class=\"line\"><span class=\"type\">float</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">1.8f</span> - <span class=\"number\">1.7f</span>;</span><br><span class=\"line\">System.out.println(a); <span class=\"comment\">// 0.100000024</span></span><br><span class=\"line\">System.out.println(b);<span class=\"comment\">// 0.099999905</span></span><br><span class=\"line\">System.out.println(a == b); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>为什么会出现这个问题呢？</p>\n<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储再计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>\n<p>就比如说十进制下的 0.2 就没办法精确转换为二进制小数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class=\"line\"><span class=\"comment\">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class=\"line\"><span class=\"number\">0.2</span> * <span class=\"number\">2</span> = <span class=\"number\">0.4</span> -&gt; <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0.4</span> * <span class=\"number\">2</span> = <span class=\"number\">0.8</span> -&gt; <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0.8</span> * <span class=\"number\">2</span> = <span class=\"number\">1.6</span> -&gt; <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0.6</span> * <span class=\"number\">2</span> = <span class=\"number\">1.2</span> -&gt; <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0.2</span> * <span class=\"number\">2</span> = <span class=\"number\">0.4</span> -&gt; <span class=\"number\">0</span>（发生循环）</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>关于浮点数的更多内容，建议看一下<a href=\"http://kaito-kidd.com/2018/08/08/computer-system-float-point/\">计算机系统基础（四）浮点数</a>这篇文章。</p>\n<h3 id=\"如何解决浮点数运算的精度丢失问题？\"><a href=\"#如何解决浮点数运算的精度丢失问题？\" class=\"headerlink\" title=\"如何解决浮点数运算的精度丢失问题？\"></a>如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部门需要将浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;1.0&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;0.9&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;0.8&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> a.subtract(b);</span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> b.subtract(c);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(x); <span class=\"comment\">/* 0.1 */</span></span><br><span class=\"line\">System.out.println(y); <span class=\"comment\">/* 0.1 */</span></span><br><span class=\"line\">System.out.println(Objects.equals(x, y)); <span class=\"comment\">/* true */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"超过-long-整型的数据应该如何表示？\"><a href=\"#超过-long-整型的数据应该如何表示？\" class=\"headerlink\" title=\"超过 long 整型的数据应该如何表示？\"></a>超过 long 整型的数据应该如何表示？</h3><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p>\n<p>在 Java 中，64 位 long 整型是最大的整数类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> Long.MAX_VALUE;</span><br><span class=\"line\">System.out.println(l + <span class=\"number\">1</span>); <span class=\"comment\">// -9223372036854775808</span></span><br><span class=\"line\">System.out.println(l + <span class=\"number\">1</span> == Long.MIN_VALUE); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整型数据。</p>\n<p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p>\n<h2 id=\"面向对象基础\"><a href=\"#面向对象基础\" class=\"headerlink\" title=\"面向对象基础\"></a>面向对象基础</h2><h3 id=\"面向对象和面向过程的区别？\"><a href=\"#面向对象和面向过程的区别？\" class=\"headerlink\" title=\"面向对象和面向过程的区别？\"></a>面向对象和面向过程的区别？</h3><p>两者的主要区别在于解决问题的方式不同：</p>\n<ul>\n<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题；</li>\n<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题；</li>\n</ul>\n<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>\n<h3 id=\"面向对象的三大特征\"><a href=\"#面向对象的三大特征\" class=\"headerlink\" title=\"面向对象的三大特征\"></a>面向对象的三大特征</h3><h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供外界访问的方法，那么这个类也没有什么意义了。</p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码地重用，程序的可维护性，节省大量创建新类的时间，提高我们的开发效率。</p>\n<p><strong>关于继承如下 3 点请记住：</strong></p>\n<ol>\n<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，<strong>只是拥有</strong></li>\n<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展</li>\n<li>子类可以用自己的方式实现父类的方法（以后介绍）  </li>\n</ol>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类打得引用指向子类的实例。</p>\n<p><strong>多态的特点：</strong></p>\n<ul>\n<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>\n<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>\n<li>多态不能调用“只在子类存在但在父类不存在”的方法</li>\n<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>\n</ul>\n<h3 id=\"接口和抽象类有什么共同点和区别？\"><a href=\"#接口和抽象类有什么共同点和区别？\" class=\"headerlink\" title=\"接口和抽象类有什么共同点和区别？\"></a>接口和抽象类有什么共同点和区别？</h3><p><strong>共同点：</strong></p>\n<ul>\n<li>都不能被实例化</li>\n<li>都可以包含抽象方法</li>\n<li>都可以有默认实现方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）</li>\n</ul>\n<p><strong>区别：</strong></p>\n<ul>\n<li>接口主要用于对类的行为进行约束，你是实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系</li>\n<li>一个类只能继承一个类，但是可以实现多个接口</li>\n<li>接口中成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认是 <code>default</code>，可在子类中被重新定义，也可被重新赋值</li>\n</ul>\n<h3 id=\"深拷贝和浅拷贝区别了解吗？什么是引用拷贝？\"><a href=\"#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？\" class=\"headerlink\" title=\"深拷贝和浅拷贝区别了解吗？什么是引用拷贝？\"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p>结论：</p>\n<ul>\n<li><p><strong>浅拷贝：</strong>浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是拷贝对象和原对象共用同一个内部对象</p>\n</li>\n<li><p><strong>浅拷贝：</strong>深拷贝会完全复制整个对象，包括这个对象所包含的内部对象</p>\n</li>\n</ul>\n<p>案例：</p>\n<p><strong>浅拷贝</strong></p>\n<p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p>\n<p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Address</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Cloneable</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Address <span class=\"title function_\">clone</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Address) <span class=\"built_in\">super</span>.clone();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AssertionError</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Cloneable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Address address;</span><br><span class=\"line\">    <span class=\"comment\">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Person <span class=\"title function_\">clone</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> (Person) <span class=\"built_in\">super</span>.clone();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> person;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AssertionError</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">person1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Address</span>(<span class=\"string\">&quot;武汉&quot;</span>));</span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">person1Copy</span> <span class=\"operator\">=</span> person1.clone();</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>\n\n<p>从输出结构就可以看出，<code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>\n<p><strong>深拷贝</strong></p>\n<p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Person <span class=\"title function_\">clone</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> (Person) <span class=\"built_in\">super</span>.clone();</span><br><span class=\"line\">        person.setAddress(person.getAddress().clone());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> person;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AssertionError</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">person1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Address</span>(<span class=\"string\">&quot;武汉&quot;</span>));</span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">person1Copy</span> <span class=\"operator\">=</span> person1.clone();</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>\n\n<p>从输出结果就可以看出，虽然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>\n<p><strong>那什么是引用拷贝呢？</strong>简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>\n<p>下图可以描述浅拷贝、深拷贝、引用拷贝：</p>\n<p><img src=\"https://my-typora-oss.oss-cn-shanghai.aliyuncs.com/image-master/20221122165417.png\" alt=\"浅拷贝、深拷贝、引用拷贝示意图\"></p>\n<h2 id=\"Java-常见类\"><a href=\"#Java-常见类\" class=\"headerlink\" title=\"Java 常见类\"></a>Java 常见类</h2><h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><h4 id=\"Object-类的常见方法有哪些？\"><a href=\"#Object-类的常见方法有哪些？\" class=\"headerlink\" title=\"Object 类的常见方法有哪些？\"></a>Object 类的常见方法有哪些？</h4><p>Object 类是一个特殊的类，是所有类的父类。主要提供有以下 11 个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> Class&lt;?&gt; getClass();</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">native</span> Object <span class=\"title function_\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notify</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notifyAll</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">long</span> timeout)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">long</span> timeout, <span class=\"type\">int</span> nanos)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"和-equals-的区别？\"><a href=\"#和-equals-的区别？\" class=\"headerlink\" title=\"== 和 equals() 的区别？\"></a>== 和 equals() 的区别？</h4><p><code>==</code> 对于基本类型来和引用类型的作用效果是不同的：</p>\n<ul>\n<li>对于基本数据类型来说，<code>==</code> 比较的是值</li>\n<li>对于引用类型来说，<code>==</code> 比较的是对象的内存地址</li>\n</ul>\n<blockquote>\n<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>\n</blockquote>\n<p><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code> 方法存在于 <code>Object</code> 类中，而 <code>Object</code> 类是所有类的直接或间接父类，因此所有的类都有 <code>equals()</code> 方法。 </p>\n<p><code>Object</code> 类 <code>equals()</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> (<span class=\"built_in\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>equals()</code> 方法存在两种使用情况：</p>\n<ul>\n<li><strong>类没有重写 <code>equals()</code> 方法</strong>：通过 <code>equals()</code> 方法比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code> 类 <code>equals()</code> 方法。</li>\n<li><strong>类重写了 <code>equals()</code> 方法</strong>：一般我们都重写 <code>equals()</code> 方法来比较两个对象中属性是否相等；若它们的属性相等，则返回 <code>true</code>（即认为这两个对象相等）。</li>\n</ul>\n<p><code>String</code> 类 <code>equals()</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object anObject)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">anotherString</span> <span class=\"operator\">=</span> (String)anObject;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> value.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> v1[] = value;</span><br><span class=\"line\">            <span class=\"type\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"hashCode-有什么用？\"><a href=\"#hashCode-有什么用？\" class=\"headerlink\" title=\"hashCode() 有什么用？\"></a>hashCode() 有什么用？</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数）</p>\n","categories":[{"name":"面试指北","path":"api/categories/面试指北.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"面试","path":"api/tags/面试.json"}]}